
  /*
  Scaffold
  homepage: <https://github.com/vladmandic/scaffold>
  author: <https://github.com/vladmandic>'
  */

var bK=Object.create,Og=Object.defineProperty,xK=Object.getPrototypeOf,wK=Object.prototype.hasOwnProperty,$K=Object.getOwnPropertyNames,vK=Object.getOwnPropertyDescriptor;var CK=x=>Og(x,"__esModule",{value:!0});var Lg=(x,Gt)=>()=>(Gt||(Gt={exports:{}},x(Gt.exports,Gt)),Gt.exports);var NK=(x,Gt,Zs)=>{if(Gt&&typeof Gt=="object"||typeof Gt=="function")for(let fn of $K(Gt))!wK.call(x,fn)&&fn!=="default"&&Og(x,fn,{get:()=>Gt[fn],enumerable:!(Zs=vK(Gt,fn))||Zs.enumerable});return x},kK=x=>x&&x.__esModule?x:NK(CK(Og(x!=null?bK(xK(x)):{},"default",{value:x,enumerable:!0})),x);var p$=Lg(()=>{});var f$=Lg(()=>{});var g$=Lg((md,m$)=>{(function(x,Gt){typeof md=="object"&&typeof m$!="undefined"?Gt(md):typeof define=="function"&&define.amd?define(["exports"],Gt):(x=x||self,Gt(x.tf=x.tf||{}))})(md,function(x){"use strict";let Gt=1e-7,Zs=1e-4;class fn{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class zr{refCount(t){return me("refCount")}incRef(t){return me("incRef")}timerAvailable(){return!0}time(t){return me("time")}read(t){return me("read")}readSync(t){return me("readSync")}numDataIds(){return me("numDataIds")}disposeData(t,e){return me("disposeData")}write(t,e,s){return me("write")}move(t,e,s,r,o){return me("move")}memory(){return me("memory")}floatPrecision(){return me("floatPrecision")}epsilon(){return this.floatPrecision()===32?Gt:Zs}dispose(){return me("dispose")}}function me(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function yd(n){let t=n.length,e=0,s=0;for(;t>0;)s=Math.random()*t|0,t--,e=n[t],n[t]=n[s],n[s]=e}function b$(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,s,r,o=0;for(;e>0;)o=Math.random()*e|0,e--,s=n[e],r=t[e],n[e]=n[o],t[e]=t[o],n[o]=s,t[o]=r}function Fa(n,t,e){return Math.max(n,Math.min(t,e))}function bd(n){return n%2==0?n:n+1}function Pg(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function x$(n,t){let e=Math.random();return t*e+(1-e)*n}function w$(n,t){let e=0;for(let s=0;s<n.length;s++){let r=Number(n[s])-Number(t[s]);e+=r*r}return e}function N(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function ge(n,t,e=""){N(At(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Qs(n){N(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ns(n,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(n)||ke(n)&&!e)for(let s=0;s<n.length;++s)ns(n[s],t,e);else t.push(n);return t}function H(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function $$(n){return n.length===0}function At(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function le(n){return n%1==0}function v$(n){if(Math.tanh!=null)return Math.tanh(n);if(n===Infinity)return 1;if(n===-Infinity)return-1;{let t=Math.exp(2*n);return(t-1)/(t+1)}}function sc(n){let t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function C$(n){let t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return yd(t),t}function tr(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function xd(n,t=s=>0,e){return new Promise((s,r)=>{let o=0,a=()=>{if(n()){s();return}o++;let i=t(o);if(e!=null&&o>=e){r();return}setTimeout(a,i)};a()})}function wd(n,t){let e=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let r=n.slice();return r[s]=t/e,r}function $t(n,t){let e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),N(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),N(n.every(s=>le(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function vs(n,t){let e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,o=t==null||r?null:$t(t,n).sort(),a=0;for(let i=0;i<n.length;++i){if(o!=null){if(o[a]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(o[a]==null||o[a]>i)&&n[i]===1&&(e.push(n[i]),s.push(i)),o[a]<=i&&a++}n[i]!==1&&(e.push(n[i]),s.push(i))}return{newShape:e,keptDims:s}}function ye(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${n}`);return e}function er(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function zg(n,t){for(let e=0;e<n.length;e++){let s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function Mg(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function $d(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function ke(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array}function rc(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Bg(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function Mn(n){return typeof n=="string"||n instanceof String}function Vg(n){return typeof n=="boolean"}function oc(n){return typeof n=="number"}function Mr(n){return Array.isArray(n)?Mr(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array?"int32":oc(n)?"float32":Mn(n)?"string":Vg(n)?"bool":"float32"}function Cs(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ac(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function pt(n){let t=n.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function Wg(n,t,e){let s=new Array;if(t.length===1){let r=t[0];for(let o=0;o<r;o++)s[o]=e[n+o]}else{let r=t[0],o=t.slice(1),a=o.reduce((i,l)=>i*l);for(let i=0;i<r;i++)s[i]=Wg(n+i*a,o,e)}return s}function sn(n,t){if(n.length===0)return t[0];let e=n.reduce((s,r)=>s*r);if(e===0)return[];if(e!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}.`);return Wg(0,n,t)}function vd(n,t){let e=Ie(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Ie(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function Cd(n,t){let e=n.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return sn(n,new Float32Array(e));if(t==="int32")return sn(n,new Int32Array(e));if(t==="bool")return sn(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Nd(n){n.forEach(t=>{N(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function In(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function Br(n,t,e){if(t===0)return[];if(t===1)return[n];let s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function nr(n){return n&&n.then&&typeof n.then=="function"}let Ug="tfjsflags";class Gg{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){let r=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(nr(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=N$(this.global.location.search);Ug in t&&t[Ug].split(",").forEach(s=>{let[r,o]=s.split(":");this.urlFlags[r]=I$(r,o)})}}function N$(n){let t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(k$(t,s[0],s[1]),s.join("="))),t}function k$(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function I$(n,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}function G(){return x.ENV}x.ENV=null;function S$(n){x.ENV=n}let kd;function Hg(){if(kd==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");kd=n}return kd}function T$(){let n=Hg();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Id(n,t){let e=T$();if(e.has(n))return e.get(n);{let s=t();return e.set(n,s),e.get(n)}}let _a="Abs",Vr="Acos",Wr="Acosh",sr="Add",Oa="AddN",ic="All",lc="Any",La="ArgMax",Pa="ArgMin",Ur="Asin",Gr="Asinh",Hr="Atan",jr="Atanh",qr="Atan2",za="AvgPool",cc="AvgPoolGrad",Ma="AvgPool3D",uc="AvgPool3DGrad",Ba="BatchMatMul",Va="BatchToSpaceND",hc="Bincount",jg="BroadcastTo",Kr="Cast",Xr="Ceil",Yr="ClipByValue",dc="Complex",Wa="ComplexAbs",Ua="Concat",Ga="Conv2D",pc="Conv2DBackpropFilter",Ha="Conv2DBackpropInput",ja="Conv3D",fc="Conv3DBackpropFilterV2",mc="Conv3DBackpropInputV2",Jr="Cos",Zr="Cosh",qa="Cumsum",gc="CropAndResize",yc="DenseBincount",bc="DepthToSpace",Ka="DepthwiseConv2dNative",xc="DepthwiseConv2dNativeBackpropFilter",wc="DepthwiseConv2dNativeBackpropInput",$c="Diag",Xa="Dilation2D",vc="Dilation2DBackpropInput",Cc="Dilation2DBackpropFilter",Qr="RealDiv",to="Elu",Nc="EluGrad",eo="Erf",Ya="Equal",no="Exp",Ja="ExpandDims",so="Expm1",kc="FFT",Ic="Fill",Sc="FlipLeftRight",ro="Floor",oo="FloorDiv",Za="FusedBatchNorm",Qa="GatherV2",Tc="GatherNd",ti="Greater",ao="GreaterEqual",io="Identity",Ec="IFFT",Ac="Imag",lo="IsFinite",co="IsInf",uo="IsNan",ei="LeakyRelu",ni="Less",si="LessEqual",Dc="LinSpace",ho="Log",po="Log1p",ri="LogicalAnd",oi="LogicalNot",ai="LogicalOr",qg="LogSoftmax",ii="LRN",Rc="LRNGrad",li="Max",fo="Maximum",ci="MaxPool",Fc="MaxPoolGrad",ui="MaxPool3D",_c="MaxPool3DGrad",Oc="MaxPoolWithArgmax",hi="Mean",di="Min",mo="Minimum",pi="MirrorPad",go="Mod",Lc="Multinomial",yo="Multiply",fi="Neg",mi="NotEqual",Pc="NonMaxSuppressionV3",zc="NonMaxSuppressionV4",Mc="NonMaxSuppressionV5",gi="OnesLike",yi="OneHot",bi="Pack",xi="PadV2",E$="Pool",bo="Pow",wi="Prelu",Bc="Prod",Vc="Range",Wc="Real",xo="Reciprocal",wo="Relu",$i="Reshape",vi="ResizeNearestNeighbor",Uc="ResizeNearestNeighborGrad",Ci="ResizeBilinear",Gc="ResizeBilinearGrad",$o="Relu6",Ni="Reverse",vo="Round",Co="Rsqrt",Hc="ScatterNd",ki="Select",No="Selu",Ii="Slice",ko="Sin",Io="Sinh",So="Sign",To="Sigmoid",Eo="Softplus",Ao="Sqrt",Si="Sum",Ti="SpaceToBatchND",Ei="SplitV",Ai="Softmax",Do="SquaredDifference",jc="Square",Ro="Sub",qc="SparseToDense",Kc="StridedSlice",Fo="Tan",_o="Tanh",Oo="Tile",Xc="TopK",Di="Transpose",Yc="Unique",Ri="Unpack",Fi="UnsortedSegmentSum",_i="ZerosLike",Lo="Step",Jc="FromPixels",Zc="RotateWithOffset",Oi="_FusedMatMul",Li="FusedConv2D",Pi="FusedDepthwiseConv2D";let Po=Id("kernelRegistry",()=>new Map),zi=Id("gradRegistry",()=>new Map);function Qc(n,t){let e=Td(n,t);return Po.get(e)}function Sd(n){return zi.get(n)}function tu(n){let t=Po.entries(),e=[];for(;;){let{done:s,value:r}=t.next();if(s)break;let[o,a]=r,[i]=o.split("_");i===n&&e.push(a)}return e}function eu(n){let{kernelName:t,backendName:e}=n,s=Td(t,e);Po.has(s)&&console.warn(`The kernel '${t}' for backend '${e}' is already registered`),Po.set(s,n)}function Kg(n){let{kernelName:t}=n;zi.has(t)&&G().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),zi.set(t,n)}function A$(n,t){let e=Td(n,t);if(!Po.has(e))throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);Po.delete(e)}function D$(n){if(!zi.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);zi.delete(n)}function R$(n,t){tu(n).forEach(s=>{let r=Object.assign({},s,{backendName:t});eu(r)})}function Td(n,t){return`${t}_${n}`}function ss(n,t){return t==="string"?rr(n):Ns([n],t)}function F$(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function Ns(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ns(n)),G().getBool("DEBUG")&&zg(n,t),F$(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){let e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Se(){return G().platform.now()}function Xg(n,t){return G().platform.fetch(n,t)}function rr(n,t="utf-8"){return t=t||"utf-8",G().platform.encode(n,t)}function or(n,t="utf-8"){return t=t||"utf-8",G().platform.decode(n,t)}var _$=Object.freeze({__proto__:null,createScalarValue:ss,toTypedArray:Ns,now:Se,fetch:Xg,encodeString:rr,decodeString:or,shuffle:yd,shuffleCombo:b$,clamp:Fa,nearestLargerEven:bd,sum:Pg,randUniform:x$,distSquared:w$,assert:N,assertShapesMatch:ge,assertNonNull:Qs,flatten:ns,sizeFromShape:H,isScalarShape:$$,arraysEqual:At,isInt:le,tanh:v$,sizeToSquarishShape:sc,createShuffledIndices:C$,rightPad:tr,repeatedTry:xd,inferFromImplicitShape:wd,parseAxisParam:$t,squeezeShape:vs,getTypedArrayFromDType:ye,getArrayFromDType:er,checkConversionForErrors:zg,isValidDtype:Mg,hasEncodingLoss:$d,isTypedArray:ke,bytesPerElement:rc,bytesFromStringArray:Bg,isString:Mn,isBoolean:Vg,isNumber:oc,inferDtype:Mr,isFunction:Cs,nearestDivisor:ac,computeStrides:pt,toNestedArray:sn,makeOnesTypedArray:vd,makeZerosTypedArray:Ie,makeZerosNestedTypedArray:Cd,assertNonNegativeIntegerDimensions:Nd,locToIndex:In,indexToLoc:Br,isPromise:nr});class O${constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new P$)}profileKernel(t,e,s){let r,o=()=>{r=s()},a,i=Se();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(let c of r)c.dataSync();a=Promise.resolve({kernelMs:Se()-i})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){let u=r[c];u.data().then(h=>{L$(h,u.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:s,timeMs:r,inputs:o,extraInfo:a}=t;s.forEach(i=>{Promise.all([i.data(),r,a]).then(l=>{this.logger.logKernelProfile(e,i,l[0],l[1],o,l[2])})})}}function L$(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){let r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class P${logKernelProfile(t,e,s,r,o,a){let i=typeof r=="number"?tr(`${r}ms`,9):r.error,l=tr(t,25),c=e.rank,u=e.size,h=tr(e.shape.toString(),14),d="";for(let p in o){let f=o[p];if(f!=null){let m=f.shape||e.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${i}	%c${c}D ${h}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function z$(n,t,e){let s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){let c=n[l],u=c.inputs;for(let h in u){let d=u[h],p=!1;for(let f=0;f<t.length;f++)if(s[d.id]){c.outputs.forEach(m=>s[m.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}let o={};o[e.id]=!0;let a={};for(let l=n.length-1;l>=0;l--){let c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(o[c.outputs[h].id]){for(let d in u)o[u[d].id]=!0,a[c.id]=!0;break}}let i=[];for(let l=0;l<n.length;l++){let c=n[l];if(r[c.id]&&a[c.id]){let u={};for(let d in c.inputs){let p=c.inputs[d];s[p.id]&&(u[d]=p)}let h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,i.push(h)}}return i}function M$(n,t,e,s){for(let r=t.length-1;r>=0;r--){let o=t[r],a=[];if(o.outputs.forEach(l=>{let c=n[l.id];c!=null?a.push(c):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);let i=o.gradient(a);for(let l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);let c=e(()=>i[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);let u=o.inputs[l];if(!At(c.shape,u.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{let h=n[u.id];n[u.id]=s(h,c),h.dispose()}}}}let Yg=20,Mi=3,Ed=7;function B$(n,t,e,s){let r=pt(t),o=V$(n,t,e,r),a=t.length,i=nu(n,t,e,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map(c=>"    "+c).join(`
`)),l.join(`
`)}function V$(n,t,e,s){let r=H(t),o=s[s.length-1],a=new Array(o).fill(0),i=t.length,l=e==="complex64"?Vi(n):n;if(i>1)for(let c=0;c<r/o;c++){let u=c*o;for(let h=0;h<o;h++)a[h]=Math.max(a[h],Bi(l[u+h],0,e).length)}return a}function Bi(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Ed))} + ${parseFloat(n[1].toFixed(Ed))}j`:Mn(n)?s=`'${n}'`:e==="bool"?s=Jg(n):s=parseFloat(n.toFixed(Ed)).toString(),tr(s,t)}function Jg(n){return n===0?"false":"true"}function nu(n,t,e,s,r,o=!0){let a=e==="complex64"?2:1,i=t[0],l=t.length;if(l===0){if(e==="complex64"){let m=Vi(n);return[Bi(m[0],0,e)]}return e==="bool"?[Jg(n[0])]:[n[0].toString()]}if(l===1){if(i>Yg){let g=Mi*a,y=Array.from(n.slice(0,g)),b=Array.from(n.slice((i-Mi)*a,i*a));return e==="complex64"&&(y=Vi(y),b=Vi(b)),["["+y.map((C,w)=>Bi(C,r[w],e)).join(", ")+", ..., "+b.map((C,w)=>Bi(C,r[i-Mi+w],e)).join(", ")+"]"]}let m=e==="complex64"?Vi(n):Array.from(n);return["["+m.map((g,y)=>Bi(g,r[y],e)).join(", ")+"]"]}let c=t.slice(1),u=s.slice(1),h=s[0]*a,d=[];if(i>Yg){for(let m=0;m<Mi;m++){let g=m*h,y=g+h;d.push(...nu(n.slice(g,y),c,e,u,r,!1))}d.push("...");for(let m=i-Mi;m<i;m++){let g=m*h,y=g+h;d.push(...nu(n.slice(g,y),c,e,u,r,m===i-1))}}else for(let m=0;m<i;m++){let g=m*h,y=g+h;d.push(...nu(n.slice(g,y),c,e,u,r,m===i-1))}let p=l===2?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function Vi(n){let t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class ce{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=H(t),s!=null){let r=s.length;N(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||er(e,this.size),this.strides=pt(t)}set(t,...e){e.length===0&&(e=[0]),N(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let r of t){if(r<0||r>=this.shape[e]){let o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Bn().makeTensor(this.values,this.shape,this.dtype)}}let Bn=null,zo=null,Zg=null;function W$(n){Bn=n}function U$(n){zo=n}function G$(n){Zg=n}class Dt{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=H(t),this.strides=pt(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return zo.buffer(this.shape,this.dtype,t)}bufferSync(){return zo.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return sn(this.shape,t)}arraySync(){return sn(this.shape,this.dataSync())}async data(){this.throwIfDisposed();let t=Bn().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(s=>or(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();let t=Bn().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>or(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Bn().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Bn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return zo.print(this,t)}clone(){return this.throwIfDisposed(),zo.clone(this)}toString(t=!1){let e=this.dataSync();return B$(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),zo.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Bn().makeVariable(this,t,e,s)}}Object.defineProperty(Dt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function W(){return Id("Tensor",()=>Dt)}W();class Wi extends Dt{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r);this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!At(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Bn().disposeTensor(this),this.dataId=t.dataId,Bn().incRef(this,null)}dispose(){Bn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Wi,Symbol.hasInstance,{value:n=>n instanceof Dt&&n.assign!=null&&n.assign instanceof Function});(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(x.Rank||(x.Rank={}));var Ad;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Ad||(Ad={}));var Dd;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Dd||(Dd={}));var Rd;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Rd||(Rd={}));var Fd;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Fd||(Fd={}));let H$={float32:Rd,int32:Ad,bool:Dd,complex64:Fd};function Ge(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return H$[n][t]}function su(n){return Ge(n,"int32")}function Xt(n,t){if(n.dtype===t.dtype)return[n,t];let e=Ge(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function Qg(n,t){N(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function ru(n,t){return t.some(e=>e.id===n.id)}function rs(n){let t=[],e=new Set;return ty(n,t,e),t}function ty(n,t,e){if(n==null)return;if(n instanceof Dt){t.push(n);return}if(!j$(n))return;let s=n;for(let r in s){let o=s[r];e.has(o)||(e.add(o),ty(o,t,e))}}function j$(n){return Array.isArray(n)||typeof n=="object"}var q$=Object.freeze({__proto__:null,makeTypesMatch:Xt,assertTypesMatch:Qg,isTensorInList:ru,getTensorsInContainer:rs});function _d(n){return n.kernelName!=null}class ey{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Mo{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ey}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new O$(this.backendInstance),!0}setupRegisteredKernels(){tu(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){tu(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let s=e.factory();if(s&&!(s instanceof zr)&&typeof s.then=="function"){let r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return console.warn(`Initialization of backend ${t} failed`),console.warn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let s=t[e],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let s=this.state.tensorInfo.get(e),r=s.backend,o=this.readSync(e),a=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{let r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return Mo.nextTensorId++}nextVariableId(){return Mo.nextVariableId++}clone(t){let e=A.runKernel(io,{x:t}),s={x:t},r=a=>({x:()=>{let i="float32",l={x:a},c={dtype:i};return A.runKernel(Kr,l,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,o,{}),e}runKernel(t,e,s){if(!(Qc(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){let r=this.backend.numDataIds(),o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[],r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l,c=_d(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_d(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let y=Qc(f,this.backendName);N(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{let b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,C);let w=C.map(v=>{if(v.rank!=null)return v;let{dataId:I,shape:k,dtype:T}=v;return this.makeTensorFromDataId(I,k,T)});if(r){let v=this.getTensorsForGradient(f,m,w);s=this.saveTensorsForBackwardMode(v)}return w}}else{let{forwardFunc:f}=t,m=g=>{!r||(s=g.map(y=>this.keep(this.clone(y))))};i=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}let{inputs:u,attrs:h}=t,d=_d(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=i():(p=this.profiler.profileKernel(c,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs)}),r&&this.addTapeNode(c,u,e,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:e.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){let r=Sd(t);if(r!=null){let o=r.inputsToSave||[],a=r.outputsToSave||[],i;r.saveAllInputs?(N(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(c=>e[c])):i=o.map(c=>e[c]);let l=s.filter((c,u)=>a[u]);return i.concat(l)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=t;s==="string"&&Mn(t[0])&&(o=t.map(l=>rr(l)));let a=r.write(o,e,s),i=new Dt(e,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){let l=this.state.tensorInfo.get(a),c=Bg(o);this.state.numBytes+=c-l.bytes,l.bytes=c}return i}makeTensorFromDataId(t,e,s,r){s=s||"float32";let o=new Dt(e,s,t,this.nextTensorId());return this.trackTensor(o,r),o}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let o=new Wi(t,e,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*rc(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Wi||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let s=t.size*rc(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,o,a){let i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:o},l=Sd(t);l!=null&&(r=l.gradFunc),r!=null&&(i.gradient=c=>(c=c.map((u,h)=>{if(u==null){let d=s[h],p=Ie(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),r(c.length>1?c:c[0],o,a))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=rs(t),s=new Set(e.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){let a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(t,e,s,r=!1){if(N(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);let o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));N(o instanceof Dt,()=>"The result y returned by f() must be a tensor.");let a=z$(this.state.activeTape,e,o);if(!r&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[o.id]=s==null?K$(o.shape):s,M$(i,a,c=>this.tidy(c),X$);let l=e.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let u of c.saved)u.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(t){return N(Cs(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{N(e.every(i=>i instanceof Dt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s,r={};e.forEach((i,l)=>{r[l]=i});let o=(i,l)=>(s=t(...e,l),N(s.value instanceof Dt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),N(Cs(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,l)=>{let c=s.gradFunc(i,l),u=Array.isArray(c)?c:[c];N(u.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),N(u.every(d=>d instanceof Dt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){let e=Se(),s=await this.backend.time(t);return s.wallMs=Se()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ey;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Mo.nextTensorId=0,Mo.nextVariableId=0;function K$(n){let t=vd(H(n),"float32");return A.makeTensor(t,n,"float32")}function ny(){let n=Hg();if(n._tfengine==null){let t=new Gg(n);n._tfengine=new Mo(t)}return S$(n._tfengine.ENV),W$(()=>n._tfengine),n._tfengine}let A=ny();function X$(n,t){let e={a:n,b:t};return A.runKernel(sr,e)}function Y$(){return typeof navigator!="undefined"&&navigator!=null}function sy(){if(Y$()){let n=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function Od(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var J$=Object.freeze({__proto__:null,isMobile:sy,isBrowser:Od});let Vn=G();Vn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Vn.registerFlag("IS_BROWSER",()=>Od()),Vn.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined"),Vn.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Vn.registerFlag("PROD",()=>!1),Vn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Vn.getBool("DEBUG")),Vn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Vn.registerFlag("IS_TEST",()=>!1),Vn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);function Wn(n,t){let e=n;if(ke(n))return t==="string"?[]:[n.length];if(!Array.isArray(n))return[];let s=[];for(;Array.isArray(e)||ke(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ry(n,s,[]),s}function ry(n,t,e){if(e=e||[],!Array.isArray(n)&&!ke(n)){N(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}N(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),N(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);let s=t.slice(1);for(let r=0;r<n.length;++r)ry(n[r],s,e.concat(r))}function oy(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function S(n,t,e,s="numeric"){if(n instanceof Dt)return oy(s,n.dtype,t,e),n;let r=Mr(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),oy(s,r,t,e),n==null||!ke(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){let l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}let o=Wn(n,r);!ke(n)&&!Array.isArray(n)&&(n=[n]);let i=r!=="string"?Ns(n,r):ns(n,[],!0);return A.makeTensor(i,o,r)}function Ui(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,a)=>S(o,`${t}[${a}]`,e,s))}let ay="__op";function D(n){let t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+ay;let r=(...o)=>{A.startScope(e);try{let a=s(...o);return nr(a)&&console.error("Cannot return a Promise inside of tidy."),A.endScope(a),a}catch(a){throw A.endScope(null),a}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function Z$(n,t){let e=S(n,"real","complex"),s=S(t,"imag","complex");ge(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);let r={real:e,imag:s};return A.runKernel(dc,r)}let ks=D({complex_:Z$});function Is(n,t,e,s){if(s==null&&(s=Mr(n)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!ke(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Nd(t);let r=H(t),o=H(e);N(r===o,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<e.length;++a){let i=e[a],l=a===e.length-1?i!==H(t.slice(a)):!0;N(e[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!ke(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?Ns(n,s):ns(n,[],!0),A.makeTensor(n,t,s)}function Sn(n,t,e){let s=Wn(n,e);return Is(n,t,s,e)}let Ld={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};let ou=4;async function Pd(n,t){let e=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){let i=r[a],l=Array.isArray(n)?n[a].tensor:n[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);let c={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async h=>{let d=await l.bytes(),p=d.reduce((g,y)=>g+y.length,0)+ou*d.length,f=new Uint8Array(p),m=0;for(let g=0;g<d.length;g++){let y=d[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=ou,f.set(y,m),m+=y.length}h(f)});s.push(u)}else s.push(l.data());t!=null&&(c.group=t),e.push(c)}let o=await Promise.all(s);return{data:Q$(o),specs:e}}function au(n,t){let e={},s,r=0;for(let o of t){let a=o.name,i=o.dtype,l=o.shape,c=H(l),u;if("quantization"in o){let h=o.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${o.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=Ld[h.dtype],p=n.slice(r,r+c*d),f=h.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(i==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];u[m]=g*h.scale+h.min}}else if(h.dtype==="float16")s===void 0&&(s=ov()),u=s(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(i==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];u[m]=Math.round(g*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=c*d}else if(i==="string"){let h=H(o.shape);u=[];for(let d=0;d<h;d++){let p=new Uint32Array(n.slice(r,r+ou))[0];r+=ou;let f=new Uint8Array(n.slice(r,r+p));u.push(f),r+=p}}else{let h=Ld[i],d=n.slice(r,r+c*h);if(i==="float32")u=new Float32Array(d);else if(i==="int32")u=new Int32Array(d);else if(i==="bool")u=new Uint8Array(d);else if(i==="complex64"){u=new Float32Array(d);let p=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let y=0;y<p.length;y++)p[y]=u[y*2],f[y]=u[y*2+1];let m=Sn(p,l,"float32"),g=Sn(f,l,"float32");e[a]=ks(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=c*h}i!=="complex64"&&(e[a]=Sn(u,l,i))}return e}function Q$(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0,e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});let s=new Uint8Array(t),r=0;return e.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}let zd=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function iy(n){return zd?Buffer.byteLength(n):new Blob([n]).size}function tv(n){if(zd)return Buffer.from(n).toString("base64");let t=new Uint8Array(n),e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function ev(n){if(zd){let s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}let t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function iu(n){if(n.length===1)return n[0];let t=0;n.forEach(r=>{t+=r.byteLength});let e=new Uint8Array(t),s=0;return n.forEach(r=>{e.set(new Uint8Array(r),s),s+=r.byteLength}),e.buffer}function ly(n){let t="/";for(n=n.trim();n.endsWith(t);)n=n.slice(0,n.length-1);let e=n.split(t);return e[e.length-1]}function Gi(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:iy(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:iy(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function nv(){let n=e=>{let s=e<<13,r=0;for(;(s&8388608)==0;)r-=8388608,s<<=1;return s&=~8388608,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function sv(){let n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function rv(){let n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function ov(){let n=nv(),t=sv(),e=rv();return s=>{let r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){let i=s[a],l=n[e[i>>10]+(i&1023)]+t[i>>10];o[a]=l}return new Float32Array(r)}}class Yt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Yt.instance==null&&(Yt.instance=new Yt),Yt.instance}static registerSaveRouter(t){Yt.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Yt.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Yt.getHandlers(t,"save")}static getLoadHandlers(t,e){return Yt.getHandlers(t,"load",e)}static getHandlers(t,e,s){let r=[];return(e==="load"?Yt.getInstance().loadRouters:Yt.getInstance().saveRouters).forEach(a=>{let i=a(t,s);i!==null&&r.push(i)}),r}}let av=n=>Yt.registerSaveRouter(n),iv=n=>Yt.registerLoadRouter(n),Md=n=>Yt.getSaveHandlers(n),Bd=(n,t)=>Yt.getLoadHandlers(n,t);let lu="tensorflowjs",Vd=1,ar="models_store",Ss="model_info_store";async function SK(){let n=Wd();return new Promise((t,e)=>{let s=n.deleteDatabase(lu);s.onsuccess=()=>t(),s.onerror=r=>e(r)})}function Wd(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let n=typeof window=="undefined"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ud(n){let t=n.result;t.createObjectStore(ar,{keyPath:"modelPath"}),t.createObjectStore(Ss,{keyPath:"modelPath"})}class ir{constructor(t){if(this.indexedDB=Wd(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{let o=this.indexedDB.open(lu,Vd);o.onupgradeneeded=()=>Ud(o),o.onsuccess=()=>{let a=o.result;if(e==null){let i=a.transaction(ar,"readonly"),c=i.objectStore(ar).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=u=>(a.close(),r(c.error)),i.oncomplete=()=>a.close()}else{let i=Gi(e),l=a.transaction(Ss,"readwrite"),c=l.objectStore(Ss),u=c.put({modelPath:this.modelPath,modelArtifactsInfo:i}),h;u.onsuccess=()=>{h=a.transaction(ar,"readwrite");let p=h.objectStore(ar).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:i});p.onsuccess=()=>s({modelArtifactsInfo:i}),p.onerror=f=>{c=l.objectStore(Ss);let m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),r(p.error)),m.onerror=g=>(a.close(),r(p.error))}},u.onerror=d=>(a.close(),r(u.error)),l.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}ir.URL_SCHEME="indexeddb://";let cy=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ir.URL_SCHEME)?lv(n.slice(ir.URL_SCHEME.length)):null;Yt.registerSaveRouter(cy),Yt.registerLoadRouter(cy);function lv(n){return new ir(n)}function cv(n){return n.startsWith(ir.URL_SCHEME)?n.slice(ir.URL_SCHEME.length):n}class uv{constructor(){this.indexedDB=Wd()}async listModels(){return new Promise((t,e)=>{let s=this.indexedDB.open(lu,Vd);s.onupgradeneeded=()=>Ud(s),s.onsuccess=()=>{let r=s.result,o=r.transaction(Ss,"readonly"),i=o.objectStore(Ss).getAll();i.onsuccess=()=>{let l={};for(let c of i.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},i.onerror=l=>(r.close(),e(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=cv(t),new Promise((e,s)=>{let r=this.indexedDB.open(lu,Vd);r.onupgradeneeded=()=>Ud(r),r.onsuccess=()=>{let o=r.result,a=o.transaction(Ss,"readwrite"),i=a.objectStore(Ss),l=i.get(t),c;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let u=i.delete(t),h=()=>{c=o.transaction(ar,"readwrite");let p=c.objectStore(ar).delete(t);p.onsuccess=()=>e(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};u.onsuccess=h,u.onerror=d=>(h(),o.close(),s(l.error))}},l.onerror=u=>(o.close(),s(l.error)),a.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}let Un="/",lr="tensorflowjs_models",uy="info",hv="model_topology",dv="weight_specs",pv="weight_data",fv="model_metadata";function TK(){if(!G().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");let n=window.localStorage,t=[];for(let e=0;e<n.length;++e){let s=n.key(e),r=lr+Un;if(s.startsWith(r)&&s.length>r.length){n.removeItem(s);let o=dy(s);t.indexOf(o)===-1&&t.push(o)}}return t}function hy(n){return{info:[lr,n,uy].join(Un),topology:[lr,n,hv].join(Un),weightSpecs:[lr,n,dv].join(Un),weightData:[lr,n,pv].join(Un),modelMetadata:[lr,n,fv].join(Un)}}function dy(n){let t=n.split(Un);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Un)}function mv(n){return n.startsWith(cr.URL_SCHEME)?n.slice(cr.URL_SCHEME.length):n}class cr{constructor(t){if(!G().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=hy(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=Gi(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,tv(t.weightData));let o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return t.signature!=null&&(o.signature=t.signature),t.userDefinedMetadata!=null&&(o.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(o.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch(o){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;let o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){let i=JSON.parse(o);e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy,i.signature!=null&&(e.signature=i.signature),i.userDefinedMetadata!=null&&(e.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(e.modelInitializer=i.modelInitializer)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=ev(a),e}}cr.URL_SCHEME="localstorage://";let py=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(cr.URL_SCHEME)?gv(n.slice(cr.URL_SCHEME.length)):null;Yt.registerSaveRouter(py),Yt.registerLoadRouter(py);function gv(n){return new cr(n)}class yv{constructor(){N(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),N(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=lr+Un,s=Un+uy;for(let r=0;r<this.LS.length;++r){let o=this.LS.key(r);if(o.startsWith(e)&&o.endsWith(s)){let a=dy(o);t[a]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=mv(t);let e=hy(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let s=JSON.parse(this.LS.getItem(e.info));return this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),s}}let Bo="://";class He{constructor(){this.managers={}}static getInstance(){return He.instance==null&&(He.instance=new He),He.instance}static registerManager(t,e){N(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Bo)&&(t=t.slice(0,t.indexOf(Bo))),N(t.length>0,()=>"scheme must not be an empty string.");let s=He.getInstance();N(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function cu(n){if(n.indexOf(Bo)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${He.getSchemes().join(",")}`);return{scheme:n.split(Bo)[0],path:n.split(Bo)[1]}}async function fy(n,t,e=!1){N(n!==t,()=>`Old path and new path are the same: '${n}'`);let s=Yt.getLoadHandlers(n);N(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),N(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);let r=s[0],o=Yt.getSaveHandlers(t);N(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),N(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);let a=o[0],i=cu(n).scheme,l=cu(n).path,c=i===cu(n).scheme,u=await r.load();e&&c&&await He.getManager(i).removeModel(l);let h=await a.save(u);return e&&!c&&await He.getManager(i).removeModel(l),h.modelArtifactsInfo}async function bv(){let n=He.getSchemes(),t={};for(let e of n){let s=await He.getManager(e).listModels();for(let r in s){let o=e+Bo+r;t[o]=s[r]}}return t}async function xv(n){let t=cu(n);return He.getManager(t.scheme).removeModel(t.path)}async function wv(n,t){return fy(n,t,!1)}async function $v(n,t){return fy(n,t,!0)}class vv{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(G().get("IS_BROWSER")){G().setPlatform("browser",new vv);try{He.registerManager(cr.URL_SCHEME,new yv)}catch(n){}try{He.registerManager(ir.URL_SCHEME,new uv)}catch(n){}}let Cv={importFetch:()=>p$()},Vo;function EK(){Vo=null}function AK(n){Vo=n}function DK(){return Vo}class Nv{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return G().global.fetch!=null?G().global.fetch(t,e):(Vo==null&&(Vo=Cv.importFetch()),Vo(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}}G().get("IS_NODE")&&G().setPlatform("node",new Nv);function vt(n,t="float32",e){return t=t||"float32",Nd(n),new ce(n,t,e)}function kv(n,t){let e=S(n,"x","cast");if(!Mg(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let s={x:e},r={dtype:t};return A.runKernel(Kr,s,r)}let rt=D({cast_:kv});function Iv(n){let e={x:S(n,"x","clone","string_or_numeric")};return A.runKernel(io,e)}let Ts=D({clone_:Iv});function my(n,t=!1){console.log(n.toString(t))}ny(),U$({buffer:vt,cast:rt,clone:Ts,print:my});let Sv="model",Tv=".json",Ev=".weights.bin";function gy(n){return new Promise(t=>setTimeout(t)).then(n)}class ur{constructor(t){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ur.URL_SCHEME)&&(t=t.slice(ur.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Sv),this.modelTopologyFileName=t+Tv,this.weightDataFileName=t+Ev}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:s};t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer);let o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(a.download=this.modelTopologyFileName,a.href=o,await gy(()=>a.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=e,await gy(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Gi(t)}}}}ur.URL_SCHEME="downloads://";class Av{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){let t=this.files[0],e=this.files.slice(1);return new Promise((s,r)=>{let o=new FileReader;o.onload=a=>{let i=JSON.parse(a.target.result),l=i.modelTopology;if(l==null){r(new Error(`modelTopology field is missing from file ${t.name}`));return}e.length===0&&s({modelTopology:l});let c=i.weightsManifest;if(c==null){r(new Error(`weightManifest field is missing from file ${t.name}`));return}let u;try{u=this.checkManifestAndWeightFiles(c,e)}catch(f){r(f);return}let h=[],d=[],p=[];c.forEach(f=>{f.paths.forEach(m=>{d.push(m),p.push(null)}),h.push(...f.weights)}),c.forEach(f=>{f.paths.forEach(m=>{let g=new FileReader;g.onload=y=>{let b=y.target.result,C=d.indexOf(m);if(p[C]=b,p.indexOf(null)===-1){let w={modelTopology:l,weightSpecs:h,weightData:iu(p),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy};i.signature!=null&&(w.signature=i.signature),i.userDefinedMetadata!=null&&(w.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(w.modelInitializer=i.modelInitializer),s(w)}},g.onerror=y=>r(`Failed to weights data from file of path '${m}'.`),g.readAsArrayBuffer(u[m])})})},o.onerror=a=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(t)})}checkManifestAndWeightFiles(t,e){let s=[],r=e.map(a=>ly(a.name)),o={};for(let a of t)a.paths.forEach(i=>{let l=ly(i);if(s.indexOf(l)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${l}'`);if(s.push(l),r.indexOf(l)===-1)throw new Error(`Weight file with basename '${l}' is not provided.`);o[i]=e[r.indexOf(l)]});if(s.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${s.length}) and the number of weight files provided (${e.length}).`);return o}}let Dv=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ur.URL_SCHEME)?Rv(n.slice(ur.URL_SCHEME.length)):null;Yt.registerSaveRouter(Dv);function Rv(n="model"){return new ur(n)}function Fv(n){return new Av(n)}function yy(n,t,e,s){a(n),e=e==null?0:e,s=s==null?1:s,i(e,s);let r=0,o=l=>(l.then(c=>{let u=e+ ++r/n.length*(s-e);return t(u),c}),l);function a(l){N(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,c){N(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),N(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),N(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(o))}async function by(n,t){t==null&&(t={});let e=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,s=n.map(h=>e(h,t.requestInit,{isBinary:!0})),r=0,o=.5,i=(t.onProgress==null?await Promise.all(s):await yy(s,t.onProgress,r,o)).map(h=>h.arrayBuffer()),l=.5,c=1;return t.onProgress==null?await Promise.all(i):await yy(i,t.onProgress,l,c)}async function xy(n,t="",e,s){return wy(a=>by(a,{requestInit:s}))(n,t,e)}function wy(n){return async(t,e="",s)=>{let r=t.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],i=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=Ld[y]*H(g.shape),C=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};s!=null?s.forEach((w,v)=>{w===g.name&&(C(),a[v]=!0)}):C(),i.push(g.name),m+=b})}),!a.every(p=>p)){let p=s.filter((f,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let l=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),c=[];l.forEach(p=>{t[p].paths.forEach(f=>{let m=e+(e.endsWith("/")?"":"/")+f;c.push(m)})});let u=await n(c),h={},d=0;return l.forEach(p=>{let f=t[p].paths.length,m=0;for(let w=0;w<f;w++)m+=u[d+w].byteLength;let g=new ArrayBuffer(m),y=new Uint8Array(g),b=0;for(let w=0;w<f;w++){let v=new Uint8Array(u[d+w]);y.set(v,b),b+=v.byteLength}o[p].forEach(w=>{let v=g.slice(w.groupOffset,w.groupOffset+w.sizeBytes),I=au(v,[w.manifestEntry]);for(let k in I)h[k]=I[k]}),d+=f}),h}}let _v="application/octet-stream",Ov="application/json";class Gd{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(N(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=G().platform.fetch,N(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&N(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:s};t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(r)],{type:Ov}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:_v}),"model.weights.bin");let o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:Gi(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(f){let m=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?m+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":m+=" Please make sure the server is serving valid JSON for this request.",new Error(m)}let s=e.modelTopology,r=e.weightsManifest,o=e.generatedBy,a=e.convertedBy,i=e.format,l=e.signature,c=e.userDefinedMetadata;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,h;r!=null&&([u,h]=await this.loadWeights(r));let d={modelTopology:s,weightSpecs:u,weightData:h,generatedBy:o,convertedBy:a,format:i};l!=null&&(d.signature=l),c!=null&&(d.userDefinedMetadata=c);let p=e.modelInitializer;return p&&(d.modelInitializer=p),d}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Lv(e),o=this.weightPathPrefix||s,a=[];for(let u of t)a.push(...u.weights);let i=[],l=[];for(let u of t)for(let h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):i.push(o+h+r);this.weightUrlConverter&&i.push(...await Promise.all(l));let c=await by(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,iu(c)]}}Gd.URL_SCHEME_REGEX=/^https?:\/\//;function Lv(n){let t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),r=e>t?n.substring(e):"";return[s+"/",r]}function Hd(n){return n.match(Gd.URL_SCHEME_REGEX)!=null}let $y=(n,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>Hd(s)):e=Hd(n),e)return jd(n,t)}return null};Yt.registerSaveRouter($y),Yt.registerLoadRouter($y);function jd(n,t){return new Gd(n,t)}function uu(n,t){return jd(n,t)}class qd{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class Pv{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function zv(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new qd(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new qd({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new qd({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function Mv(n){return new Pv(n)}var Bv=Object.freeze({__proto__:null,browserFiles:Fv,browserHTTPRequest:uu,concatenateArrayBuffers:iu,decodeWeights:au,encodeWeights:Pd,fromMemory:zv,getLoadHandlers:Bd,getModelArtifactsInfoForJSON:Gi,getSaveHandlers:Md,http:jd,isHTTPScheme:Hd,loadWeights:xy,registerLoadRouter:iv,registerSaveRouter:av,weightsLoaderFactory:wy,withSaveHandler:Mv,copyModel:wv,listModels:bv,moveModel:$v,removeModel:xv});function Vv(n,t,e=!1,s=!1){let r=S(n,"a","matMul"),o=S(t,"b","matMul");[r,o]=Xt(r,o);let a={a:r,b:o},i={transposeA:e,transposeB:s};return A.runKernel(Ba,a,i)}let It=D({matMul_:Vv});function Wv(n,t,e=1,s=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let o={indices:S(n,"indices","oneHot","int32")},a={depth:t,onValue:e,offValue:s};return A.runKernel(yi,o,a)}let hr=D({oneHot_:Wv});function Uv(n,t){let e=S(n,"x","transpose");if(t==null&&(t=e.shape.map((o,a)=>a).reverse()),N(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(o=>{N(o>=0&&o<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let s={x:e},r={perm:t};return A.runKernel(Di,s,r)}let Rt=D({transpose_:Uv});function Gv(n,t,e){let s=S(n,"labels","confusionMatrix"),r=S(t,"predictions","confusionMatrix");N(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),N(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),N(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),N(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),N(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let o=hr(rt(s,"int32"),e),a=hr(rt(r,"int32"),e),i=Rt(o),l=It(i,a);return rt(l,"int32")}let Hv=D({confusionMatrix_:Gv});var jv=Object.freeze({__proto__:null,confusionMatrix:Hv});function vy(n,t,e){if(Qs(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let s=Wn(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Is(n,t,s,e)}let Wo;function qv(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,s=!1,r=!1,o=!1,a=!1,i=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(r){let f=2;if(r&&n.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Qc(Jc,A.backendName)!=null){let f={pixels:n},m={numChannels:t};return A.runKernel(Jc,f,m)}let[c,u]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height],h;a?h=n.getContext("2d").getImageData(0,0,c,u).data:s||e?h=n.data:(o||r||i)&&(Wo==null&&(Wo=document.createElement("canvas").getContext("2d")),Wo.canvas.width=c,Wo.canvas.height=u,Wo.drawImage(n,0,0,c,u),h=Wo.getImageData(0,0,c,u).data);let d;if(t===4)d=new Int32Array(h);else{let f=c*u;d=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)d[m*t+g]=h[m*4+g]}return vy(d,[u,c,t],"int32")}async function Kv(n,t){let e=S(n,"img","toPixels");if(!(n instanceof Dt)){let c=e;e=rt(c,"int32"),c.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[s,r]=e.shape.slice(0,2),o=e.rank===2?1:e.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let a=await e.data(),i=e.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let c=0;c<s*r;++c){let u=[0,0,0,255];for(let d=0;d<o;d++){let p=a[c*o+d];if(e.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(e.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);o===1?(u[0]=p*i,u[1]=p*i,u[2]=p*i):u[d]=p*i}let h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(t!=null){t.width=r,t.height=s;let c=t.getContext("2d"),u=new ImageData(l,r,s);c.putImageData(u,0,0)}return e!==n&&e.dispose(),l}let Cy=D({fromPixels_:qv});var Xv=Object.freeze({__proto__:null,toPixels:Kv,fromPixels:Cy});function hu(n,t){let e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(H(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);let r=t.shape,o=r[r.length-1],a=1;for(let h=0;h<r.length-1;++h)a*=r[h];let i=n.shape,l=r.slice();l.pop();let c=1;for(let h=o;h<e;++h)c*=i[h],l.push(i[h]);let u=[...pt(n.shape).map(h=>h/c),1].slice(0,o);return[l,a,c,u]}var Yv=Object.freeze({__proto__:null,prepareAndValidate:hu});function Kd(n,t,e){let s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(o+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(e.shape[a]!==t.shape[a])throw new Error(o+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-r;++a)if(e.shape[a+r]!==n[a+s])throw new Error(o+` updates.shape[${a+r}] (${e.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Xd(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Kd(e,t,n)}function Uo(n,t,e){let s=t.shape.length,r=s>1?t.shape[s-1]:1,o=e.length,a=1;for(let h=r;h<o;++h)a*=e[h];let i=r<1?1:r,l=H(t.shape)/i,c=[...pt(e.slice(0,r)),1],u=H(e);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:c,outputSize:u}}var Jv=Object.freeze({__proto__:null,validateUpdateShape:Kd,validateInput:Xd,calculateShapes:Uo});function Yd(n,t,e){let s=n.shape.length;N(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),N(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)N(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function du(n){let t=[],e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function Ny(n,t,e){let s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function ky(n,t,e,s){let r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<e;o++)o===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Iy(n,t,e){return e<=n?e:e-(t-1)}function Sy(n,t){let e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function Ty(n,t,e,s,r,o,a,i,l){let c=n.length,u=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&e>0){let p=t[0],f=e+1;u=Ey(a,p,f,s,n),h=Ay(i,p,f,r,n),d=ky(o,p,f,n)}else for(let p=0;p<c;p++)u[p]=Ry(a,s,o,n,p,l),h[p]=Fy(i,r,o,n,p,l),d[p]=Dy(o,p,l);return{begin:u,end:h,strides:d}}function Ey(n,t,e,s,r){let o=[...r],a=Sy(e,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{let l=Iy(t,e,i),c=s[l];n&1<<l&&(c=0),o[i]=c}return o}function Ay(n,t,e,s,r){let o=[...r],a=Sy(e,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{let l=Iy(t,e,i),c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),o[i]=c}for(let i=0;i<o.length;i++){let l=r[i];o[i]<0&&(o[i]+=l),o[i]=Fa(0,o[i],r[i])}return o}function Dy(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function Ry(n,t,e,s,r,o){let a=t[r],i=e[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let l=s[r];return a<0&&(a+=l),a=Fa(0,a,l-1),a}function Fy(n,t,e,s,r,o){let a=t[r],i=e[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let l=s[r];return a<0&&(a+=l),i>0?a=Fa(0,a,l):a=Fa(-1,a,l-1),a}function Jd(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function Zd(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function pu(n,t,e){let s,r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(a=>{N(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return e==null?o=new Array(r).fill(-1):typeof e=="number"?o=[e,...new Array(r-1).fill(-1)]:e.length<r?o=e.concat(new Array(r-e.length).fill(-1)):o=e,o=o.map((a,i)=>a>=0?a:(N(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),n.shape[i]-s[i])),[s,o]}function Qd(n,t,e,s,r,o,a,i,l){let c=t.slice(),u=e.slice(),h=s;s==null&&(h=new Array(c.length));let d=du(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&i!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&l!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let p=n.length-c.length,f=du(i),m=n.slice();f.forEach(k=>{c[k]=0,u[k]=1,m.splice(k,0,1)});let{begin:g,end:y,strides:b}=Ty(m,d,p,c,u,h,r,o,a);c=g,u=y,h=b;let C=du(l);C.forEach(k=>{u[k]=c[k]+1,h[k]=1});let w=Ny(c,u,h),v=w.filter((k,T)=>C.indexOf(T)===-1);return{nonStrided:h.every(k=>k===1),$begin:c,$end:u,$strides:h,size:w,newShape:m,outShape:v}}var _y=Object.freeze({__proto__:null,assertParamsValid:Yd,maskToAxes:du,computeOutShape:Ny,stridesWithElidedDims:ky,getNormalizedAxes:Ty,startIndicesWithElidedDims:Ey,stopIndicesWithElidedDims:Ay,stridesForAxis:Dy,startForAxis:Ry,stopForAxis:Fy,isSliceContinous:Jd,computeFlatOffset:Zd,parseSliceParams:pu,sliceInfo:Qd});class dr{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class rn{constructor(){this.classNameMap={}}static getMap(){return rn.instance==null&&(rn.instance=new rn),rn.instance}static register(t){rn.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function X(n){N(n.className!=null,()=>"Class being registered does not have the static className property defined."),N(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),N(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),rn.register(n)}var Zv=Object.freeze({__proto__:null,Serializable:dr,SerializationMap:rn,registerClass:X});let Qv=.001,Oy=.1;function tC(n,t,e){return e==null&&(e=fu()),tp(n,t,(s,r)=>np(s,r,e))}function fu(){return A.backend.floatPrecision()===32?Qv:Oy}function tp(n,t,e){let s=!0;if((ke(n)||ke(t))&&(s=!1),ke(n)&&ke(t)&&(s=!0),s){let a=n.constructor.name,i=t.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(n)&&Array.isArray(t)){let a=Wn(n),i=Wn(t);if(!At(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let r=ke(n)?n:ns(n),o=ke(t)?t:ns(t);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){let i=r[a],l=o[a];if(!e(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${r}.
Expected: ${o}.`)}}function eC(n,t){n().then(()=>t.fail(),()=>t())}function nC(n,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Mn(n)||Mn(n[0])||Mn(t)||Mn(t[0])?tp(n,e,(s,r)=>s==r):tp(n,t,(s,r)=>np(s,r,0))}function ep(n,t,e){if(e==null&&(e=fu()),!np(n,t,e))throw new Error(`Numbers differ: actual === ${n}, expected === ${t}`)}function np(n,t,e){return!isFinite(n)&&!isFinite(t)?!0:!(isNaN(n)||isNaN(t)||Math.abs(n-t)>e)}function sC(n,t,e){for(let s=0;s<n.length;s++)if(n[s]<t||n[s]>e)throw new Error(`Value out of range:${n[s]} low: ${t}, high: ${e}`)}function rC(n,t){expect(new Float32Array(n)).toEqual(new Float32Array(t))}function Ly(n){for(let t=0;t<n.length;t++){let e=n[t];Array.isArray(e)?Ly(e):n[t]=rr(e)}return n}var oC=Object.freeze({__proto__:null,TEST_EPSILON_FLOAT16:Oy,expectArraysClose:tC,testEpsilon:fu,expectPromiseToFail:eC,expectArraysEqual:nC,expectNumbersClose:ep,expectValuesInRange:sC,expectArrayBuffersEqual:rC,encodeStrings:Ly});let Py="3.2.0";function aC(){G().set("PROD",!0)}function iC(){G().set("DEBUG",!0)}function lC(){G().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function zy(n){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}G$(zy);function cC(){A.disposeVariables()}function os(){return A}function mu(){return A.memory()}function uC(n){return A.profile(n)}function O(n,t){return A.tidy(n,t)}function bt(n){rs(n).forEach(e=>e.dispose())}function be(n){return A.keep(n)}function hC(n){return A.time(n)}function My(n){return A.setBackend(n)}function dC(){return A.ready()}function pC(){return A.backendName}function fC(n){A.removeBackend(n)}function mC(n){return A.findBackend(n)}function gC(n){return A.findBackendFactory(n)}function sp(n,t,e=1){return A.registerBackend(n,t,e)}function By(){return A.backend}function yC(n,t){G().setPlatform(n,t)}function bC(n,t){let e=S(n,"a","add"),s=S(t,"b","add");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(sr,r)}let Z=D({add_:bC});function xC(n,t){let e=S(n,"a","floorDiv"),s=S(t,"b","floorDiv");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(oo,r)}let gu=D({floorDiv_:xC});function wC(n,t){let e=S(n,"a","div"),s=S(t,"b","div");if([e,s]=Xt(e,s),e.dtype==="int32"&&s.dtype==="int32")return gu(e,s);let r={a:e,b:s},o={};return A.runKernel(Qr,r,o)}let dt=D({div_:wC});function $C(n,t){let e=S(n,"a","mul"),s=S(t,"b","mul");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(yo,r)}let _=D({mul_:$C});function vC(n){let t=S(n,"x","abs");if(t.dtype==="complex64"){let e={x:t};return A.runKernel(Wa,e)}else{let e={x:t};return A.runKernel(_a,e)}}let ue=D({abs_:vC});function CC(n){let e={x:S(n,"x","acos")};return A.runKernel(Vr,e)}let rp=D({acos_:CC});function NC(n){let e={x:S(n,"x","acosh")};return A.runKernel(Wr,e)}let op=D({acosh_:NC});function kC(n){N(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),N(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);let t=n.map((r,o)=>S(r,`tensors${o}`,"addN")),e=t[0];t.forEach(r=>{if(r.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!At(r.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let s=t;return A.runKernel(Oa,s)}let Vy=D({addN_:kC});function IC(n,t=null,e=!1){let r={x:S(n,"x","all","bool")},o={axis:t,keepDims:e};return A.runKernel(ic,r,o)}let yu=D({all_:IC});function SC(n,t=null,e=!1){let r={x:S(n,"x","any","bool")},o={axis:t,keepDims:e};return A.runKernel(lc,r,o)}let Hi=D({any_:SC});function TC(n,t=0){let s={x:S(n,"x","argMax")},r={axis:t};return A.runKernel(La,s,r)}let ji=D({argMax_:TC});function EC(n,t=0){let s={x:S(n,"x","argMin")},r={axis:t};return A.runKernel(Pa,s,r)}let ap=D({argMin_:EC});function AC(n){let e={x:S(n,"x","asin")};return A.runKernel(Ur,e)}let ip=D({asin_:AC});function DC(n){let e={x:S(n,"x","asinh")};return A.runKernel(Gr,e)}let lp=D({asinh_:DC});function RC(n){let e={x:S(n,"x","atan")};return A.runKernel(Hr,e)}let cp=D({atan_:RC});function FC(n,t){let e=S(n,"a","atan2"),s=S(t,"b","atan2");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(qr,r)}let up=D({atan2_:FC});function _C(n){let e={x:S(n,"x","atanh")};return A.runKernel(jr,e)}let hp=D({atanh_:_C});function qi(n,t,e,s,r="NHWC",o){let a=n[3],i=[...t,a],l=is(r);return xe(n,i,e,o,s,null,null,l)}function mn(n,t,e,s,r,o,a="channelsLast"){let[i,l]=bu(t),c;if(a==="channelsLast")c=[i,l,n[3],n[3]];else if(a==="channelsFirst")c=[i,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return xe(n,c,e,s,r,o,!1,a)}function as(n,t,e,s,r,o,a="NDHWC"){let[i,l,c]=pp(t),u,h;if(a==="NDHWC")h="channelsLast",u=[i,l,c,n[4],n[4]];else if(a==="NCDHW")h="channelsFirst",u=[i,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Es(n,u,e,s,r,!1,h,o)}function xe(n,t,e,s,r,o,a=!1,i="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(i==="channelsLast")[l,c,u,h]=n;else if(i==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${i}`);let[d,p,,f]=t,[m,g]=bu(e),[y,b]=bu(s),C=Go(d,y),w=Go(p,b),{padInfo:v,outHeight:I,outWidth:k}=PC(r,c,u,m,g,C,w,o,i),T=a?f*h:f,E;return i==="channelsFirst"?E=[l,T,I,k]:i==="channelsLast"&&(E=[l,I,k,T]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:I,outWidth:k,outChannels:T,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:C,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:n,outShape:E,filterShape:t}}function Es(n,t,e,s,r,o=!1,a="channelsLast",i){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h,d]=n;else if(a==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${a}`);let[p,f,m,,g]=t,[y,b,C]=pp(e),[w,v,I]=pp(s),k=Go(p,w),T=Go(f,v),E=Go(m,I),{padInfo:F,outDepth:P,outHeight:M,outWidth:z}=zC(r,c,u,h,y,b,C,k,T,E,i),U=o?g*d:g,B;return a==="channelsFirst"?B=[l,U,P,M,z]:a==="channelsLast"&&(B=[l,P,M,z,U]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:P,outHeight:M,outWidth:z,outChannels:U,padInfo:F,strideDepth:y,strideHeight:b,strideWidth:C,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationDepth:w,dilationHeight:v,dilationWidth:I,inShape:n,outShape:B,filterShape:t}}function OC(n,t,e,s,r){s==null&&(s=dp(n,t,e));let o=n[0],a=n[1],i=pr((o-t+2*s)/e+1,r),l=pr((a-t+2*s)/e+1,r);return[i,l]}function LC(n,t,e,s,r,o){r==null&&(r=dp(n,t,s));let a=n[0],i=n[1],l=n[2],c=pr((a-t+2*r)/s+1,o),u=pr((i-t+2*r)/s+1,o),h=pr((l-t+2*r)/s+1,o);return[c,u,h,e]}function dp(n,t,e,s=1){let r=Go(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function bu(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function pp(n){return typeof n=="number"?[n,n,n]:n}function Go(n,t){return t<=1?n:n+(n-1)*(t-1)}function PC(n,t,e,s,r,o,a,i,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};let p=OC([t,e],o,s,n,i);u=p[0],h=p[1]}else if(n==="same"){u=Math.ceil(t/s),h=Math.ceil(e/r);let d=Math.max(0,(u-1)*s+o-t),p=Math.max(0,(h-1)*r+a-e),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2),y=p-g;c={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/s),h=Math.ceil((e-a+1)/r);else if(typeof n=="object"){let d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=pr((t-o+d+p)/s+1,i),h=pr((e-a+f+m)/r+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function zC(n,t,e,s,r,o,a,i,l,c,u){let h,d,p,f;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};let g=LC([t,e,s,1],i,1,r,n,u);d=g[0],p=g[1],f=g[2]}else if(n==="same"){d=Math.ceil(t/r),p=Math.ceil(e/o),f=Math.ceil(s/a);let m=(d-1)*r+i-t,g=(p-1)*o+l-e,y=(f-1)*a+c-s,b=Math.floor(m/2),C=m-b,w=Math.floor(g/2),v=g-w,I=Math.floor(y/2),k=y-I;h={top:w,bottom:v,left:I,right:k,front:b,back:C,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-i+1)/r),p=Math.ceil((e-l+1)/o),f=Math.ceil((s-c+1)/a);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function pr(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function As(n){let[t,e,s]=bu(n);return t===1&&e===1&&s===1}function Te(n,t){return As(n)||As(t)}function is(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function MC(n,t){let s={x:S(n,"x","reshape","string_or_numeric")},r={shape:t};return A.runKernel($i,s,r)}let L=D({reshape_:MC});function BC(n,t,e,s,r){let o=S(n,"x","avgPool","float32"),a=1;N(Te(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),N(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),r!=null&&N(le(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let c={x:i},u={filterSize:t,strides:e,pad:s,dimRoundingMode:r},h=A.runKernel(za,c,u);return h=rt(h,o.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}let Ki=D({avgPool_:BC});function VC(n,t,e,s,r,o="NDHWC"){let a=S(n,"x","avgPool3d","float32"),i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),N(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),N(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),r!=null&&N(le(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let c={x:i},u={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:o},h=A.runKernel(Ma,c,u);return h=rt(h,i.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}let fp=D({avgPool3d_:VC});function WC(n,t=0){N(n.length>=1,()=>"Pass at least one tensor to concat");let e=Ui(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),e.length===1)return Ts(e[0]);let s=e,r={axis:t};return A.runKernel(Ua,s,r)}let ee=D({concat_:WC});function UC(n){let e={x:S(n,"x","sigmoid")};return A.runKernel(To,e)}let Gn=D({sigmoid_:UC});function GC(n,t,e){let s=S(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");let r={x:s},o={begin:t,size:e};return A.runKernel(Ii,r,o)}let St=D({slice_:GC});function HC(n){let e={x:S(n,"x","tanh")};return A.runKernel(_o,e)}let Ho=D({tanh_:HC});function jC(n,t,e,s,r,o){let a=S(n,"forgetBias","basicLSTMCell"),i=S(t,"lstmKernel","basicLSTMCell"),l=S(e,"lstmBias","basicLSTMCell"),c=S(s,"data","basicLSTMCell"),u=S(r,"c","basicLSTMCell"),h=S(o,"h","basicLSTMCell"),d=ee([c,h],1),p=It(d,i),f=Z(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=St(f,[0,0],y),C=St(f,[0,g],y),w=St(f,[0,g*2],y),v=St(f,[0,g*3],y),I=Z(_(Gn(b),Ho(C)),_(u,Gn(Z(a,w)))),k=_(Ho(I),Gn(v));return[I,k]}let qC=D({basicLSTMCell_:jC});function KC(n,t,e){let s=S(n,"x","batchToSpaceND"),r=t.reduce((i,l)=>i*l);N(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),N(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),N(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let o={x:s},a={blockShape:t,crops:e};return A.runKernel(Va,o,a)}let Xi=D({batchToSpaceND_:KC});function XC(n){let t;return n.rank===0||n.rank===1?t=L(n,[1,1,1,n.size]):n.rank===2?t=L(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function YC(n,t,e,s,r,o){o==null&&(o=.001);let a=S(n,"x","batchNorm"),i=S(t,"mean","batchNorm"),l=S(e,"variance","batchNorm"),c;r!=null&&(c=S(r,"scale","batchNorm"));let u;s!=null&&(u=S(s,"offset","batchNorm")),N(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:XC(a),scale:c,offset:u,mean:i,variance:l},p={varianceEpsilon:o},f=A.runKernel(Za,d,p);return L(f,a.shape)}let fr=D({batchNorm_:YC});function JC(n,t,e,s,r,o){let a=S(n,"x","batchNorm"),i=S(t,"mean","batchNorm"),l=S(e,"variance","batchNorm"),c;r!=null&&(c=S(r,"scale","batchNorm"));let u;return s!=null&&(u=S(s,"offset","batchNorm")),N(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),N(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),N(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&N(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),fr(a,i,l,u,c,o)}let Wy=D({batchNorm2d_:JC});function ZC(n,t,e,s,r,o){let a=S(n,"x","batchNorm"),i=S(t,"mean","batchNorm"),l=S(e,"variance","batchNorm"),c;r!=null&&(c=S(r,"scale","batchNorm"));let u;return s!=null&&(u=S(s,"offset","batchNorm")),N(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),N(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),N(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&N(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),fr(a,i,l,u,c,o)}let Uy=D({batchNorm3d_:ZC});function QC(n,t,e,s,r,o){let a=S(n,"x","batchNorm"),i=S(t,"mean","batchNorm"),l=S(e,"variance","batchNorm"),c;r!=null&&(c=S(r,"scale","batchNorm"));let u;return s!=null&&(u=S(s,"offset","batchNorm")),N(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),N(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),N(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&N(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&N(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),fr(a,i,l,u,c,o)}let Gy=D({batchNorm4d_:QC});function tN(n,t,e){let s=S(n,"x","bincount"),r=S(t,"weights","bincount");N(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),N(e>=0,()=>`size must be non-negative, but got ${e}.`),N(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);let o={x:s,weights:r},a={size:e};return A.runKernel(hc,o,a)}let Hy=D({bincount_:tN});function eN(n,t){let e=S(n,"broadcastTo","x"),s=e.shape;if(t.some(c=>!(c>0)||c%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=L(e,c)}let r=e.shape,o=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])o[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(o.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return Ts(e);let i={x:e},l={reps:o};return A.runKernel(Oo,i,l)}let Yi=D({broadcastTo_:eN});function nN(n){let e={x:S(n,"x","ceil")};return A.runKernel(Xr,e)}let mp=D({ceil_:nN});function sN(n,t,e){let s=S(n,"x","clipByValue");N(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let r={x:s},o={clipValueMin:t,clipValueMax:e};return A.runKernel(Yr,r,o)}let Me=D({clipByValue_:sN});function rN(n){return ee(n,0)}let jy=D({concat1d_:rN});function oN(n,t){return ee(n,t)}let qy=D({concat2d_:oN});function aN(n,t){return ee(n,t)}let Ky=D({concat3d_:aN});function iN(n,t){return ee(n,t)}let Xy=D({concat4d_:iN});function lN(n,t,e,s,r="NHWC",o=[1,1],a){let i=S(n,"x","conv2d"),l=S(t,"filter","conv2d"),c=i,u=!1;i.rank===3&&(u=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),N(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),N(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),a!=null&&N(le(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let h=r==="NHWC"?c.shape[3]:c.shape[1];N(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),N(Te(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let d={x:c,filter:l},p={strides:e,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},f=A.runKernel(Ga,d,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}let ls=D({conv2d_:lN});function cN(n,t,e,s,r="NWC",o=1,a){let i=S(n,"x","conv1d"),l=S(t,"filter","conv1d"),c=i,u=!1;i.rank===2&&(u=!0,c=L(i,[1,i.shape[0],i.shape[1]])),N(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),N(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),a!=null&&N(le(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),N(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),N(Te(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),N(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let h=L(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=L(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=ls(d,h,[1,e],s,"NHWC",[1,o],a);return u?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}let xu=D({conv1d_:cN});function uN(n,t,e,s,r,o="NHWC",a){N(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,l=t,c=!1;t.rank===3&&(c=!0,l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,n[0],n[1],n[2]]),N(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),N(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),N(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let u=o==="NHWC"?i[3]:i[1],h=o==="NHWC"?l.shape[3]:l.shape[1];N(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),N(h===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[3]}.`),a!=null&&N(le(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let d={dy:l,filter:e},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:i},f=A.runKernel(Ha,d,p);return c?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}let gp=D({conv2DBackpropInput_:uN});function hN(n,t,e,s,r,o){let a=S(n,"x","conv2dTranspose"),i=S(t,"filter","conv2dTranspose");return gp(e,a,i,s,r,"NHWC",o)}let wu=D({conv2dTranspose_:hN});function dN(n,t,e,s,r="NDHWC",o=[1,1,1]){let a=S(n,"x","conv3d"),i=S(t,"filter","conv3d"),l=a,c=!1;a.rank===4&&(c=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),N(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),N(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),N(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),N(Te(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),N(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);let u={x:l,filter:i},h={strides:e,pad:s,dataFormat:r,dilations:o},d=A.runKernel(ja,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}let yp=D({conv3d_:dN});function pN(n,t,e,s,r){N(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,a=t,i=!1;t.rank===4&&(i=!0,a=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);let l=o[4],c=a.shape[4];N(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),N(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),N(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),N(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),N(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);let u={dy:a,filter:e},h={pad:r,strides:s,inputShape:o},d=A.runKernel(mc,u,h);return i?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}let Yy=D({conv3DBackpropInput_:pN});function fN(n,t,e,s,r){let o=S(n,"x","conv3dTranspose"),a=S(t,"filter","conv3dTranspose");return Yy(e,o,a,s,r)}let mN=D({conv3dTranspose_:fN});function gN(n){let e={x:S(n,"x","cos")};return A.runKernel(Jr,e)}let Ji=D({cos_:gN});function yN(n){let e={x:S(n,"x","cosh")};return A.runKernel(Zr,e)}let $u=D({cosh_:yN});function bN(n,t=0,e=!1,s=!1){let o={x:S(n,"x","cumsum")},a={axis:t,exclusive:e,reverse:s};return A.runKernel(qa,o,a)}let vu=D({cumsum_:bN});function xN(n,t,e,s=!1){let r=S(n,"x","denseBincount"),o=S(t,"weights","denseBincount");N(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),N(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),N(e>=0,()=>`size must be non-negative, but got ${e}.`),N(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);let a={x:r,weights:o},i={size:e,binaryOutput:s};return A.runKernel(yc,a,i)}let Jy=D({denseBincount_:xN});function wN(n,t,e="NHWC"){let s=S(n,"x","depthToSpace"),r=e==="NHWC"?s.shape[1]:s.shape[2],o=e==="NHWC"?s.shape[2]:s.shape[3],a=e==="NHWC"?s.shape[3]:s.shape[1];N(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),N(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t} for depthToSpace with input shape
        ${s.shape}`),N(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${s.shape}`);let i={x:s},l={blockSize:t,dataFormat:e};return A.runKernel(bc,i,l)}let bp=D({depthToSpace_:wN});function $N(n,t,e,s,r="NHWC",o=[1,1],a){let i=S(n,"x","depthwiseConv2d"),l=S(t,"filter","depthwiseConv2d"),c=i,u=!1;i.rank===3&&(u=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),N(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),N(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),N(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),a!=null&&N(le(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let h={x:c,filter:l},d={strides:e,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},p=A.runKernel(Ka,h,d);return u?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}let jo=D({depthwiseConv2d_:$N});function vN(n){let e={x:S(n,"x","diag")};return A.runKernel($c,e)}let CN=D({diag_:vN});function NN(n,t,e,s,r=[1,1],o="NHWC"){let a=S(n,"x","dilation2d"),i=S(t,"filter","dilation2d");N(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),N(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),N(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,c=!1;a.rank===3&&(l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0);let u={x:l,filter:i},h={strides:e,pad:s,dilations:r},d=A.runKernel(Xa,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}let xp=D({dilation2d_:NN});function Zi(n,t){let e=n.length,s=[];for(let r=0;r<e;r++){let o=e-1-r,a=n[o]||1;(t[t.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function he(n,t){let e=[];for(let s=0;s<t.length;s++){let r=n[n.length-s-1],o=t.length-s-1,a=t[o];(r==null||r===1&&a>1)&&e.unshift(o)}return e}function Nt(n,t){let e=[],s=Math.max(n.length,t.length);for(let r=0;r<s;r++){let o=n[n.length-r-1];o==null&&(o=1);let a=t[t.length-r-1];if(a==null&&(a=1),o===1)e.unshift(a);else if(a===1)e.unshift(o);else if(o!==a){let i=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(i)}else e.unshift(o)}return e}function kN(n,t){let e=S(n,"a","equal"),s=S(t,"b","equal");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(Ya,r)}let cs=D({equal_:kN});function IN(n,t,e){let s=S(t,"a","where"),r=S(e,"b","where"),o=S(n,"condition","where","bool"),a=Nt(s.shape,r.shape),i=Yi(s,a),l=Yi(r,a);o.rank===1&&N(o.shape[0]===s.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),o.rank!==1&&ge(o.shape,l.shape,"Error in where: ");let c={condition:o,t:i,e:l};return A.runKernel(ki,c)}let Oe=D({where_:IN});function SN(n){let e={x:S(n,"x","zerosLike")};return A.runKernel(_i,e)}let Ct=D({zerosLike_:SN});function TN(n,t){let e=S(n,"a","div"),s=S(t,"b","div");[e,s]=Xt(e,s);let r=dt(e,s),o=Ct(r),a=cs(s,o);return Oe(a,o,r)}let wp=D({divNoNan_:TN});function EN(n,t){let e=S(n,"t1","dot"),s=S(t,"t2","dot");N((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);let r=e.rank===1?e.size:e.shape[1],o=s.rank===1?s.size:s.shape[0];if(N(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),e.rank===1&&s.rank===1){let a=L(e,[1,-1]),i=L(s,[-1,1]),l=It(a,i);return L(l,[])}else if(e.rank===1&&s.rank===2){let a=L(e,[1,-1]),i=L(s,[s.shape[0],s.shape[1]]),l=It(a,i);return L(l,[l.size])}else if(e.rank===2&&s.rank===1){let a=L(s,[-1,1]),i=It(e,a);return L(i,[i.size])}else{let a=L(s,[s.shape[0],s.shape[1]]);return It(e,a)}}let Zy=D({dot_:EN});function AN(n){let e={x:S(n,"x","elu")};return A.runKernel(to,e)}let qo=D({elu_:AN});function DN(n){let t=S(n,"x","erf");N(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=rt(t,"float32"));let e={x:t};return A.runKernel(eo,e)}let $p=D({erf_:DN});function RN(n){let e={x:S(n,"x","exp")};return A.runKernel(no,e)}let on=D({exp_:RN});function FN(n,t=0){let e=S(n,"x","expandDims","string_or_numeric");N(t<=e.rank,()=>"Axis must be <= rank of the tensor");let s={input:e},r={dim:t};return A.runKernel(Ja,s,r)}let je=D({expandDims_:FN});function _N(n){let e={x:S(n,"x","expm1")};return A.runKernel(so,e)}let vp=D({expm1_:_N});function ON(n,t){let e=S(n,"x","tile","string_or_numeric");N(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let s={x:e},r={reps:t};return A.runKernel(Oo,s,r)}let Ds=D({tile_:ON});function LN(n,t,e,s="float32"){t==null&&(t=n);let r=vt([n,t],s),o=n<=t?n:t;for(let i=0;i<o;++i)r.set(1,i,i);let a=L(r.toTensor(),[n,t]);if(e==null)return a;if(e.length===1)return Ds(je(a,0),[e[0],1,1]);if(e.length===2)return Ds(je(je(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return Ds(je(je(je(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}let Cu=D({eye_:LN});function Qi(n,t,e){let s={shape:n,value:t,dtype:e};return A.runKernel(Ic,{},s)}function PN(n){let e={x:S(n,"x","floor")};return A.runKernel(ro,e)}let Ko=D({floor_:PN});function zN(n,t,e=0,s=0){let r=S(n,"x","gather"),o=S(t,"indices","gather","int32"),a={x:r,indices:o},i={axis:e,batchDims:s};return A.runKernel(Qa,a,i)}let mr=D({gather_:zN});function MN(n,t){let e=S(n,"a","greater"),s=S(t,"b","greater");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(ti,r)}let an=D({greater_:MN});function BN(n,t){let e=S(n,"a","greaterEqual"),s=S(t,"b","greaterEqual");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(ao,r)}let Rs=D({greaterEqual_:BN});function VN(n){let e={input:S(n,"input","imag")};return A.runKernel(Ac,e)}let Nu=D({imag_:VN});function WN(n){let e={x:S(n,"x","isFinite")};return A.runKernel(lo,e)}let Qy=D({isFinite_:WN});function UN(n){let e={x:S(n,"x","isInf")};return A.runKernel(co,e)}let tb=D({isInf_:UN});function GN(n){let e={x:S(n,"x","isNaN")};return A.runKernel(uo,e)}let eb=D({isNaN_:GN});function HN(n,t=.2){let s={x:S(n,"x","leakyRelu")},r={alpha:t};return A.runKernel(ei,s,r)}let tl=D({leakyRelu_:HN});function jN(n,t){let e=S(n,"a","less"),s=S(t,"b","less");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(ni,r)}let ku=D({less_:jN});function qN(n,t){let e=S(n,"a","lessEqual"),s=S(t,"b","lessEqual");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(si,r)}let gr=D({lessEqual_:qN});function nb(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");let s={start:n,stop:t,num:e};return A.runKernel(Dc,{},s)}function KN(n,t=5,e=1,s=1,r=.5){let o=S(n,"x","localResponseNormalization");N(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),N(le(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let l={x:a},c={depthRadius:t,bias:e,alpha:s,beta:r},u=A.runKernel(ii,l,c);return i?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}let Cp=D({localResponseNormalization_:KN});function XN(n){let e={x:S(n,"x","log")};return A.runKernel(ho,e)}let qe=D({log_:XN});function YN(n){let e={x:S(n,"x","log1p")};return A.runKernel(po,e)}let Iu=D({log1p_:YN});function JN(n){return N(Cs(n),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let s=S(t,"x","tf.grad","string_or_numeric"),r=e!=null?S(e,"dy","tf.grad"):null;return A.tidy(()=>{let{value:o,grads:a}=A.gradients(()=>n(s),[s],r);return r!=null&&ge(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Su(a),a[0]})}}function ZN(n){return N(Cs(n),()=>"The f passed in grads(f) must be a function"),(t,e)=>{N(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let s=Ui(t,"args","tf.grads","string_or_numeric"),r=e!=null?S(e,"dy","tf.grads"):null;return A.tidy(()=>{let{value:o,grads:a}=A.gradients(()=>n(...s),s,r);return r!=null&&ge(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Su(a),a})}}function QN(n){return N(Cs(n),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{N(t instanceof Dt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),N(e==null||e instanceof Dt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:s,value:r}=A.gradients(()=>n(t),[t],e);return Su(s),{grad:s[0],value:r}}}function tk(n){return N(Cs(n),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{N(Array.isArray(t)&&t.every(r=>r instanceof Dt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),N(e==null||e instanceof Dt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let s=A.gradients(()=>n(...t),t,e);return e!=null&&ge(s.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Su(s.grads),s}}function Np(n,t){N(Cs(n),()=>"The f passed in variableGrads(f) must be a function"),N(t==null||Array.isArray(t)&&t.every(c=>c instanceof Wi),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let c in A.registeredVariables)t.push(A.registeredVariables[c])}let s=e?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),N(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let o=!0,{value:a,grads:i}=A.gradients(n,t,null,o);N(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),N(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let l={};return t.forEach((c,u)=>{i[u]!=null&&(l[c.name]=i[u])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:a,grads:l}}function Hn(n){return A.customGrad(n)}function Su(n){if(n.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function ek(n){let e={x:S(n,"x","neg")};return A.runKernel(fi,e)}let Jt=D({neg_:ek});function nk(n){let e={x:S(n,"x","softplus")};return A.runKernel(Eo,e)}let Xo=D({softplus_:nk});function sk(n){let t=S(n,"x","logSigmoid");return Hn(s=>({value:Jt(Xo(Jt(s))),gradFunc:a=>_(a,Gn(Jt(s)))}))(t)}let sb=D({logSigmoid_:sk});function rk(n,t=null,e=!1){let r={x:S(n,"x","max")},o={reductionIndices:t,keepDims:e};return A.runKernel(li,r,o)}let ln=D({max_:rk});function ok(n,t){let e=S(n,"a","sub"),s=S(t,"b","sub");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(Ro,r)}let at=D({sub_:ok});function ak(n,t=null,e=!1){let s=S(n,"x","sum");s.dtype==="bool"&&(s=rt(s,"int32"));let r={x:s},o={axis:t,keepDims:e};return A.runKernel(Si,r,o)}let ht=D({sum_:ak});function ik(n,t=-1){let e=S(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Hn((r,o)=>{let a=!0,i=ln(r,t,!0),l=at(r,i),c=at(rt(l,"float32"),qe(ht(on(l),t,a)));return o([c]),{value:c,gradFunc:(h,d)=>{let[p]=d,f=!0,m=on(p);return at(h,_(ht(h,t,f),m))}}})(e)}let Tu=D({logSoftmax_:ik});function kp(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function rb(n,t,e){let s=n.length+t.length,r=[],o=0,a=0;for(let i=0;i<s;i++)e.indexOf(i)===-1?r.push(n[o++]):r.push(t[a++]);return r}function we(n,t){let e=[],s=n.length;for(let o=0;o<s;o++)t.indexOf(o)===-1&&e.push(n[o]);let r=t.map(o=>n[o]);return[e,r]}function ne(n,t){let e=t.map(s=>1);return rb(n,e,t)}function Ee(n,t,e){N(kp(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function se(n,t){if(kp(n,t))return null;let e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function Yo(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function ae(n,t){let e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function lk(n,t=null,e=!1){let s=S(n,"x","logSumExp"),r=$t(t,s.shape),o=ln(s,r,!0),a=at(s,o),i=on(a),l=ht(i,r),c=qe(l),u=Z(L(o,c.shape),c);if(e){let h=ne(u.shape,r);return L(u,h)}return u}let Ip=D({logSumExp_:lk});function ck(n,t){let e=S(n,"a","logicalAnd","bool"),s=S(t,"b","logicalAnd","bool");Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(ri,r)}let gn=D({logicalAnd_:ck});function uk(n){let e={x:S(n,"x","logicalNot","bool")};return A.runKernel(oi,e)}let el=D({logicalNot_:uk});function hk(n,t){let e=S(n,"a","logicalOr","bool"),s=S(t,"b","logicalOr","bool");Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(ai,r)}let Eu=D({logicalOr_:hk});function dk(n,t){let e=S(n,"a","logicalXor","bool"),s=S(t,"b","logicalXor","bool");return Nt(e.shape,s.shape),gn(Eu(n,t),el(gn(n,t)))}let ob=D({logicalXor_:dk});function pk(n,t,e,s,r){let o=S(n,"x","maxPool"),a=1,i=o,l=!1;o.rank===3&&(l=!0,i=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),N(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),N(Te(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),r!=null&&N(le(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let c={x:i},u={filterSize:t,strides:e,pad:s,dimRoundingMode:r},h=A.runKernel(ci,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}let nl=D({maxPool_:pk});function fk(n,t=[1,1,1],e,s,r,o="NDHWC"){let a=S(n,"x","maxPool3d"),i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),N(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),N(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),r!=null&&N(le(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let c={x:i},u={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:o},h=A.runKernel(ui,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}let Sp=D({maxPool3d_:fk});function mk(n,t,e,s,r=!1){let a={x:S(n,"x","maxPoolWithArgmax")},i={filterSize:t,strides:e,pad:s,includeBatchInIndex:r},l=A.runKernel(Oc,a,i);return{result:l[0],indexes:l[1]}}let ab=D({maxPoolWithArgmax_:mk});function gk(n,t){let e=S(n,"a","maximum"),s=S(t,"b","maximum");[e,s]=Xt(e,s),e.dtype==="bool"&&(e=rt(e,"int32"),s=rt(s,"int32")),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(fo,r)}let jn=D({maximum_:gk});function yk(n,t=null,e=!1){let r={x:S(n,"x","mean")},o={axis:t,keepDims:e};return A.runKernel(hi,r,o)}let Zt=D({mean_:yk});function bk(n,t=null,e=!1){let r={x:S(n,"x","min")},o={axis:t,keepDims:e};return A.runKernel(di,r,o)}let Jo=D({min_:bk});function xk(n,t){let e=S(n,"a","minimum"),s=S(t,"b","minimum");[e,s]=Xt(e,s),e.dtype==="bool"&&(e=rt(e,"int32"),s=rt(s,"int32")),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(mo,r)}let Zo=D({minimum_:xk});function wk(n,t,e){N(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let s=S(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");N(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);let r=e==="reflect"?1:0;for(let i=0;i<s.rank;i++)N(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),N(t[i][0]>=0&&t[i][0]<=s.shape[i]-r&&t[i][1]>=0&&t[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);let o={paddings:t,mode:e},a={x:s};return A.runKernel(pi,a,o)}let Tp=D({mirrorPad_:wk});function $k(n,t){let e=S(n,"a","mod"),s=S(t,"b","mod");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(go,r)}let Ep=D({mod_:$k});function vk(n){let t=S(n,"x","square"),e={};return A.runKernel("Square",{x:t},e)}let Ot=D({square_:vk});function Ck(n,t=null,e=!1){n=S(n,"x","moments");let s=$t(t,n.shape),r=Zt(n,s,e),o=r.shape;e||(o=ne(r.shape,s));let a=Ot(at(rt(n,"float32"),L(r,o))),i=Zt(a,s,e);return{mean:r,variance:i}}let Au=D({moments_:Ck});function Nk(n,t,e,s){let r=S(t,"data","multiRNNCell"),o=Ui(e,"c","multiRNNCell"),a=Ui(s,"h","multiRNNCell"),i=r,l=[];for(let h=0;h<n.length;h++){let d=n[h](i,o[h],a[h]);l.push(d[0]),l.push(d[1]),i=d[1]}let c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}let kk=D({multiRNNCell_:Nk});function Ik(n,t,e,s=!1){let r=S(n,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);e=e||Math.random();let l={logits:a===1?L(r,[1,-1]):r},c={numSamples:t,seed:e,normalized:s},u=A.runKernel(Lc,l,c);return a===1?L(u,[u.size]):u}let ib=D({multinomial_:Ik});function Sk(n,t){let e=S(n,"a","notEqual"),s=S(t,"b","notEqual");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s};return A.runKernel(mi,r)}let yr=D({notEqual_:Sk});function re(n,t="float32"){if(t==="complex64"){let s=re(n,"float32"),r=re(n,"float32");return ks(s,r)}let e=Ie(H(n),t);return A.makeTensor(e,n,t)}function Tn(n,t="float32"){if(t==="complex64"){let s=Tn(n,"float32"),r=re(n,"float32");return ks(s,r)}let e=vd(H(n),t);return A.makeTensor(e,n,t)}function Tk(n){let e={x:S(n,"x","onesLike")};return A.runKernel(gi,e)}let Le=D({onesLike_:Tk});function Ek(n,t){let e=S(n,"v1","outerProduct"),s=S(t,"v2","outerProduct");N(e.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${s.rank}.`);let r=L(e,[-1,1]),o=L(s,[1,-1]);return It(r,o)}let Ak=D({outerProduct_:Ek});function Dk(n,t,e=0){let s=S(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:e},o={x:s};return A.runKernel(xi,o,r)}let qn=D({pad_:Dk});function Rk(n,t,e=0){return N(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),qn(n,[t],e)}let Fk=D({pad1d_:Rk});function _k(n,t,e=0){return N(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qn(n,t,e)}let Ok=D({pad2d_:_k});function Lk(n,t,e=0){return N(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qn(n,t,e)}let Pk=D({pad3d_:Lk});function zk(n,t,e=0){return N(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qn(n,t,e)}let Mk=D({pad4d_:zk});function Bk(n,t,e){let s=S(n,"x","spaceToBatchND");N(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),N(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),N(s.shape.reduce((a,i,l)=>l>0&&l<=t.length?a&&(i+e[l-1][0]+e[l-1][1])%t[l-1]==0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:s},o={blockShape:t,paddings:e};return A.runKernel(Ti,r,o)}let sl=D({spaceToBatchND_:Bk});function Vk(n,t,e,s,r,o){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");let a=S(n,"x","maxPool"),i=a,l=!1;a.rank===3&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),N(Te(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);let c=mn(i.shape,t,o,r,s),u=[c.dilationHeight,c.dilationWidth],h;s==="same"?h=Uk([c.filterHeight,c.filterWidth],u):h=[[0,0],[0,0]];let d=u[0]===1&&u[1]===1,[p,f]=Wk([c.inHeight,c.inWidth],u,h),m=d?s:"valid",g=d?i:sl(i,u,p),b=(e==="avg"?()=>Ki(g,t,o,m):()=>nl(g,t,o,m))(),C=d?b:Xi(b,u,f);return l?L(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function Wk(n,t,e){let s=e.map(u=>u[0]),r=e.map(u=>u[1]),o=n.concat(s,r),a=t.map((u,h)=>(u-o[h]%u)%u),i=r.map((u,h)=>u+a[h]),l=t.map((u,h)=>[s[h],i[h]]),c=t.map((u,h)=>[0,a[h]]);return[l,c]}function Uk(n,t){let s=n.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,i)=>a-r[i]);return s.map((a,i)=>[r[i],o[i]])}let lb=D({pool_:Vk});function Gk(n,t){let e=S(n,"base","pow"),s=S(t,"exp","pow");[e,s]=Xt(e,s);let r={a:e,b:s};return A.runKernel(bo,r)}let Kn=D({pow_:Gk});function Hk(n,t){let e=S(n,"x","prelu"),s=S(t,"alpha","prelu"),r={x:e,alpha:s};return A.runKernel(wi,r)}let rl=D({prelu_:Hk});function jk(n,t=null,e=!1){let s=S(n,"x","prod");s.dtype==="bool"&&(s=rt(s,"int32"));let r={x:s},o={axis:t,keepDims:e};return A.runKernel(Bc,r,o)}let Du=D({prod_:jk});function qk(n,t,e){let s=H(n),r=null;if(e==null||e==="float32")r=new Float32Array(s);else if(e==="int32")r=new Int32Array(s);else if(e==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${e}`);for(let o=0;o<s;o++)r[o]=t();return A.makeTensor(r,n,e)}let Kk=D({rand_:qk});var Qo=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function FK(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function br(n,t){return t={exports:{}},n(t,t.exports),t.exports}function _K(n){return n&&n.default||n}function OK(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var Xk=br(function(n){(function(t,e,s){function r(l){var c=this,u=i();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var u=new r(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,u),d.state=function(){return o(u,{})}),d}function i(){var l=4022871197,c=function(u){u=u.toString();for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.alea=a})(Qo,n,!1)}),Yk=br(function(n){(function(t,e,s){function r(i){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var c=new r(i),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&o(u,c),h.state=function(){return o(c,{})}),h}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.xor128=a})(Qo,n,!1)}),Jk=br(function(n){(function(t,e,s){function r(i){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:c+=i;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var c=new r(i),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&o(u,c),h.state=function(){return o(c,{})}),h}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.xorwow=a})(Qo,n,!1)}),Zk=br(function(n){(function(t,e,s){function r(i){var l=this;l.next=function(){var u=l.x,h=l.i,d,p,f;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,l.i=h+1&7,p};function c(u,h){var d,p,f=[];if(h===(h|0))p=f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[d&7]=f[d&7]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?p=f[7]=-1:p=f[d],u.x=f,u.i=0,d=256;d>0;--d)u.next()}c(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var c=new r(i),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.x&&o(u,c),h.state=function(){return o(c,{})}),h}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.xorshift7=a})(Qo,n,!1)}),Qk=br(function(n){(function(t,e,s){function r(i){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,p,f;return l.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(u^u>>>16)|0};function c(u,h){var d,p,f,m,g,y=[],b=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,b=Math.max(b,h.length)),f=0,m=-32;m<b;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;u.w=g,u.X=y,u.i=f}c(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var c=new r(i),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.X&&o(u,c),h.state=function(){return o(c,{})}),h}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.xor4096=a})(Qo,n,!1)}),tI=br(function(n){(function(t,e,s){function r(i){var l=this,c="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):c+=i;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var c=new r(i),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&o(u,c),h.state=function(){return o(c,{})}),h}e&&e.exports?e.exports=a:s&&s.amd?s(function(){return a}):this.tychei=a})(Qo,n,!1)}),xr=br(function(n){(function(t,e){var s=this,r=256,o=6,a=52,i="random",l=e.pow(r,o),c=e.pow(2,a),u=c*2,h=r-1,d;function p(w,v,I){var k=[];v=v==!0?{entropy:!0}:v||{};var T=y(g(v.entropy?[w,C(t)]:w==null?b():w,3),k),E=new f(k),F=function(){for(var P=E.g(o),M=l,z=0;P<c;)P=(P+z)*r,M*=r,z=E.g(1);for(;P>=u;)P/=2,M/=2,z>>>=1;return(P+z)/M};return F.int32=function(){return E.g(4)|0},F.quick=function(){return E.g(4)/4294967296},F.double=F,y(C(E.S),t),(v.pass||I||function(P,M,z,U){return U&&(U.S&&m(U,E),P.state=function(){return m(E,{})}),z?(e[i]=P,M):P})(F,T,"global"in v?v.global:this==e,v.state)}e["seed"+i]=p;function f(w){var v,I=w.length,k=this,T=0,E=k.i=k.j=0,F=k.S=[];for(I||(w=[I++]);T<r;)F[T]=T++;for(T=0;T<r;T++)F[T]=F[E=h&E+w[T%I]+(v=F[T])],F[E]=v;(k.g=function(P){for(var M,z=0,U=k.i,B=k.j,V=k.S;P--;)M=V[U=h&U+1],z=z*r+V[h&(V[U]=V[B=h&B+M])+(V[B]=M)];return k.i=U,k.j=B,z})(r)}function m(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function g(w,v){var I=[],k=typeof w,T;if(v&&k=="object")for(T in w)try{I.push(g(w[T],v-1))}catch(E){}return I.length?I:k=="string"?w:w+"\0"}function y(w,v){for(var I=w+"",k,T=0;T<I.length;)v[h&T]=h&(k^=v[h&T]*19)+I.charCodeAt(T++);return C(v)}function b(){try{var w;return d&&(w=d.randomBytes)?w=w(r):(w=new Uint8Array(r),(s.crypto||s.msCrypto).getRandomValues(w)),C(w)}catch(k){var v=s.navigator,I=v&&v.plugins;return[+new Date,s,I,s.screen,C(t)]}}function C(w){return String.fromCharCode.apply(0,w)}if(y(e.random(),t),n.exports){n.exports=p;try{d=f$()}catch(w){}}})([],Math)});xr.alea=Xk,xr.xor128=Yk,xr.xorwow=Jk,xr.xorshift7=Zk,xr.xor4096=Qk,xr.tychei=tI;var eI=xr,ta=eI.alea;class Ap{constructor(t,e,s,r,o){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=o||Math.random();this.random=ta(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*r*i,e=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class nI{constructor(t,e,s,r){this.alpha=t,this.beta=1/e,this.dtype=s;let o=r||Math.random();this.randu=ta(o.toString()),this.randn=new Ap(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,t=r*r,e=1-.331*t*t,s=.5*t+this.d*(1-a+Math.log(a)),o=this.randu(),o<e||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class sI{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=ta(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function LK(n){let t=n.length,e=aI(n),s=oI(n),r=t/6*(Math.pow(e,2)+.25*Math.pow(s-3,2));if(r>5.991)throw new Error(`Invalid p-value for JB: ${r}`)}function PK(n,t,e,s){s==null&&(s=fu());let r=Dp(n);ep(r,t,s),ep(rI(n,r),e,s)}function Dp(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t/n.length}function rI(n,t){let e=0;for(let s=0;s<n.length;s++){let r=n[s]-t;e+=r*r}return Math.sqrt(e/n.length)}function oI(n){let t=Dp(n),e=n.length,s=0,r=0;for(let o=0;o<e;o++){let a=n[o]-t;s+=Math.pow(a,2),r+=Math.pow(a,4)}return 1/e*r/Math.pow(1/e*s,2)}function aI(n){let t=Dp(n),e=n.length,s=0,r=0;for(let o=0;o<e;o++){let a=n[o]-t;s+=Math.pow(a,2),r+=Math.pow(a,3)}return 1/e*r/Math.pow(1/(e-1)*s,3/2)}function iI(n,t,e=1,s="float32",r){if(e==null&&(e=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);let o=new nI(t,e,s,r),a=vt(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}let lI=D({randomGamma_:iI});function cI(n,t=0,e=1,s,r){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);let o=new Ap(t,e,s,!1,r),a=vt(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}let Rp=D({randomNormal_:cI});function uI(n,t=0,e=1,s="float32",r){let o=vt(n,s),a=new sI(t,e,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}let wr=D({randomUniform_:uI});function Ru(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");let r={start:n,stop:t,step:e,dtype:s};return A.runKernel(Vc,{},r)}function hI(n){let e={input:S(n,"input","real")};return A.runKernel(Wc,e)}let ol=D({real_:hI});function dI(n){let e={x:S(n,"x","reciprocal")};return A.runKernel(xo,e)}let Fp=D({reciprocal_:dI});function pI(n){let e={x:S(n,"x","relu")};return A.runKernel(wo,e)}let Xn=D({relu_:pI});function fI(n){let e={x:S(n,"x","relu6")};return A.runKernel($o,e)}let Fu=D({relu6_:fI});function mI(n,t){let s={x:S(n,"x","reverse")},r={dims:t};return A.runKernel(Ni,s,r)}let Ke=D({reverse_:mI});function gI(n){let t=S(n,"x","reverse");return N(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ke(t,0)}let yI=D({reverse1d_:gI});function bI(n,t){let e=S(n,"x","reverse");return N(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Ke(e,t)}let xI=D({reverse2d_:bI});function wI(n,t){let e=S(n,"x","reverse");return N(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Ke(e,t)}let $I=D({reverse3d_:wI});function vI(n,t){let e=S(n,"x","reverse");return N(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Ke(e,t)}let CI=D({reverse4d_:vI});function NI(n){let e={x:S(n,"x","round")};return A.runKernel(vo,e)}let _p=D({round_:NI});function kI(n){let e={x:S(n,"x","rsqrt")};return A.runKernel(Co,e)}let _u=D({rsqrt_:kI});function ut(n,t){if((ke(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ke(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Is(n,[],[],t)}function II(n){let e={x:S(n,"x","selu")};return A.runKernel(No,e)}let Ou=D({selu_:II});function SI(n,t,e,s,r,o=[1,1],a="NHWC"){let i=S(n,"x","separableConv2d"),l=S(t,"depthwiseFilter","separableConv2d"),c=S(e,"pointwiseFilter","separableConv2d"),u=i,h=!1;if(i.rank===3&&(h=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");N(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),N(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),N(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),N(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),N(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let d=l.shape[2],p=l.shape[3];N(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);let f=jo(u,l,s,r,a,o),g=ls(f,c,1,"valid",a);return h?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}let Op=D({separableConv2d_:SI});async function TI(n,t){let e=S(n,"x","setdiff1d"),s=S(t,"y","setdiff1d");N(e.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${s.dtype}).`),N(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),N(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);let r=await e.data(),o=await s.data(),a=new Set(o),i=0;for(let u=0;u<r.length;u++)a.has(r[u])||i++;let l=new ce([i],e.dtype),c=new ce([i],"int32");for(let u=0,h=0;u<r.length;u++)a.has(r[u])||(l.values[h]=r[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}let cb=TI;function EI(n){let e={x:S(n,"x","sign")};return A.runKernel(So,e)}let Lp=D({sign_:EI});function AI(n){let e={x:S(n,"x","sin")};return A.runKernel(ko,e)}let Lu=D({sin_:AI});function DI(n){let e={x:S(n,"x","sinh")};return A.runKernel(Io,e)}let Pu=D({sinh_:DI});function RI(n,t,e){let s=S(n,"x","slice1d");return N(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),St(s,[t],[e])}let zu=D({slice1d_:RI});function FI(n,t,e){let s=S(n,"x","slice2d");return N(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),St(s,t,e)}let Pp=D({slice2d_:FI});function _I(n,t,e){let s=S(n,"x","slice3d");return N(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),St(s,t,e)}let Mu=D({slice3d_:_I});function OI(n,t,e){let s=S(n,"x","slice4d");return N(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),St(s,t,e)}let al=D({slice4d_:OI});function LI(n,t=-1){let e=S(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let s={logits:e},r={dim:t};return A.runKernel(Ai,s,r)}let il=D({softmax_:LI});function PI(n){N(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);let t={input:n};return A.runKernel(kc,t)}let ll=D({fft_:PI});function zI(n){N(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);let t={input:n};return A.runKernel(Ec,t)}let ea=D({ifft_:zI});function MI(n){let t=n.shape[n.shape.length-1],e=n.size/t,s;if(t<=2){let r=L(n,[e,t]);s=ea(r)}else{let r=[e,2*(t-1)],o=L(ol(n),[e,t]),a=L(Nu(n),[e,t]),i=Ke(St(o,[0,1],[e,t-2]),1),l=_(Ke(St(a,[0,1],[e,t-2]),1),ut(-1)),c=ee([o,i],1),u=ee([a,l],1),h=L(ks(c,u),[r[0],r[1]]);s=ea(h)}if(s=ol(s),n.rank===3&&n.shape[0]!==0){let r=s,o=n.shape[0];s=L(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}let Bu=D({irfft_:MI});function BI(n,t,e=0){let r={x:S(n,"x","split")},o={numOrSizeSplits:t,axis:e};return A.runKernel(Ei,r,o)}let Xe=D({split_:BI});function VI(n,t){N(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1],s=n.size/e,r;if(t!=null&&t<e){let f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,r=St(n,f,m),e=t}else if(t!=null&&t>e){let f=n.shape.map(m=>m);f[n.shape.length-1]=t-e,r=ee([n,re(f)],n.shape.length-1),e=t}else r=n;let o=Ct(r),a=L(ks(r,o),[s,e]),i=ll(a),l=Math.floor(e/2)+1,c=ol(i),u=Nu(i),h=Xe(c,[l,e-l],c.shape.length-1),d=Xe(u,[l,e-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,L(ks(h[0],d[0]),p)}let cl=D({rfft_:VI});function WI(n){let e={x:S(n,"x","sqrt")};return A.runKernel(Ao,e)}let Ae=D({sqrt_:WI});function UI(n,t){let e=S(n,"a","squaredDifference"),s=S(t,"b","squaredDifference");[e,s]=Xt(e,s),Nt(e.shape,s.shape);let r={a:e,b:s},o={};return A.runKernel(Do,r,o)}let Vu=D({squaredDifference_:UI});function GI(n,t){let e=S(n,"x","squeeze");return L(e,vs(e.shape,t).newShape)}let Fs=D({squeeze_:GI});function HI(n,t=0){let e=Ui(n,"tensors","stack","string_or_numeric");N(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&N(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let s=e,r={axis:t};return A.runKernel(bi,s,r)}let Ye=D({stack_:HI});function jI(n,t=0){let s={x:S(n,"x","step")},r={alpha:t};return A.runKernel(Lo,s,r)}let na=D({step_:jI});function qI(n,t,e,s,r=0,o=0,a=0,i=0,l=0){let u={x:S(n,"x","stridedSlice")},h={begin:t,end:e,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return A.runKernel(Kc,u,h)}let zp=D({stridedSlice_:qI});function KI(n){let e={x:S(n,"x","tan")};return A.runKernel(Fo,e)}let Mp=D({tan_:KI});function Je(n,t){Qs(n);let e=Wn(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Is(n,null,e,t)}function $r(n,t,e){if(Qs(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let s=Wn(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Is(n,t,s,e)}function XI(n,t,e){if(Qs(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let s=Wn(n,e);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Is(n,t,s,e)}function YI(n,t,e){if(Qs(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let s=Wn(n,e);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Is(n,t,s,e)}function JI(n,t,e){if(Qs(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let s=Wn(n,e);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,Is(n,t,s,e)}function ZI(n,t=1,e=!0){let s=S(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=s.shape[s.shape.length-1];if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let o={x:s},a={k:t,sorted:e},[i,l]=A.runKernel(Xc,o,a);return{values:i,indices:l}}let Bp=D({topk_:ZI});function QI(n,t=0,e=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");let o=new Ap(t,e,s,!0,r),a=vt(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}let ul=D({truncatedNormal_:QI});function tS(n,t=0){let e=S(n,"x","unique","string_or_numeric");N(e.rank>0,()=>"The input tensor must be at least 1D");let s={x:e},r={axis:t},[o,a]=A.runKernel(Yc,s,r);return{values:o,indices:a}}let Wu=D({unique_:tS});function eS(n,t,e){let s=S(n,"x","unsortedSegmentSum"),r=S(t,"segmentIds","unsortedSegmentSum","int32");N(le(e),()=>"numSegments must be of dtype int");let o={x:s,segmentIds:r},a={numSegments:e};return A.runKernel(Fi,o,a)}let Vp=D({unsortedSegmentSum_:eS});function nS(n,t=0){let e=S(n,"x","unstack","string_or_numeric");N(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let s={value:e},r={axis:t};return A.runKernel(Ri,s,r)}let yn=D({unstack_:nS});function ub(n,t=!0,e,s){return A.makeVariable(n,t,e,s)}function Uu(n,t){let e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);let s=vt(n,"int32"),r=vt([e.length,n.length],"int32");for(let o=0;o<e.length;o++){let a=s.indexToLoc(e[o]),i=o*n.length;r.values.set(a,i)}return r.toTensor()}async function sS(n){let t=S(n,"condition","whereAsync","bool"),e=await t.data(),s=Uu(t.shape,e);return n!==t&&t.dispose(),s}let Wp=sS;async function rS(n,t,e){let s=S(n,"tensor","boolMask"),r=S(t,"mask","boolMask","bool"),o=e==null?0:e,a=r.rank,i=s.shape;N(a>0,()=>"mask cannot be scalar"),ge(i.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+a;m++)l*=i[m];let c=i.slice(0,o).concat([l],i.slice(o+a)),u=L(s,c),h=L(r,[-1]),d=await Wp(h),p=Fs(d,[1]),f=mr(u,p,o);return n!==s&&s.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}let oS=rS;function aS(n,t="euclidean",e=null,s=!1){n=S(n,"x","norm");let r=hb(n,t,e),o=r.shape;if(s){let a=$t(e,n.shape);o=ne(r.shape,a)}return L(r,o)}function hb(n,t,e=null){if(n.rank===0)return ue(n);if(n.rank!==1&&e===null)return hb(L(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ht(ue(n),e);if(t===Infinity)return ln(ue(n),e);if(t===-Infinity)return Jo(ue(n),e);if(t==="euclidean"||t===2)return Ae(ht(Kn(ue(n),ut(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return ln(ht(ue(n),e[0]),e[1]-1);if(t===Infinity)return ln(ht(ue(n),e[1]),e[0]);if(t===-Infinity)return Jo(ht(ue(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Ae(ht(Ot(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}let Gu=D({norm_:aS});function iS(n,t,e,s,r=!0){let o=S(n,"v","movingAverage"),a=S(t,"x","movingAverage"),i=S(e,"decay","movingAverage");Qg(o,a),N(At(o.shape,a.shape),()=>"Shape mismatch in v and x");let l=ut(1),c=at(l,i),u=_(at(a,o),c);if(r){N(s!=null,()=>"When using zeroDebias: true, step is required.");let h=S(s,"step","movingAverage");u=dt(u,at(l,Kn(i,h)))}return Z(o,u)}let lS=D({movingAverage_:iS});function cS(n,t,e){let s=S(n,"indices","scatterND","int32"),r=S(t,"updates","scatterND");Xd(r,s,e);let o={indices:s,updates:r},a={shape:e};return A.runKernel(Hc,o,a)}let db=D({scatterND_:cS});function uS(n,t,e,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);let r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);let a=t.size;if(!(t.rank===0||t.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function hS(n,t,e,s=0){let r=S(n,"sparseIndices","sparseToDense","int32"),o=S(t,"sparseValues","sparseToDense"),a=S(s,"defaultValue","sparseToDense",o.dtype);uS(r,o,e,a);let i={sparseIndices:r,sparseValues:o,defaultValue:a},l={outputShape:e};return A.runKernel(qc,i,l)}let Up=D({sparseToDense_:hS});function dS(n,t){let e=S(t,"indices","gatherND","int32"),r={params:S(n,"x","gatherND"),indices:e};return A.runKernel(Tc,r)}let pb=D({gatherND_:dS});function pS(n,t){if(t==null)return n.shape.slice();if(At(n.shape,t))return t;if(n.shape.length===t.length){let e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function fS(n,t,e,s){let r=S(n,"x","dropout");if(N(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),N(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Dt?r.clone():r;let o=pS(r,e),a=1-t,i=dt(Ko(Z(wr(o,0,1,"float32",s),a)),a);return _(r,i)}let fb=D({dropout_:fS});function mb(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Gp(n,t,e){let s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){let a=2*Math.PI*o/(n+s-1);r[o]=t-e*Math.cos(a)}return Je(r,"float32")}async function mS(n,t,e=1){let s=S(n,"predictions","inTopK"),r=S(t,"targets","inTopK");N(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),N(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),ge(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let o=s.shape[s.shape.length-1];N(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);let a=await s.data(),i=await r.data(),[l,c]=[a.length/o,o],u=ye("bool",l);for(let h=0;h<l;h++){let d=h*c,p=a.subarray(d,d+c),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<e;m++)if(f[m].index===i[h]){u[h]=1;break}}return n!==s&&s.dispose(),t!==r&&r.dispose(),Sn(u,r.shape,"bool")}let gS=mS;function yS(n,t,e,s,r,o="NHWC",a){let i=n;n.rank===3&&(i=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]])),N(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),N(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),N(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let c=o==="NHWC"?i.shape[3]:i.shape[1],u=o==="NHWC"?l.shape[3]:l.shape[1];N(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),N(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),a!=null&&N(le(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let h={x:i,dy:l},d={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:e};return A.runKernel(pc,h,d)}let Hp=D({conv2DBackpropFilter_:yS});function Hu(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return _(n,na(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function ju(n,t){let e=t,s=he(n.shape,t.shape);return s.length>0&&(e=ht(e,s)),L(e,n.shape)}function qu(n,t,e,s){if(t==="linear")return n;if(t==="relu")return Xn(n);if(t==="elu")return qo(n);if(t==="relu6")return Fu(n);if(t==="prelu")return rl(n,e);if(t==="leakyrelu")return tl(n,s);throw new Error(`Unknown fused activation ${t}.`)}let Ku=(n,t)=>!(n>0)||t==="linear";function bS({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",Ku(A.state.gradientDepth,l)===!1){let v=ls(n,t,e,s,r,o,a);return i!=null&&(v=Z(v,i)),qu(v,l,c,u)}let h=S(n,"x","conv2d"),d=S(t,"filter","conv2d"),p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),N(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),N(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),a!=null&&N(le(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),N(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),N(Te(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),N(r==="NHWC",()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);let m=xe(p.shape,d.shape,e,o,s,a),g;i!=null&&(g=S(i,"bias","fused conv2d"),[g]=Xt(g,h),Nt(m.outShape,g.shape));let y;c!=null&&(y=S(c,"prelu weights","fused conv2d"));let b=(v,I)=>{let[k,T,E,F]=I,P=Hu(v,E,l);N(As(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);let M=gp(T.shape,P,k,e,s),z=Hp(T,P,k.shape,e,s),U=[M,z];if(F!=null){let B=ju(F,P);U.push(B)}return U},C={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:e,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return i==null?Hn((I,k,T)=>{let E=A.runKernel(Li,C,w);return T([k,I,E]),f&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,d):Hn((I,k,T,E)=>{let F=A.runKernel(Li,C,w);return E([k,I,F,T]),f&&(F=L(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:b}})(p,d,g)}let jp=D({fusedConv2d_:bS});function xS(n,t,e,s,r,o=[1,1],a){let i=n;n.rank===3&&(i=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:i,dy:l},u={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:e};return A.runKernel(xc,c,u)}let gb=D({depthwiseConv2dNativeBackpropFilter_:xS});function wS(n,t,e,s,r,o=[1,1],a){let i=t,l=!1;t.rank===3&&(l=!0,i=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:i,filter:e},u={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:n},h=A.runKernel(wc,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}let yb=D({depthwiseConv2dNativeBackpropInput_:wS});function $S({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(Ku(A.state.gradientDepth,l)===!1){let v=jo(n,t,e,s,r,o,a);return i!=null&&(v=Z(v,i)),qu(v,l,c,u)}let h=S(n,"x","depthwiseConv2d"),d=S(t,"filter","depthwiseConv2d"),p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),N(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),N(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),N(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),N(Te(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),a!=null&&N(le(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${s}.`);let m=xe(p.shape,d.shape,e,o,s,a,!0),g;i!=null&&(g=S(i,"bias","fused conv2d"),[g]=Xt(g,h),Nt(m.outShape,g.shape));let y;c!=null&&(y=S(c,"prelu weights","fused depthwiseConv2d"));let b=(v,I)=>{N(As(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[k,T,E,F]=I,P=Hu(v,E,l),M=yb(T.shape,P,k,e,s,o,a),z=gb(T,P,k.shape,e,s,o,a);if(F!=null){let U=ju(g,P);return[M,z,U]}return[M,z]},C={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:e,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return i==null?Hn((I,k,T)=>{let E=A.runKernel(Pi,C,w);return T([k,I,E]),f&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,d):Hn((I,k,T,E)=>{let F=A.runKernel(Pi,C,w);return E([k,I,F,T]),f&&(F=L(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:b}})(p,d,g)}let bb=D({fusedDepthwiseConv2d_:$S});function vS({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(Ku(A.state.gradientDepth,o)===!1){let F=It(n,t,e,s);return r!=null&&(F=Z(F,r)),qu(F,o,a,i)}let l=S(n,"a","fused matMul"),c=S(t,"b","fused matMul");[l,c]=Xt(l,c);let u=e?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=H(f),y=H(m);N(l.rank>=2&&c.rank>=2&&l.rank===c.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${c.rank}.`),N(At(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${c.shape} must match.`),N(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);let b=l.shape.slice(0,-2).concat([d,p]),C=e?L(l,[g,u,d]):L(l,[g,d,u]),w=s?L(c,[y,p,h]):L(c,[y,h,p]),v;r!=null&&(v=S(r,"bias","fused matMul"),[v]=Xt(v,l),Nt(b,v.shape));let I;a!=null&&(I=S(a,"prelu weights","fused matMul"));let k=(F,P)=>{let[M,z,U,B]=P,V=Hu(L(F,U.shape),U,o),K,j;if(!e&&!s?(K=It(V,z,!1,!0),j=It(M,V,!0,!1)):!e&&s?(K=It(V,z,!1,!1),j=It(V,M,!0,!1)):e&&!s?(K=It(z,V,!1,!0),j=It(M,V,!1,!1)):(K=It(z,V,!0,!0),j=It(V,M,!0,!0)),r!=null){let q=ju(B,V);return[K,j,q]}else return[K,j]},T={a:C,b:w,bias:v,preluActivationWeights:I},E={transposeA:e,transposeB:s,activation:o,leakyreluAlpha:i};return r==null?Hn((P,M,z)=>{let U=A.runKernel(Oi,T,E);return z([P,M,U]),{value:L(U,b),gradFunc:k}})(C,w):Hn((P,M,z,U)=>{let B=A.runKernel(Oi,T,E);return U([P,M,B,z]),{value:L(B,b),gradFunc:k}})(C,w,v)}let Xu=D({fusedMatMul_:vS});var CS=Object.freeze({__proto__:null,conv2d:jp,depthwiseConv2d:bb,matMul:Xu});function NS(n){return Gp(n,.54,.46)}let kS=D({hammingWindow_:NS});function IS(n){return Gp(n,.5,.5)}let xb=D({hannWindow_:IS});function SS(n,t,e,s=!1,r=0){let o=0,a=[];for(;o+t<=n.size;)a.push(St(n,o,t)),o+=e;if(s)for(;o<n.size;){let i=o+t-n.size,l=ee([St(n,o,t-i),Qi([i],r)]);a.push(l),o+=e}return a.length===0?$r([],[0,t]):L(ee(a),[a.length,t])}let wb=D({frame_:SS});function TS(n,t,e,s,r=xb){s==null&&(s=mb(t));let o=wb(n,t,e),a=_(o,r(t)),i=[];for(let l=0;l<o.shape[0];l++)i.push(cl(St(a,[l,0],[1,t]),s));return ee(i)}let ES=D({stft_:TS});function AS(n,t,e,s,r="bilinear",o=0){let a=S(n,"image","cropAndResize"),i=S(t,"boxes","cropAndResize","float32"),l=S(e,"boxInd","cropAndResize","int32"),c=i.shape[0];N(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),N(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),N(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),N(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),N(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),N(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let u={image:a,boxes:i,boxInd:l},h={method:r,extrapolationValue:o,cropSize:s};return A.runKernel(gc,u,h)}let DS=D({cropAndResize_:AS});function RS(n){let t=S(n,"image","flipLeftRight","float32");N(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return A.runKernel(Sc,e,{})}let FS=D({flipLeftRight_:RS});function _S(n,t,e=0,s=.5){let r=S(n,"image","rotateWithOffset","float32");N(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let o={image:r},a={radians:t,fillValue:e,center:s};return A.runKernel(Zc,o,a)}let OS=D({rotateWithOffset_:_S});function sa(n,t,e,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);let a=n.shape[0];return e=Math.min(e,a),N(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),N(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),N(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),N(t.rank===1,()=>"scores must be a 1D tensor"),N(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),N(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function LS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){let o=S(n,"boxes","nonMaxSuppression"),a=S(t,"scores","nonMaxSuppression"),i=sa(o,a,e,s,r);e=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;let l={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return A.runKernel(Pc,{boxes:o,scores:a},l)}let PS=D({nonMaxSuppression_:LS});function zS(n,t,e){let s=MS(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function MS(n,t,e){return VS(n,t,e||BS)}function BS(n,t){return n>t?1:n<t?-1:0}function VS(n,t,e){let s=0,r=n.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);let i=e(t,n[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}function Yu(n,t,e,s,r){return qp(n,t,e,s,r,0)}function Ju(n,t,e,s,r,o){return qp(n,t,e,s,r,0,!1,o,!0)}function Zu(n,t,e,s,r,o){return qp(n,t,e,s,r,o,!0)}function qp(n,t,e,s,r,o,a=!1,i=!1,l=!1){let c=[];for(let g=0;g<t.length;g++)t[g]>r&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort($b);let u=o>0?-.5/o:0,h=[],d=[];for(;h.length<e&&c.length>0;){let g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:C}=g;if(y<r)break;let w=!1;for(let v=h.length-1;v>=C;--v){let I=WS(n,b,h[v]);if(I>=s){w=!0;break}if(g.score=g.score*US(s,u,I),g.score<=r)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(b),d.push(g.score)):g.score>r&&zS(c,g,$b))}let p=h.length,f=e-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function WS(n,t,e){let s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-o)*(l-a),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;let m=Math.max(o,c),g=Math.max(a,u),y=Math.min(i,h),b=Math.min(l,d),C=Math.max(y-m,0)*Math.max(b-g,0);return C/(p+f-C)}function US(n,t,e){let s=Math.exp(t*e*e);return e<=n?s:0}function $b(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function GS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){let o=S(n,"boxes","nonMaxSuppressionAsync"),a=S(t,"scores","nonMaxSuppressionAsync"),i=sa(o,a,e,s,r);e=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;let l=await Promise.all([o.data(),a.data()]),c=l[0],u=l[1],{selectedIndices:h}=Yu(c,u,e,s,r);return o!==n&&o.dispose(),a!==t&&a.dispose(),Je(h,"int32")}let HS=GS;function jS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,o=0){let a=S(n,"boxes","nonMaxSuppression"),i=S(t,"scores","nonMaxSuppression"),l=sa(a,i,e,s,r,o);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;let c={boxes:a,scores:i},u={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},h=A.runKernel(Mc,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}let qS=D({nonMaxSuppressionWithScore_:jS});async function KS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,o=0){let a=S(n,"boxes","nonMaxSuppressionAsync"),i=S(t,"scores","nonMaxSuppressionAsync"),l=sa(a,i,e,s,r,o);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;let c=await Promise.all([a.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=Zu(u,h,e,s,r,o);return a!==n&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Je(d,"int32"),selectedScores:Je(p)}}let XS=KS;function YS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){let a=S(n,"boxes","nonMaxSuppression"),i=S(t,"scores","nonMaxSuppression"),l=sa(a,i,e,s,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:a,scores:i},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:o},f=A.runKernel(zc,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}let JS=D({nonMaxSuppressionPadded_:YS});async function ZS(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){let a=S(n,"boxes","nonMaxSuppressionAsync"),i=S(t,"scores","nonMaxSuppressionAsync"),l=sa(a,i,e,s,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:m}=Ju(d,p,c,u,h,o);return a!==n&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Je(f,"int32"),validOutputs:ut(m,"int32")}}let QS=ZS;function tT(n,t,e=!1,s=!1){let r=S(n,"images","resizeBilinear");N(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),N(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),N(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,i={images:o},l={alignCorners:e,halfPixelCenters:s,size:t},c=A.runKernel(Ci,i,l);return a?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}let vb=D({resizeBilinear_:tT});function eT(n,t,e=!1,s=!1){let r=S(n,"images","resizeNearestNeighbor");N(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),N(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),N(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),N(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,i={images:o},l={alignCorners:e,halfPixelCenters:s,size:t},c=A.runKernel(vi,i,l);return a?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}let Cb=D({resizeNearestNeighbor_:eT});function nT(n,t,e){N(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),N(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let s=S(n,"a","bandPart");N(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);let r=s.shape,[o,a]=s.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(e<=a))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`);t<0&&(t=o),e<0&&(e=a);let i=L(Ru(0,o,1,"int32"),[-1,1]),l=Ru(0,a,1,"int32"),c=at(i,l),u=gn(gr(c,ut(+t,"int32")),Rs(c,ut(-e,"int32"))),h=re([o,a],s.dtype);return L(Ye(yn(L(s,[-1,o,a])).map(d=>Oe(u,d,h))),r)}let sT=D({bandPart_:nT});function rT(n){let t;if(Array.isArray(n)){t=!1,N(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=n[0].shape[0];for(let o=1;o<n.length;++o)N(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else t=!0,n=Xe(n,n.shape[0],0).map(r=>Fs(r,[0]));N(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);let e=[],s=n;for(let r=0;r<n.length;++r)e.push(A.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){let i=_(ht(_(e[a],o)),e[a]);o=at(o,i)}return dt(o,Gu(o,"euclidean"))}));return t?Ye(e,0):e}let oT=D({gramSchmidt_:rT});function aT(n,t=!1){if(N(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Nb(n,t);{let e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=yn(L(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{let[c,u]=Nb(l,t);r.push(c),o.push(u)});let a=L(Ye(r,0),n.shape),i=L(Ye(o,0),n.shape);return[a,i]}}function Nb(n,t=!1){return A.tidy(()=>{N(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);let e=n.shape[0],s=n.shape[1],r=Cu(e),o=Ts(n),a=$r([[1]],[1,1]),i=Ts(a),l=e>=s?s:e;for(let c=0;c<l;++c){let u=o,h=i,d=r;[i,o,r]=A.tidy(()=>{let p=St(o,[c,c],[e-c,1]),f=Gu(p),m=St(o,[c,c],[1,1]),g=Oe(an(m,0),$r([[-1]]),$r([[1]])),y=at(m,_(g,f)),b=dt(p,y);b.shape[0]===1?i=Ts(a):i=ee([a,St(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let C=Jt(dt(It(g,y),f)),w=St(o,[c,0],[e-c,s]),v=_(C,i),I=Rt(i);if(c===0)o=at(w,It(v,It(I,w)));else{let E=at(w,It(v,It(I,w)));o=ee([St(o,[0,0],[c,s]),E],0)}let k=Rt(v),T=St(r,[0,c],[e,r.shape[1]-c]);if(c===0)r=at(T,It(It(T,i),k));else{let E=at(T,It(It(T,i),k));r=ee([St(r,[0,0],[e,c]),E],1)}return[i,o,r]}),bt([u,h,d])}return!t&&e>s&&(r=St(r,[0,0],[e,s]),o=St(o,[0,0],[s,s])),[r,o]})}let iT=D({qr_:aT});(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(x.Reduction||(x.Reduction={}));function lT(n,t,e=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=S(n,"losses","computeWeightedLoss"),r=null;t!=null&&(r=S(t,"weights","computeWeightedLoss"));let o=r==null?s:_(s,r);if(e===x.Reduction.NONE)return o;if(e===x.Reduction.SUM)return ht(o);if(e===x.Reduction.MEAN){if(r==null)return Zt(o);{let a=s.size/r.size,i=dt(ht(o),ht(r));return a>1?dt(i,ut(a)):i}}if(e===x.Reduction.SUM_BY_NONZERO_WEIGHTS){if(r==null)return dt(ht(o),ut(s.size));{let a=_(r,Tn(s.shape)),i=rt(ht(yr(a,ut(0))),"float32");return dt(ht(o),i)}}throw Error(`Unknown reduction: ${e}`)}let us=D({computeWeightedLoss_:lT});function cT(n,t,e,s=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let r=S(n,"labels","absoluteDifference"),o=S(t,"predictions","absoluteDifference"),a=null;e!=null&&(a=S(e,"weights","absoluteDifference")),ge(r.shape,o.shape,"Error in absoluteDifference: ");let i=ue(at(r,o));return us(i,a,s)}let uT=D({absoluteDifference_:cT});function hT(n,t,e,s,r=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let o=S(n,"labels","cosineDistance"),a=S(t,"predictions","cosineDistance"),i=null;s!=null&&(i=S(s,"weights","cosineDistance")),ge(o.shape,a.shape,"Error in cosineDistance: ");let l=ut(1),c=at(l,ht(_(o,a),e,!0));return us(c,i,r)}let dT=D({cosineDistance_:hT});function pT(n,t,e,s=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let r=S(n,"labels","hingeLoss"),o=S(t,"predictions","hingeLoss"),a=null;e!=null&&(a=S(e,"weights","hingeLoss")),ge(r.shape,o.shape,"Error in hingeLoss: ");let i=ut(1);r=at(_(ut(2),r),i);let l=Xn(at(i,_(r,o)));return us(l,a,s)}let fT=D({hingeLoss_:pT});function mT(n,t,e,s=1,r=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let o=S(n,"labels","huberLoss"),a=S(t,"predictions","huberLoss"),i=null;e!=null&&(i=S(e,"weights","huberLoss")),ge(o.shape,a.shape,"Error in huberLoss: ");let l=ut(s),c=ue(at(a,o)),u=Zo(c,l),h=at(c,u),d=Z(_(ut(.5),Ot(u)),_(l,h));return us(d,i,r)}let gT=D({huberLoss_:mT});function yT(n,t,e,s=1e-7,r=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let o=S(n,"labels","logLoss"),a=S(t,"predictions","logLoss"),i=null;e!=null&&(i=S(e,"weights","logLoss")),ge(o.shape,a.shape,"Error in logLoss: ");let l=ut(1),c=ut(s),u=Jt(_(o,qe(Z(a,c)))),h=_(at(l,o),qe(Z(at(l,a),c))),d=at(u,h);return us(d,i,r)}let bT=D({logLoss_:yT});function xT(n,t,e,s=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let r=S(n,"labels","meanSquaredError"),o=S(t,"predictions","meanSquaredError"),a=null;e!=null&&(a=S(e,"weights","meanSquaredError")),ge(r.shape,o.shape,"Error in meanSquaredError: ");let i=Vu(r,o);return us(i,a,s)}let wT=D({meanSquaredError_:xT});function $T(n,t){let e=S(n,"labels","sigmoidCrossEntropyWithLogits"),s=S(t,"logits","sigmoidCrossEntropyWithLogits");ge(e.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=Xn(s),o=_(s,e),a=Iu(on(Jt(ue(s))));return Z(at(r,o),a)}function vT(n,t,e,s=0,r=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let o=S(n,"multiClassLabels","sigmoidCrossEntropy"),a=S(t,"logits","sigmoidCrossEntropy"),i=null;if(e!=null&&(i=S(e,"weights","sigmoidCrossEntropy")),ge(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){let c=ut(s),u=ut(1),h=ut(.5);o=Z(_(o,at(u,c)),_(h,c))}let l=$T(o,a);return us(l,i,r)}let CT=D({sigmoidCrossEntropy_:vT});function NT(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Hn((r,o,a)=>{let l=Ip(o,[e],!0),c=at(rt(o,"float32"),l);a([r,c]);let u=Jt(_(c,r));return{value:ht(u,[e]),gradFunc:(p,f)=>{let[m,g]=f,y=ne(p.shape,[e]);return[_(L(p,y),at(rt(m,"float32"),on(g))),_(L(p,y),at(on(g),rt(m,"float32")))]}}})(n,t)}function kT(n,t,e,s=0,r=x.Reduction.SUM_BY_NONZERO_WEIGHTS){let o=S(n,"onehotLabels","softmaxCrossEntropy"),a=S(t,"logits","softmaxCrossEntropy"),i=null;if(e!=null&&(i=S(e,"weights","softmaxCrossEntropy")),ge(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){let c=ut(s),u=ut(1),h=ut(o.shape[1]);o=Z(_(o,at(u,c)),dt(c,h))}let l=NT(o,a);return us(l,i,r)}let IT=D({softmaxCrossEntropy_:kT});let ST={fft:ll,ifft:ea,rfft:cl,irfft:Bu},TT={hammingWindow:kS,hannWindow:xb,frame:wb,stft:ES},_s={flipLeftRight:FS,resizeNearestNeighbor:Cb,resizeBilinear:vb,rotateWithOffset:OS,cropAndResize:DS,nonMaxSuppression:PS,nonMaxSuppressionAsync:HS,nonMaxSuppressionWithScore:qS,nonMaxSuppressionWithScoreAsync:XS,nonMaxSuppressionPadded:JS,nonMaxSuppressionPaddedAsync:QS},kb={bandPart:sT,gramSchmidt:oT,qr:iT},ET={absoluteDifference:uT,computeWeightedLoss:us,cosineDistance:dT,hingeLoss:fT,huberLoss:gT,logLoss:bT,meanSquaredError:wT,sigmoidCrossEntropy:CT,softmaxCrossEntropy:IT};class hs extends dr{minimize(t,e=!1,s){let{value:r,grads:o}=this.computeGradients(t,s);if(s!=null){let a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return bt(o),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Np(t,e)}dispose(){this.iterations_!=null&&bt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ut(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(hs,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class hl extends hs{constructor(t,e,s=null){super();this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{let o=A.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:O(()=>Ct(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:O(()=>Ct(o).variable(a))});let i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;let l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;O(()=>{let u=Z(_(l,this.rho),_(Ot(i),1-this.rho)),h=_(dt(Ae(Z(c,this.epsilon)),Ae(Z(l,this.epsilon))),i),d=Z(_(c,this.rho),_(Ot(h),1-this.rho));l.assign(u),c.assign(d);let p=Z(_(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(bt(this.accumulatedGrads.map(t=>t.variable)),bt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}hl.className="Adadelta",X(hl);class dl extends hs{constructor(t,e=.1){super();this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{let o=A.registeredVariables[s];if(this.accumulatedGrads[r]==null){let l=!1;this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:O(()=>Qi(o.shape,this.initialAccumulatorValue).variable(l))}}let a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;let i=this.accumulatedGrads[r].variable;O(()=>{let l=Z(i,Ot(a));i.assign(l);let c=Z(_(dt(a,Ae(Z(l,A.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&bt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}dl.className="Adagrad",X(dl);class pl extends hs{constructor(t,e,s,r=null){super();this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],O(()=>{this.accBeta1=ut(e).variable(),this.accBeta2=ut(s).variable()}),r==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);O(()=>{let s=at(1,this.accBeta1),r=at(1,this.accBeta2);e.forEach((o,a)=>{let i=A.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:O(()=>Ct(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:O(()=>Ct(i).variable(l))});let c=Array.isArray(t)?t[a].tensor:t[o];if(c==null)return;let u=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,d=Z(_(u,this.beta1),_(c,1-this.beta1)),p=Z(_(h,this.beta2),_(Ot(c),1-this.beta2)),f=dt(d,s),m=dt(p,r);u.assign(d),h.assign(p);let g=Z(_(dt(f,Z(Ae(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(_(this.accBeta1,this.beta1)),this.accBeta2.assign(_(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&bt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&bt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),O(()=>{this.accBeta1.assign(Kn(this.beta1,this.iterations_+1)),this.accBeta2.assign(Kn(this.beta2,this.iterations_+1))});let e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}pl.className="Adam",X(pl);class fl extends hs{constructor(t,e,s,r=null,o=0){super();this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],O(()=>{this.iteration=ut(0).variable(),this.accBeta1=ut(e).variable()}),r==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);O(()=>{let s=at(1,this.accBeta1),r=dt(-this.learningRate,Z(_(this.iteration,this.decay),1));e.forEach((o,a)=>{let i=A.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ct(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Ct(i).variable(l)});let c=Array.isArray(t)?t[a].tensor:t[o];if(c==null)return;let u=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,d=Z(_(u,this.beta1),_(c,1-this.beta1)),p=_(h,this.beta2),f=ue(c),m=jn(p,f);u.assign(d),h.assign(m);let g=Z(_(dt(r,s),dt(d,Z(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(_(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&bt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&bt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}fl.className="Adamax",X(fl);class ra extends hs{constructor(t){super();this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{let o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;let a=A.registeredVariables[s];O(()=>{let i=Z(_(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=be(ut(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}ra.className="SGD",X(ra);class ml extends ra{constructor(t,e,s=!1){super(t);this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ut(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{let o=A.registeredVariables[s];if(this.accumulations[r]==null){let l=!1;this.accumulations[r]={originalName:`${s}/momentum`,variable:O(()=>Ct(o).variable(l))}}let a=this.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[s];i!=null&&O(()=>{let l,c=Z(_(this.m,a),i);this.useNesterov?l=Z(_(this.c,Z(i,_(c,this.m))),o):l=Z(_(this.c,c),o),a.assign(c),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&bt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}ml.className="Momentum",X(ml);class gl extends hs{constructor(t,e=.9,s=0,r=null,o=!1){super();if(this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=A.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{let o=A.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:O(()=>Ct(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:O(()=>Ct(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:O(()=>Ct(o).variable(a))});let i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;let l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;O(()=>{let u=Z(_(l,this.decay),_(Ot(i),1-this.decay));if(this.centered){let h=this.accumulatedMeanGrads[r].variable,d=Z(_(h,this.decay),_(i,1-this.decay)),p=dt(_(i,this.learningRate),Ae(at(u,Z(Ot(d),this.epsilon)))),f=Z(_(c,this.momentum),p);l.assign(u),h.assign(d),c.assign(f);let m=at(o,f);o.assign(m)}else{let h=Z(_(l,this.decay),_(Ot(i),1-this.decay)),d=Z(_(c,this.momentum),dt(_(i,this.learningRate),Ae(Z(h,this.epsilon))));l.assign(h),c.assign(d);let p=at(o,d);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&bt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&bt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&bt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}gl.className="RMSProp",X(gl);class vr{static sgd(t){return new ra(t)}static momentum(t,e,s=!1){return new ml(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,o=!1){return new gl(t,e,s,r,o)}static adam(t=.001,e=.9,s=.999,r=null){return new pl(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new hl(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,o=0){return new fl(t,e,s,r,o)}static adagrad(t,e=.1){return new dl(t,e)}}let Cr={sgd:vr.sgd,momentum:vr.momentum,adadelta:vr.adadelta,adagrad:vr.adagrad,rmsprop:vr.rmsprop,adamax:vr.adamax,adam:vr.adam};let AT=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function Qu(){return new Promise(n=>AT(()=>n()))}function Kp(n,t){let e=n[0].length;n.forEach((r,o)=>{N(r.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),N(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let s=n[0];n.forEach((r,o)=>{for(let a=0;a<e;a++)N(a===t||r[a]===s[a],()=>`Error in concat${e}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function ds(n,t){let e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}let Xp=30;function th(n){return n<=Xp?n:ac(n,Math.floor(Math.sqrt(n)))}function Yp(n,t,e){let s=e*(typeof n=="number"?n:n[0]),r=t*(typeof n=="number"?n:n[1]);return[s,r]}function yl(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);let o=t.length;for(let a=0;a<o;++a)r=r.concat([n[a+1]/t[a],t[a]]);r=r.concat(n.slice(o+1))}return r}function bl(n,t,e=!0){let s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{let r=[],o=[];for(let a=1;a<n;++a)a>=t*2+1||a%2==1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function xl(n,t,e,s=!0){let r=[];s?r.push(n[0]/e):r.push(n[0]*e);for(let o=1;o<n.length;++o)o<=t.length?s?r.push(t[o-1]*n[o]):r.push(n[o]/t[o-1]):r.push(n[o]);return r}function Jp(n,t){let e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function Zp(n,t,e){let s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}let eh=1.7580993408473768,nh=1.0507009873554805;let Qp=.3275911,tf=.254829592,ef=-.284496736,nf=1.421413741,sf=-1.453152027,rf=1.061405429;function oa(...n){G().getBool("IS_TEST")||console.warn(...n)}function DT(...n){G().getBool("IS_TEST")||console.log(...n)}function ps(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);let e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function Ib(n){let t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function Sb(n){let t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function Tb(n){let t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function of(n,t){let e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function Eb(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function Ab(n,t){let e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){let o=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:e,imag:s}}function Db(n,t,e){let s=(e?2:-2)*Math.PI*(n/t),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}function af(n,t,e=0){let s=[];if(typeof t=="number")N(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{let r=t.reduce((a,i)=>(i===-1&&(a+=1),a),0);N(r<=1,()=>"There should be only one negative value in split array.");let o=t.indexOf(-1);if(o!==-1){let a=t.reduce((i,l)=>l>0?i+l:i);t[o]=n.shape[e]-a}N(n.shape[e]===t.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function Rb(n,t){let e=!1,s;for(n<=Xp?(s=n,e=!0):s=ac(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=ac(n,s+1);return s}function Fb(n,t,e){let s=[],r=n.length;for(let o=0;o<r;o++)o!==t?s.push(n[o]):s.push(e);return s}function lf(n,t,e,s){let r=t.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let h=0;h<s;++h)if(n.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let a=n.shape[e],i=[],l=1,c=1,u=1;for(let h=0;h<s;++h)i.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<e;h++)i.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<r;h++)i.push(t.shape[h]);for(let h=e+1;h<o;h++)i.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:a,outputShape:i}}var RT=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:Rb,computeOutShape:Fb,collectGatherOpShapeInfo:lf});function cf(n){try{return n.map(t=>or(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function _b(n){return n.map(t=>rr(t))}var Ob=Object.freeze({__proto__:null,slice_util:_y,segment_util:RT,fromUint8ToStringArray:cf,fromStringArrayToUint8:_b,upcastType:Ge,axesAreInnerMostDims:kp,combineLocations:rb,computeOutAndReduceShapes:we,expandShapeToKeepDim:ne,assertAxesAreInnerMostDims:Ee,getAxesPermutation:se,getUndoAxesPermutation:Yo,getInnerMostAxes:ae,getBroadcastDims:Zi,getReductionAxes:he,assertAndGetBroadcastShape:Nt,assertParamsConsistent:Kp,computeOutShape:ds,computeDilation2DInfo:qi,computePool2DInfo:mn,computePool3DInfo:as,computeConv2DInfo:xe,computeConv3DInfo:Es,computeDefaultPad:dp,tupleValuesAreOne:As,eitherStridesOrDilationsAreOne:Te,convertConv2DDataFormat:is,getFusedDyActivation:Hu,getFusedBiasGradient:ju,applyActivation:qu,shouldFuse:Ku,PARALLELIZE_THRESHOLD:Xp,computeOptimalWindowSize:th,getImageCenter:Yp,getReshaped:yl,getPermuted:bl,getReshapedPermuted:xl,getSliceBeginCoords:Jp,getSliceSize:Zp,prepareAndValidate:hu,validateUpdateShape:Kd,validateInput:Xd,calculateShapes:Uo,SELU_SCALEALPHA:eh,SELU_SCALE:nh,ERF_P:Qp,ERF_A1:tf,ERF_A2:ef,ERF_A3:nf,ERF_A4:sf,ERF_A5:rf,warn:oa,log:DT,mergeRealAndImagArrays:ps,splitRealAndImagArrays:Ib,complexWithEvenIndex:Sb,complexWithOddIndex:Tb,getComplexWithIndex:of,assignToTypedArray:Eb,exponents:Ab,exponent:Db,prepareSplitSize:af});var FT=Object.freeze({__proto__:null,nonMaxSuppressionV3Impl:Yu,nonMaxSuppressionV4Impl:Ju,nonMaxSuppressionV5Impl:Zu,whereImpl:Uu});let Lb={kernelName:_a,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,na(rt(e,"float32"),-1))}}};let _T={kernelName:Vr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let s=Ot(rt(e,"float32")),r=Ae(at(ut(1),s));return Jt(dt(n,r))}}}};let OT={kernelName:Wr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let s=Ae(at(Ot(rt(e,"float32")),1));return dt(n,s)}}}};let LT={kernelName:sr,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=n,l=he(e.shape,r);return l.length>0&&(i=ht(i,l)),L(i,e.shape)},b:()=>{let i=n,l=he(s.shape,r);return l.length>0&&(i=ht(i,l)),L(i,s.shape)}}}};let PT={kernelName:Oa,saveAllInputs:!0,gradFunc:(n,t)=>{let e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};let zT={kernelName:La,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ct(e)}}};let MT={kernelName:Pa,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ct(e)}}};let BT={kernelName:Ur,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,Ae(at(ut(1),Ot(rt(e,"float32")))))}}};let VT={kernelName:Gr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let s=Ae(Z(ut(1),Ot(rt(e,"float32"))));return dt(n,s)}}}};let WT={kernelName:qr,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=Z(Ot(e),Ot(s)),l=_(n,dt(s,i)),c=he(e.shape,r);return c.length>0&&(l=ht(l,c)),L(l,e.shape)},b:()=>{let i=Z(Ot(e),Ot(s)),l=Jt(_(n,dt(e,i))),c=he(s.shape,r);return c.length>0&&(l=ht(l,c)),L(l,s.shape)}}}};let UT={kernelName:Hr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,Z(Ot(rt(e,"float32")),1))}}};let GT={kernelName:jr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,at(ut(1),Ot(rt(e,"float32"))))}}};function HT(n,t,e,s,r,o){let a=S(n,"dy","avgPool3dGrad"),i=S(t,"input","avgPool3dGrad"),l=a,c=i,u=!1;i.rank===4&&(u=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),N(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),N(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),o!=null&&N(le(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);let h={dy:l,input:c},d={filterSize:e,strides:s,pad:r,dimRoundingMode:o},p=A.runKernel(uc,h,d);return u?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}let jT=D({avgPool3dGrad_:HT});let qT={kernelName:Ma,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{filterSize:r,strides:o,pad:a,dimRoundingMode:i}=e;return{x:()=>jT(n,s,r,o,a,i)}}};function KT(n,t,e,s,r){let o=S(n,"dy","avgPoolGrad"),a=S(t,"input","avgPoolGrad");N(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let i=a,l=o,c=!1;a.rank===3&&(c=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),N(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),N(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let u={dy:l,input:i},h={filterSize:e,strides:s,pad:r},d=A.runKernel(cc,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}let XT=D({avgPoolGrad_:KT});let YT={kernelName:za,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{filterSize:r,strides:o,pad:a}=e;return{x:()=>XT(n,s,r,o,a)}}};let JT={kernelName:Ba,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{let[s,r]=t,{transposeA:o,transposeB:a}=e;return!o&&!a?{a:()=>It(n,r,!1,!0),b:()=>It(s,n,!0,!1)}:!o&&a?{a:()=>It(n,r,!1,!1),b:()=>It(n,s,!0,!1)}:o&&!a?{a:()=>It(r,n,!1,!0),b:()=>It(s,n,!1,!1)}:{a:()=>It(r,n,!0,!0),b:()=>It(n,s,!0,!0)}}};let ZT={kernelName:Va,gradFunc:(n,t,e)=>{let{blockShape:s,crops:r}=e;return{x:()=>sl(n,s,r)}}};let QT={kernelName:jg,gradFunc:(n,t,e)=>{let s=e,r=s.inputShape,o=s.shape,a=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])a[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);let i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>ht(n,i,!0)}}};let tE={kernelName:Kr,gradFunc:n=>({x:()=>n.clone()})};let eE={kernelName:Xr,gradFunc:n=>({x:()=>Ct(n)})};let nE={kernelName:Yr,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{clipValueMin:r,clipValueMax:o}=e;return{x:()=>Oe(gn(Rs(s,r),gr(s,o)),n,Ct(n))}}};let sE={kernelName:Wa,inputsToSave:["x"],gradFunc:Lb.gradFunc};let rE={kernelName:Ua,saveAllInputs:!0,gradFunc:(n,t,e)=>{let s=t.map(l=>l.shape),{axis:r}=e,o=$t(r,t[0].shape)[0],a=s.map(l=>l[o]);return Xe(n,a,o).map(l=>()=>l)}};let oE={kernelName:Ga,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[s,r]=t,{dilations:o,strides:a,pad:i,dataFormat:l}=e;return N(As(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>gp(s.shape,n,r,a,i,l),filter:()=>Hp(s,n,r.shape,a,i,l)}}};let aE={kernelName:Ha,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{let[s,r]=t,{strides:o,pad:a,dataFormat:i,dimRoundingMode:l}=e;return{dy:()=>ls(n,r,o,a,i,1,l),filter:()=>Hp(n,s,r.shape,o,a,i,l)}}};function iE(n,t,e,s,r){let o=n;n.rank===4&&(o=L(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=t;a.rank===4&&(a=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),N(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),N(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),N(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),N(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),N(a.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${e[4]}).`);let i={x:o,dy:a},l={strides:s,pad:r,filterShape:e};return A.runKernel(fc,i,l)}let lE=D({conv3DBackpropFilter_:iE});let cE={kernelName:ja,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:s,strides:r,pad:o}=e;N(As(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let[a,i]=t;return{x:()=>Yy(a.shape,n,i,r,o),filter:()=>lE(a,n,i.shape,r,o)}}};let uE={kernelName:Jr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(Jt(Lu(rt(e,"float32"))),n)}}};let hE={kernelName:Zr,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(Pu(rt(e,"float32")),n)}}};let dE={kernelName:qa,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{axis:r,exclusive:o,reverse:a}=e;return{x:()=>{let i=se([r],s.rank),l=vu(n,r,o,!a);return i!=null&&(l=Rt(l,i)),l}}}};let pE={kernelName:Ka,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:s,strides:r,pad:o,dimRoundingMode:a}=e,i=s==null?[1,1]:s;N(As(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[l,c]=t;return N(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),N(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),N(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),N(Te(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),a!=null&&N(le(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`),{x:()=>yb(l.shape,n,c,r,o,s,a),filter:()=>gb(l,n,c.shape,r,o,s,a)}}};let fE={kernelName:Xa,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[s,r]=t,o={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>A.runKernel(vc,o,e),filter:()=>A.runKernel(Cc,a,e)}}};let mE={kernelName:to,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t,s={dy:n,y:e};return{x:()=>A.runKernel(Nc,s)}}};let gE={kernelName:eo,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,s=_(on(Jt(Ot(e))),2/Math.sqrt(Math.PI));return{x:()=>_(n,s)}}};let yE={kernelName:no,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,e)}}};let bE={kernelName:Ja,inputsToSave:["input"],gradFunc:(n,t)=>{let[e]=t;return{input:()=>L(n,e.shape)}}};let xE={kernelName:so,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,on(e))}}};let wE={kernelName:ro,gradFunc:n=>({x:()=>Ct(n)})};let $E={kernelName:oo,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=dt(n,rt(s,"float32")),l=he(e.shape,r);return l.length>0?L(ht(i,l),e.shape):i},b:()=>{let i=_(n,rt(e,"float32")),l=he(s.shape,r);l.length>0&&(i=L(ht(i,l),s.shape));let c=Ot(s);return Jt(dt(i,rt(c,"float32")))}}}};let vE={kernelName:Za,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{let{varianceEpsilon:s}=e,[r,o,a,i]=t,l=i==null?ut(1):i,c=he(o.shape,r.shape),u=[];if(o.rank===1){for(let w=0;w<r.shape.length-1;++w)u.push(r.shape[w]);u.push(1)}let h=at(r,o),d=_(n,l),p=_u(Z(a,ut(s))),f=_(_(_(p,p),p),ut(-.5));return{x:()=>o.rank===1?L(_(_(n,Ds(L(p,[1,1,1,o.shape[0]]),u)),l),r.shape):L(_(_(n,p),l),r.shape),mean:()=>{let w=_(_(p,ut(-1)),d);return o.rank===1&&(w=ht(w,c)),L(w,o.shape)},variance:()=>{let w=_(_(f,h),d);return o.rank===1&&(w=ht(w,c)),L(w,o.shape)},scale:()=>{let w=_(h,p),v=_(n,w);return o.rank===1&&(v=ht(v,c)),L(v,o.shape)},offset:()=>{let w=n;return o.rank===1&&(w=ht(w,c)),L(w,o.shape)}}}};let CE={kernelName:Qa,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{let[s,r]=t,{axis:o}=e,a=$t(o,s.shape)[0];return{x:()=>{let l=s.shape,c=r.size,u=l.slice(0,a),h=u.length,d=l.slice(o,l.length).slice(1),p=d.length,f=Pb(0,h),m=Pb(h+1,h+1+p),g=zb([u,[c],d]),y=L(n,g),b=L(r,[c]),C=zb([[h],f,m]),w=Rt(y,C),v=Vp(w,b,s.shape[a]),I=Yo(C);return v=Rt(v,I),v},indices:()=>r}}};function Pb(n,t){let e=[];for(let s=n;s<t;++s)e.push(s);return e}function zb(n){let t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}let NE={kernelName:ao,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t;return{a:()=>Ct(e),b:()=>Ct(s)}}};let kE={kernelName:io,gradFunc:n=>({x:()=>rt(n,"float32")})};let IE={kernelName:lo,gradFunc:n=>({x:()=>Ct(n)})};let SE={kernelName:co,gradFunc:n=>({x:()=>Ct(n)})};let TE={kernelName:uo,gradFunc:n=>({x:()=>Ct(n)})};let EE={kernelName:ei,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{alpha:r}=e,o=an(s,0);return{x:()=>Oe(o,n,_(n,r))}}};let AE={kernelName:po,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,Z(e,1))}}};let DE={kernelName:ho,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,rt(e,"float32"))}}};let RE={kernelName:qg,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[s]=t,{axis:r}=e;return{logits:()=>{let o=!0,a=on(s);return at(n,_(ht(n,r,o),a))}}}};function FE(n,t,e,s=5,r=1,o=1,a=.5){let i={x:n,y:t,dy:e},l={depthRadius:s,bias:r,alpha:o,beta:a};return A.runKernel(Rc,i,l)}let _E=D({localResponseNormalizationBackprop_:FE});let OE={kernelName:ii,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[s,r]=t,{depthRadius:o,bias:a,alpha:i,beta:l}=e;return{x:()=>_E(s,r,n,o,a,i,l)}}};function Mb(n,t,e,s){return t.rank<e.rank&&(t=L(t,ne(t.shape,s))),n.rank<e.rank&&(n=L(n,ne(n.shape,s))),{x:()=>_(n,rt(cs(e,t),n.dtype))}}let Bb={kernelName:li,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let s=e,{reductionIndices:r}=s,o=t[0],a=t[1],i=$t(r,o.shape),l=Mb(n,a,o,i);return{x:()=>l.x()}}};let LE={kernelName:fo,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t;return{a:()=>_(n,rt(Rs(e,s),"float32")),b:()=>_(n,rt(ku(e,s),"float32"))}}};function PE(n,t,e,s,r,o,a){let i=S(n,"dy","maxPool3dGrad"),l=S(t,"input","maxPool3dGrad"),c=S(e,"output","maxPool3dGrad"),u=i,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=L(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),N(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),N(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),N(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),a!=null&&N(le(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let f={dy:u,input:h,output:d},m={filterSize:s,strides:r,pad:o,dimRoundingMode:a},g=A.runKernel(_c,f,m);return p?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}let zE=D({maxPool3dGrad_:PE});let ME={kernelName:ui,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[s,r]=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=e;return{x:()=>zE(n,s,r,o,a,i,l)}}};function BE(n,t,e,s,r,o,a){let i=S(n,"dy","maxPoolGrad"),l=S(t,"input","maxPoolGrad"),c=S(e,"output","maxPoolGrad");N(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),N(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),N(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),a!=null&&N(le(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let u={dy:i,input:l,output:c},h={filterSize:s,strides:r,pad:o,dimRoundingMode:a};return A.runKernel(Fc,u,h)}let VE=D({maxPoolGrad_:BE});let WE={kernelName:ci,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[s,r]=t,{filterSize:o,strides:a,pad:i}=e;return{x:()=>VE(n,s,r,o,a,i)}}};let UE={kernelName:hi,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{axis:r}=e,o=$t(r,s.shape),i=we(s.shape,o)[1],l=H(i);return{x:()=>{let u=s.shape.slice();o.forEach(p=>{u[p]=1});let h=L(n,u);return dt(_(h,Tn(s.shape,"float32")),l)}}}};let GE={kernelName:di,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let s=e,{axis:r}=s,[o,a]=t,i=$t(r,o.shape),l=Mb(n,a,o,i);return{x:()=>l.x()}}};let HE={kernelName:mo,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t;return{a:()=>_(n,rt(gr(e,s),"float32")),b:()=>_(n,rt(an(e,s),"float32"))}}};let jE={kernelName:pi,inputsToSave:["x"],gradFunc:(n,t,e)=>{let s=t[0],{paddings:r}=e,o=r.map(a=>a[0]);return{x:()=>St(n,o,s.shape)}}};let qE={kernelName:go,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=he(e.shape,r);return i.length>0?L(ht(n,i),e.shape):n},b:()=>{let i=_(n,Jt(Ko(dt(e,s)))),l=he(s.shape,r);return l.length>0?L(ht(i,l),s.shape):i}}}};let KE={kernelName:yo,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=_(n,rt(s,"float32")),l=he(e.shape,r);return l.length>0?L(ht(i,l),e.shape):i},b:()=>{let i=_(n,rt(e,"float32")),l=he(s.shape,r);return l.length>0?L(ht(i,l),s.shape):i}}}};let XE={kernelName:fi,gradFunc:n=>({x:()=>Jt(n)})};let YE={kernelName:yi,inputsToSave:["indices"],gradFunc:(n,t)=>{let e=t[0];return{indices:()=>re(e.shape,"float32")}}};let JE={kernelName:gi,gradFunc:n=>({x:()=>Ct(n)})};let ZE={kernelName:bi,saveAllInputs:!0,gradFunc:(n,t,e)=>{let{axis:s}=e;return yn(n,s).map(o=>()=>o)}};let Vb={kernelName:xi,inputsToSave:["x"],gradFunc:(n,t,e)=>{let s=t[0],{paddings:r}=e,o=r.map(a=>a[0]);return{x:()=>St(n,o,s.shape)}}};let QE={kernelName:bo,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{let[e,s,r]=t,o=e,a=s,i=Nt(o.shape,a.shape);return{a:()=>{let u=rt(a,"float32"),h=_(n,_(u,Kn(o,at(u,ut(1))))),d=he(o.shape,i);return d.length>0&&(h=ht(h,d)),L(h,o.shape)},b:()=>{let u=an(o,0),h=Oe(u,qe(o),Ct(o)),d=_(n,_(r,h)),p=he(a.shape,i);return p.length>0&&(d=ht(d,p)),L(d,a.shape)}}}};let t2={kernelName:wi,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{let[e,s]=t,r=an(e,0);return{x:()=>Oe(r,n,_(n,s)),alpha:()=>{let o=Oe(r,Ct(n),_(n,e)),a=he(s.shape,n.shape);return a.length>0&&(o=ht(o,a)),L(o,s.shape)}}}};let e2={kernelName:Qr,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=dt(n,rt(s,"float32")),l=he(e.shape,r);return l.length>0?L(ht(i,l),e.shape):i},b:()=>{let i=_(n,rt(e,"float32")),l=he(s.shape,r);l.length>0&&(i=L(ht(i,l),s.shape));let c=Ot(s);return Jt(dt(i,rt(c,"float32")))}}}};let n2={kernelName:xo,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,Jt(Ot(e)))}}};let s2={kernelName:$o,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,s=_(gr(e,6),na(e));return{x:()=>_(n,rt(s,"float32"))}}};let r2={kernelName:wo,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,rt(na(e),"float32"))}}};let o2={kernelName:$i,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>L(n,e.shape)}}};let a2={kernelName:Ci,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[s]=t,r={dy:n,images:s};return{images:()=>A.runKernel(Gc,r,e)}}};let i2={kernelName:vi,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[s]=t,r={dy:n,images:s};return{images:()=>A.runKernel(Uc,r,e)}}};let l2={kernelName:Ni,gradFunc:(n,t,e)=>{let{dims:s}=e,r=$t(s,n.shape);return{x:()=>Ke(n,r)}}};let c2={kernelName:vo,gradFunc:n=>({x:()=>Ct(n)})};let u2={kernelName:Co,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Jt(dt(n,_(Kn(e,1.5),2)))}}};let h2={kernelName:ki,inputsToSave:["condition"],gradFunc:(n,t)=>{let[e]=t;return{condition:()=>rt(Ct(e),"float32"),t:()=>_(n,rt(e,n.dtype)),e:()=>_(n,rt(el(e),n.dtype))}}};let d2={kernelName:No,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let s=an(e,ut(0)),r=ut(eh),o=ut(nh),a=_(n,o),i=_(_(n,r),on(rt(e,"float32")));return Oe(s,a,i)}}}};let p2={kernelName:To,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,_(e,at(ut(1),e)))}}};let f2={kernelName:So,gradFunc:n=>({x:()=>Ct(n)})};let m2={kernelName:ko,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(Ji(rt(e,"float32")),n)}}};let g2={kernelName:Io,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_($u(rt(e,"float32")),n)}}};let y2={kernelName:Ii,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{begin:r,size:o}=e,a=s.shape,[i,l]=pu(s,r,o),c=[];for(let u=0;u<n.rank;u++)c.push([i[u],a[u]-i[u]-l[u]]);return{x:()=>qn(n,c)}}};let b2={kernelName:Ai,outputsToSave:[!0],gradFunc:(n,t,e)=>{let[s]=t,{dim:r}=e,o=!0,a=_(n,s);return{logits:()=>at(a,_(ht(a,[r],o),s))}}};let x2={kernelName:Eo,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,Gn(e))}}};let Wb={kernelName:Ti,gradFunc:(n,t,e)=>{let{blockShape:s,paddings:r}=e;return{x:()=>Xi(n,s,r)}}};let Ub={kernelName:Ei,gradFunc:(n,t,e)=>{let{axis:s}=e;return{x:()=>ee(n,s)}}};let w2={kernelName:Ao,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,_(Ae(rt(e,"float32")),2))}}};let $2={kernelName:jc,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(n,_(rt(e,"float32"),2))}}};let v2={kernelName:Do,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=ut(2);return{a:()=>_(n,_(r,at(e,s))),b:()=>_(n,_(r,at(s,e)))}}};let C2={kernelName:Lo,gradFunc:n=>({x:()=>Ct(n)})};let N2={kernelName:Ro,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,s]=t,r=Nt(e.shape,s.shape);return{a:()=>{let i=n,l=he(e.shape,r);return l.length>0&&(i=ht(i,l)),L(i,e.shape)},b:()=>{let i=n,l=he(s.shape,r);return l.length>0&&(i=ht(i,l)),L(Jt(i),s.shape)}}}};let k2={kernelName:Si,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,r=s.shape.slice(),{axis:o}=e;$t(o,s.shape).forEach(c=>{r[c]=1});let i=L(n,r),l=_(i,Tn(s.shape,"float32"));return{x:()=>l}}};let I2={kernelName:Fo,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>dt(n,Ot(Ji(e)))}}};let S2={kernelName:_o,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>_(at(ut(1),Ot(e)),n)}}};let T2={kernelName:Oo,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[s]=t,{reps:r}=e;return{x:()=>{let a=Ct(s);if(s.rank===1)for(let i=0;i<r[0];++i)a=Z(a,St(n,[i*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)a=Z(a,St(n,[i*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)a=Z(a,St(n,[i*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let u=0;u<r[3];++u)a=Z(a,St(n,[i*s.shape[0],l*s.shape[1],c*s.shape[2],u*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};let E2={kernelName:Di,gradFunc:(n,t,e)=>{let s=e,{perm:r}=s,o=Yo(r);return{x:()=>Rt(n,o)}}};let A2={kernelName:Ri,gradFunc:(n,t,e)=>{let s=e,{axis:r}=s;return{value:()=>Ye(n,r)}}};let D2={kernelName:Fi,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R2(n,e)}}};function R2(n,t){let e=jn(t,Ct(t)),s=mr(n,e),r=Rs(t,ut(0,"int32")),o=s.rank-r.rank;for(let i=0;i<o;++i)r=je(r,i+1);r=gn(r,Tn(s.shape,"bool"));let a=Ct(s);return Oe(r,s,a)}let F2={kernelName:_i,gradFunc:n=>({x:()=>Ct(n)})};let _2=[Lb,_T,OT,LT,PT,zT,MT,BT,VT,WT,UT,GT,qT,YT,JT,ZT,QT,tE,eE,nE,sE,rE,aE,oE,cE,uE,hE,dE,pE,fE,e2,mE,gE,yE,bE,xE,$E,wE,vE,CE,NE,kE,IE,SE,TE,EE,AE,DE,RE,OE,Bb,Bb,LE,ME,WE,UE,GE,HE,jE,qE,KE,XE,YE,JE,ZE,Vb,Vb,QE,t2,n2,s2,r2,o2,a2,i2,l2,c2,u2,h2,d2,p2,f2,m2,g2,y2,b2,x2,Wb,Wb,Ub,Ub,w2,v2,$2,C2,N2,k2,I2,S2,T2,E2,A2,D2,F2];for(let n of _2)Kg(n);W().prototype.abs=function(){return this.throwIfDisposed(),ue(this)};W().prototype.acos=function(){return this.throwIfDisposed(),rp(this)};W().prototype.acosh=function(){return this.throwIfDisposed(),op(this)};W().prototype.add=function(n){return this.throwIfDisposed(),Z(this,n)};W().prototype.all=function(n,t){return this.throwIfDisposed(),yu(this,n,t)};W().prototype.any=function(n,t){return this.throwIfDisposed(),Hi(this,n,t)};W().prototype.argMax=function(n){return this.throwIfDisposed(),ji(this,n)};W().prototype.argMin=function(n){return this.throwIfDisposed(),ap(this,n)};W().prototype.asScalar=function(){return this.throwIfDisposed(),N(this.size===1,()=>"The array must have only 1 element."),L(this,[])};W().prototype.asType=function(n){return this.throwIfDisposed(),rt(this,n)};W().prototype.as1D=function(){return this.throwIfDisposed(),L(this,[this.size])};W().prototype.as2D=function(n,t){return this.throwIfDisposed(),L(this,[n,t])};W().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),L(this,[n,t,e])};W().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),L(this,[n,t,e,s])};W().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),L(this,[n,t,e,s,r])};W().prototype.asin=function(){return this.throwIfDisposed(),ip(this)};W().prototype.asinh=function(){return this.throwIfDisposed(),lp(this)};W().prototype.atan=function(){return this.throwIfDisposed(),cp(this)};W().prototype.atan2=function(n){return this.throwIfDisposed(),up(this,n)};W().prototype.atanh=function(){return this.throwIfDisposed(),hp(this)};W().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Ki(this,n,t,e,s)};W().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Xi(this,n,t)};W().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),fr(this,n,t,e,s,r)};W().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Yi(this,n)};W().prototype.cast=function(n){return this.throwIfDisposed(),rt(this,n)};W().prototype.ceil=function(){return this.throwIfDisposed(),mp(this)};W().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Me(this,n,t)};W().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Dt&&(n=[n]),ee([this,...n],t)};W().prototype.conv1d=function(n,t,e,s,r,o){return this.throwIfDisposed(),xu(this,n,t,e,s,r,o)};W().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),wu(this,n,t,e,s,r)};W().prototype.conv2d=function(n,t,e,s,r,o){return this.throwIfDisposed(),ls(this,n,t,e,s,r,o)};W().prototype.cos=function(){return this.throwIfDisposed(),Ji(this)};W().prototype.cosh=function(){return this.throwIfDisposed(),$u(this)};W().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),vu(this,n,t,e)};W().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),bp(this,n,t)};W().prototype.depthwiseConv2d=function(n,t,e,s,r,o){return this.throwIfDisposed(),jo(this,n,t,e,s,r,o)};W().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),xp(this,n,t,e,s,r)};W().prototype.divNoNan=function(n){return this.throwIfDisposed(),wp(this,n)};W().prototype.div=function(n){return this.throwIfDisposed(),dt(this,n)};W().prototype.dot=function(n){return this.throwIfDisposed(),Zy(this,n)};W().prototype.elu=function(){return this.throwIfDisposed(),qo(this)};W().prototype.equal=function(n){return this.throwIfDisposed(),cs(this,n)};W().prototype.erf=function(){return this.throwIfDisposed(),$p(this)};W().prototype.exp=function(){return this.throwIfDisposed(),on(this)};W().prototype.expandDims=function(n){return this.throwIfDisposed(),je(this,n)};W().prototype.expm1=function(){return this.throwIfDisposed(),vp(this)};W().prototype.fft=function(){return this.throwIfDisposed(),ll(this)};W().prototype.flatten=function(){return this.throwIfDisposed(),L(this,[this.size])};W().prototype.floor=function(){return this.throwIfDisposed(),Ko(this)};W().prototype.floorDiv=function(n){return this.throwIfDisposed(),gu(this,n)};W().prototype.gather=function(n,t){return this.throwIfDisposed(),mr(this,n,t)};W().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Rs(this,n)};W().prototype.greater=function(n){return this.throwIfDisposed(),an(this,n)};W().prototype.ifft=function(){return this.throwIfDisposed(),ea(this)};W().prototype.irfft=function(){return this.throwIfDisposed(),Bu(this)};W().prototype.isFinite=function(){return this.throwIfDisposed(),Qy(this)};W().prototype.isInf=function(){return this.throwIfDisposed(),tb(this)};W().prototype.isNaN=function(){return this.throwIfDisposed(),eb(this)};W().prototype.leakyRelu=function(n){return this.throwIfDisposed(),tl(this,n)};W().prototype.lessEqual=function(n){return this.throwIfDisposed(),gr(this,n)};W().prototype.less=function(n){return this.throwIfDisposed(),ku(this,n)};W().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),Cp(this,n,t,e,s)};W().prototype.logSigmoid=function(){return this.throwIfDisposed(),sb(this)};W().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Tu(this,n)};W().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),Ip(this,n,t)};W().prototype.log=function(){return this.throwIfDisposed(),qe(this)};W().prototype.log1p=function(){return this.throwIfDisposed(),Iu(this)};W().prototype.logicalAnd=function(n){return this.throwIfDisposed(),gn(this,n)};W().prototype.logicalNot=function(){return this.throwIfDisposed(),el(this)};W().prototype.logicalOr=function(n){return this.throwIfDisposed(),Eu(this,n)};W().prototype.logicalXor=function(n){return this.throwIfDisposed(),ob(this,n)};W().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),It(this,n,t,e)};W().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),nl(this,n,t,e,s)};W().prototype.max=function(n,t){return this.throwIfDisposed(),ln(this,n,t)};W().prototype.maximum=function(n){return this.throwIfDisposed(),jn(this,n)};W().prototype.mean=function(n,t){return this.throwIfDisposed(),Zt(this,n,t)};W().prototype.min=function(n,t){return this.throwIfDisposed(),Jo(this,n,t)};W().prototype.minimum=function(n){return this.throwIfDisposed(),Zo(this,n)};W().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),Tp(this,n,t)};W().prototype.mod=function(n){return this.throwIfDisposed(),Ep(this,n)};W().prototype.mul=function(n){return this.throwIfDisposed(),_(this,n)};W().prototype.neg=function(){return this.throwIfDisposed(),Jt(this)};W().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Gu(this,n,t,e)};W().prototype.notEqual=function(n){return this.throwIfDisposed(),yr(this,n)};W().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),hr(this,n,t,e)};W().prototype.onesLike=function(){return this.throwIfDisposed(),Le(this)};W().prototype.pad=function(n,t){return this.throwIfDisposed(),qn(this,n,t)};W().prototype.pool=function(n,t,e,s,r){return this.throwIfDisposed(),lb(this,n,t,e,s,r)};W().prototype.pow=function(n){return this.throwIfDisposed(),Kn(this,n)};W().prototype.prelu=function(n){return this.throwIfDisposed(),rl(this,n)};W().prototype.prod=function(n,t){return this.throwIfDisposed(),Du(this,n,t)};W().prototype.reciprocal=function(){return this.throwIfDisposed(),Fp(this)};W().prototype.relu=function(){return this.throwIfDisposed(),Xn(this)};W().prototype.relu6=function(){return this.throwIfDisposed(),Fu(this)};W().prototype.reshapeAs=function(n){return this.throwIfDisposed(),L(this,n.shape)};W().prototype.reshape=function(n){return this.throwIfDisposed(),L(this,n)};W().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),vb(this,n,t,e)};W().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),Cb(this,n,t,e)};W().prototype.reverse=function(n){return this.throwIfDisposed(),Ke(this,n)};W().prototype.rfft=function(){return this.throwIfDisposed(),cl(this)};W().prototype.round=function(){return this.throwIfDisposed(),_p(this)};W().prototype.rsqrt=function(){return this.throwIfDisposed(),_u(this)};W().prototype.selu=function(){return this.throwIfDisposed(),Ou(this)};W().prototype.separableConv2d=function(n,t,e,s,r,o){return this.throwIfDisposed(),Op(this,n,t,e,s,r,o)};W().prototype.sigmoid=function(){return this.throwIfDisposed(),Gn(this)};W().prototype.sign=function(){return this.throwIfDisposed(),Lp(this)};W().prototype.sin=function(){return this.throwIfDisposed(),Lu(this)};W().prototype.sinh=function(){return this.throwIfDisposed(),Pu(this)};W().prototype.slice=function(n,t){return this.throwIfDisposed(),St(this,n,t)};W().prototype.softmax=function(n){return this.throwIfDisposed(),il(this,n)};W().prototype.softplus=function(){return this.throwIfDisposed(),Xo(this)};W().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),sl(this,n,t)};W().prototype.split=function(n,t){return this.throwIfDisposed(),Xe(this,n,t)};W().prototype.sqrt=function(){return this.throwIfDisposed(),Ae(this)};W().prototype.square=function(){return this.throwIfDisposed(),Ot(this)};W().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Vu(this,n)};W().prototype.squeeze=function(n){return this.throwIfDisposed(),Fs(this,n)};W().prototype.stack=function(n,t){this.throwIfDisposed();let e=n instanceof Dt?[this,n]:[this,...n];return Ye(e,t)};W().prototype.step=function(n){return this.throwIfDisposed(),na(this,n)};W().prototype.stridedSlice=function(n,t,e,s,r,o,a,i){return this.throwIfDisposed(),zp(this,n,t,e,s,r,o,a,i)};W().prototype.sub=function(n){return this.throwIfDisposed(),at(this,n)};W().prototype.sum=function(n,t){return this.throwIfDisposed(),ht(this,n,t)};W().prototype.tan=function(){return this.throwIfDisposed(),Mp(this)};W().prototype.tanh=function(){return this.throwIfDisposed(),Ho(this)};W().prototype.tile=function(n){return this.throwIfDisposed(),Ds(this,n)};W().prototype.toBool=function(){return this.throwIfDisposed(),rt(this,"bool")};W().prototype.toFloat=function(){return this.throwIfDisposed(),rt(this,"float32")};W().prototype.toInt=function(){return this.throwIfDisposed(),rt(this,"int32")};W().prototype.topk=function(n,t){return this.throwIfDisposed(),Bp(this,n,t)};W().prototype.transpose=function(n){return this.throwIfDisposed(),Rt(this,n)};W().prototype.unique=function(n){return this.throwIfDisposed(),Wu(this,n)};W().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),Vp(this,n,t)};W().prototype.unstack=function(n){return this.throwIfDisposed(),yn(this,n)};W().prototype.where=function(n,t){return this.throwIfDisposed(),Oe(n,this,t)};W().prototype.zerosLike=function(){return this.throwIfDisposed(),Ct(this)};let sh;function de(){return sh==null&&(sh=By().epsilon()),sh}function zK(n){sh=n}function En(){return"channelsLast"}class Yn extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Yn.prototype)}}class bn extends Error{constructor(t){super(t);Object.setPrototypeOf(this,bn.prototype)}}class R extends Error{constructor(t){super(t);Object.setPrototypeOf(this,R.prototype)}}class gt extends Error{constructor(t){super(t);Object.setPrototypeOf(this,gt.prototype)}}class uf extends Error{constructor(t){super(t);Object.setPrototypeOf(this,uf.prototype)}}class Gb extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Gb.prototype)}}function Nr(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{let e=new Array(t);return e.fill(n),e}}function cn(n,t){if(!n)throw new uf(t)}function Hb(n,t){let e=0;for(let s of n)s===t&&e++;return e}function Be(n){return n.length===1?n[0]:n}function Mt(n){return Array.isArray(n)?n:[n]}function MK(n){let t=Mt(n),e="";for(let s of t){if(s.id==null)throw new R(`Object ${s} passed to objectListUid without an id`);e!==""&&(e=e+", "),e=`${e}${Math.abs(s.id)}`}return e}function fs(n){let e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function kr(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let xn={};function hf(n){if(n==null)return null;let t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function df(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>df(t));else{let t=Object.keys(n);for(let e of t){let s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:df(s))}}}function wl(n,t={},e={},s="object",r=!1){if(typeof n=="string"){let o=n,a;if(o in e)a=e[o];else if(o in xn)a=xn[o];else if(a=t[o],a==null)throw new R(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let o=n;if(o.className==null||o.config==null)throw new R(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);let a=o.className,i,l;if(a in e?[i,l]=e[a]:a in xn?[i,l]=xn.className:a in t&&([i,l]=t[a]),i==null)throw new R(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let c={};for(let p of Object.keys(xn))c[p]=xn[p];for(let p of Object.keys(e))c[p]=e[p];let u=o.config;u.customObjects=c;let h=Object.assign({},xn);for(let p of Object.keys(e))xn[p]=e[p];df(o.config);let d=l(i,o.config,e,r);return xn=Object.assign({},h),d}else{let c=Object.assign({},xn);for(let h of Object.keys(e))xn[h]=e[h];let u=new i(o.config);return xn=Object.assign({},c),u}}}function O2(n,t){return n<t?-1:n>t?1:0}function rh(n,t){return-1*O2(n,t)}function BK(n){switch(n){case"float32":return"float32";default:throw new R(`Invalid dtype: ${n}`)}}function VK(n,t){if(n==null||t==null)return n===t;if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(n[e]!==t[e])return!1;return!0}function Os(n){if(n==null)return n;let t=[];for(let e of n)t.indexOf(e)===-1&&t.push(e);return t}function L2(n){if(n==null)throw new R(`Invalid value in obj: ${JSON.stringify(n)}`);for(let t in n)if(n.hasOwnProperty(t))return!1;return!0}function Ir(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new R(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function pf(n,t,e=0,s=Infinity){return cn(e>=0),cn(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function $e(n,t){Array.isArray(n)?(N(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>$e(e,`element ${s+1} of ${t}`))):N(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${jb(n)}.`)}function jb(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>jb(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function P2(n,t){let e=Se(),s;return(...o)=>{let a=Se();return a-e<t||(e=a,s=n(...o)),s}}function qb(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}function WK(...n){cn(n.length>0,"arrayOfValues is empty");for(let t of n)cn(Array.isArray(t),"one of the values is not an array"),cn(t.length>0,"one of the values is empty");return n.reduce((t,e)=>t.length===0?e.map(s=>[s]):e.map(s=>t.map(r=>[...r,s])).reduce((s,r)=>s.concat(r),[]),[])}function ff(n,t){return O(()=>Ae(ht(_(n,n),t,!0)))}class $l extends dr{getConfig(){return{}}}class mf extends $l{constructor(t){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return O(()=>{let e=ff(t,this.axis),s=Me(e,0,this.maxValue);return _(t,dt(s,Z(de(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}mf.className="MaxNorm",X(mf);class gf extends $l{constructor(t){super();this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return O(()=>dt(t,Z(de(),ff(t,this.axis))))}getConfig(){return{axis:this.axis}}}gf.className="UnitNorm",X(gf);class yf extends $l{apply(t){return Xn(t)}}yf.className="NonNeg",X(yf);class bf extends $l{constructor(t){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return O(()=>{let e=ff(t,this.axis),s=Z(_(this.rate,Me(e,this.minValue,this.maxValue)),_(1-this.rate,e));return _(t,dt(s,Z(de(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}bf.className="MinMaxNorm",X(bf);let Kb={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function pe(n){return hf(n)}function Xb(n,t={}){return wl(n,rn.getMap().classNameMap,t,"constraint")}function fe(n){if(n==null)return null;if(typeof n=="string"){let e={className:n in Kb?Kb[n]:n,config:{}};return Xb(e)}else return n instanceof $l?n:Xb(n)}function z2(n){return new mf(n)}function M2(n){return new gf(n)}function B2(){return new yf}function V2(n){return new bf(n)}var W2=Object.freeze({__proto__:null,maxNorm:z2,unitNorm:M2,nonNeg:B2,minMaxNorm:V2});let U2=["channelsFirst","channelsLast"],G2=["nearest","bilinear"],H2=["valid","same","causal"],j2=["max","avg"],q2=["sum","mul","concat","ave"],UK=["temporal"];let aa=new Map;function Ht(n){Ir(U2,"DataFormat",n)}function K2(n){Ir(G2,"InterpolationFormat",n)}function un(n){Ir(H2,"PaddingMode",n)}function Yb(n){Ir(j2,"PoolMode",n)}let vl=[],Jb="/";function Sr(n,t){vl.push(n);try{let e=t();return vl.pop(),e}catch(e){throw vl.pop(),e}}function X2(){return vl.length===0?"":vl.join(Jb)+Jb}function Zb(n){if(!tx(n))throw new Error("Not a valid tensor name: '"+n+"'");return X2()+n}function Qb(n){if(!tx(n))throw new Error("Not a valid tensor name: '"+n+"'");aa.has(n)||aa.set(n,0);let t=aa.get(n);if(aa.set(n,aa.get(n)+1),t>0){let e=`${n}_${t}`;return aa.set(e,1),e}else return n}let Y2=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function tx(n){return!!n.match(Y2)}function J2(n){return n===parseInt(n.toString(),10)}function Ls(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function oh(n){return n=Array.isArray(n)?new Float32Array(n):n,Je(n)}function ia(n){return Jo(oh(n)).dataSync()[0]}function Ps(n){return ln(oh(n)).dataSync()[0]}function Z2(n){return ht(oh(n)).dataSync()[0]}function Q2(n){return Z2(n)/n.length}function GK(n){let t=at(oh(n),ut(Q2(n)));return ht(_(t,t)).dataSync()[0]/n.length}function HK(n){let t=n.slice().sort((r,o)=>r-o),e=Math.floor((t.length-1)/2),s=Math.ceil((t.length-1)/2);return e===s?t[e]:(t[e]+t[s])/2}function An(n,t){if(t<n)throw new R(`end (${t}) < begin (${n}) is forbidden.`);let e=[];for(let s=n;s<t;++s)e.push(s);return e}let ex="webgl";function jK(n){My(n),ex=n}function qK(){return ex}function KK(){return!1}function XK(n){let t=n.shape;return t.length>0?t.reduce((e,s)=>e*s):1}function Cl(n,t){return n.asType(t)}function Nl(n,t=-1){let e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),n.reshape(e)}function tA(n,t){return O(()=>{if(n.shape.length!==2)throw new R(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);let e=Nl(n,1);return $f(e,[1,t,1])})}function eA(n){let t=[Ls(n.shape)];return n.reshape(t)}function nA(n){if(n.rank<=1)throw new R(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);let t=[n.shape[0],Ls(n.shape,1)];return n.reshape(t)}function Tr(n,t,e){return O(()=>{switch(n.rank){case 1:return zu(n,t,e);case 2:return Pp(n,[t,0],[e,n.shape[1]]);case 3:return Mu(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return al(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return St(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return St(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new R(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function xf(n,t,e){return O(()=>{switch(n.rank){case 1:return zu(n,t,e);case 2:return Pp(n,[0,t],[n.shape[0],e]);case 3:return Mu(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return al(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new R(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function ah(n,t,e,s){return O(()=>{switch(n.rank){case 1:return zu(n,t,e);case 2:switch(s){case 1:return Tr(n,t,e);case 2:return xf(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Tr(n,t,e);case 2:return Mu(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return xf(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Tr(n,t,e);case 2:return al(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return al(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return xf(n,t,e);default:throw new R(`The axis is not within the rank of the tensor ${s}`)}default:throw new R(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function wf(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),ee(n,t)}function nx(n,t){switch(n.rank){case 1:return jy([n,t]);case 2:return qy([n,t],0);case 3:return Ky([n,t],0);case 4:return Xy([n,t],0);default:throw new R(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function $f(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new R(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Ds(n,t)}function ih(n,t=0,e=1,s,r){return Rp(n,t,e,s,r)}function Jn(n,t,e,s){if(n.rank<2||t.rank<2)throw new gt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=n.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(r!==o)throw new gt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return Xu({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?vf(n.rank,s,En()):null,activation:e});{let r=n.shape.slice(),o=r.pop();n=n.reshape([-1,o]);let a=t.shape.slice(),i=a.pop(),l=a.pop(),c=[...a,i],u=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=t.transpose(u).reshape([l,-1]);let h=[...r,...c];return Xu({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?vf(n.rank,s,En()):null,activation:e}).reshape(h)}}function YK(n){return O(()=>{let t=Ct(n),e=Le(n);return Oe(cs(n,t),t,Oe(an(n,Ct(n)),e,_(-1,e)))})}function JK(n,t){return O(()=>{if(n.rank!==1)throw new Error("Only 1D one-hot tensors are supported in the deeplearn backend, at present.");return n=n.toInt(),hr(n,t).toFloat()})}function sx(n,t,e){return O(()=>(Array.isArray(t)?t=Je(t,"int32"):t=t.toInt(),mr(n,t,e)))}function kl(n){return _(n,n)}function ZK(n,t){return O(()=>{if(typeof t=="number"&&(t=ut(Math.round(t),"int32")),t.dtype!=="int32")throw new gt(`Non-int32 dtype (${t.dtype}) is not supported by pow() yet`);return Kn(n,t)})}function vf(n,t,e){let s=t.shape;if(t.rank!==1&&t.rank!==n)throw new R(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?t.reshape([1,s[0],1,1,1]):t.reshape([1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?t.reshape([1,1,1,1,s[0]]):t.reshape([1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?t.reshape([1,s[0],1,1]):t.reshape([1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?t.reshape([1,1,1,s[0]]):t.reshape([1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?t.reshape([1,s[0],1]):t.reshape([1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?t.reshape([1,1,s[0]]):t.reshape([1].concat(s))}else if(n<3)return t;throw new R(`Unsupported input rank by biasAdd: ${t.rank}`)}function Zn(n,t,e){return O(()=>(e==null&&(e=En()),Ht(e),n.add(vf(n.rank,t,e))))}function sA(n,t=1){if(t!==1)throw new gt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return qo(n)}function rA(n){return O(()=>dt(n,ue(n).add(1)))}function rx(n,t,e,s){return O(()=>fb(n,t,e,s))}function oA(n){return O(()=>{let t=Z(.5,_(.2,n));return Me(t,0,1)})}function Il(n,t,e=!1){return e?n():t()}let aA=["fanIn","fanOut","fanAvg"],iA=["normal","uniform","truncatedNormal"],QK=["Zeros","Ones","Constant","RandomNormal","RandomUniform","TruncatedNormal","VarianceScaling","Orthogonal","Identity"];function lA(n){Ir(aA,"FanMode",n)}function cA(n){Ir(iA,"Distribution",n)}class wn extends dr{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Cf extends wn{apply(t,e){return re(t,e)}}Cf.className="Zeros",X(Cf);class lh extends wn{apply(t,e){return Tn(t,e)}}lh.className="Ones",X(lh);class Nf extends wn{constructor(t){super();if(typeof t!="object")throw new R(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new R(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return O(()=>_(ut(this.value),Tn(t,e)))}getConfig(){return{value:this.value}}}Nf.className="Constant",X(Nf);class kf extends wn{constructor(t){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return wr(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}kf.className="RandomUniform",X(kf);class If extends wn{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new gt(`randomNormal does not support dType ${e}.`);return ih(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}If.className="RandomNormal",X(If);class Sf extends wn{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new gt(`truncatedNormal does not support dType ${e}.`);return ul(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Sf.className="TruncatedNormal",X(Sf);class Tf extends wn{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,e){return O(()=>{if(t.length!==2||t[0]!==t[1])throw new R("Identity matrix initializer can only be used for 2D square matrices.");return _(this.gain,Cu(t[0]))})}getConfig(){return{gain:this.gain}}}Tf.className="Identity",X(Tf);function uA(n,t="channelsLast"){let e,s;if(Ht(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){let r=Ls(n,2);e=n[1]*r,s=n[0]*r}else if(t==="channelsLast"){let r=Ls(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{let r=Ls(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}class Ve extends wn{constructor(t){super();if(t.scale<0)throw new R(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,lA(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,cA(this.distribution),this.seed=t.seed}apply(t,e){let s=uA(t),r=s[0],o=s[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,o):a/=Math.max(1,(r+o)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new gt(`${this.getClassName()} does not support dType ${e}.`);return ul(t,0,i,e,this.seed)}else{let i=Math.sqrt(3*a);return wr(t,-i,i,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ve.className="VarianceScaling",X(Ve);class ch extends Ve{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}ch.className="GlorotUniform",X(ch);class uh extends Ve{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}uh.className="GlorotNormal",X(uh);class hh extends Ve{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}hh.className="HeNormal",X(hh);class dh extends Ve{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}dh.className="HeUniform",X(dh);class ph extends Ve{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}ph.className="LeCunNormal",X(ph);class fh extends Ve{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ve.className}}fh.className="LeCunNormal",X(fh);class Ef extends wn{constructor(t){super();if(this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new gt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return O(()=>{if(t.length<2)throw new gt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let s=t[0]>t[1]?[t[1],t[0]]:t,r=ih(s,0,1,"float32"),o=kb.gramSchmidt(r);return t[0]>t[1]&&(o=o.transpose()),_(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Ef.className="Orthogonal",X(Ef);let ox={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ax(n,t={}){return wl(n,rn.getMap().classNameMap,t,"initializer")}function Qt(n){return hf(n)}function jt(n){if(typeof n=="string"){let t=n in ox?ox[n]:n;if(t==="GlorotNormal")return new uh;if(t==="GlorotUniform")return new ch;if(t==="HeNormal")return new hh;if(t==="HeUniform")return new dh;if(t==="LeCunNormal")return new ph;if(t==="LeCunUniform")return new fh;{let e={};return e.className=t,e.config={},ax(e)}}else return n instanceof wn?n:ax(n)}function hA(){return new Cf}function dA(){return new lh}function pA(n){return new Nf(n)}function fA(n){return new kf(n)}function mA(n){return new If(n)}function gA(n){return new Sf(n)}function yA(n){return new Tf(n)}function bA(n){return new Ve(n)}function xA(n){return new ch(n)}function wA(n){return new uh(n)}function $A(n){return new hh(n)}function vA(n){return new dh(n)}function CA(n){return new ph(n)}function NA(n){return new fh(n)}function kA(n){return new Ef(n)}var IA=Object.freeze({__proto__:null,zeros:hA,ones:dA,constant:pA,randomUniform:fA,randomNormal:mA,truncatedNormal:gA,identity:yA,varianceScaling:bA,glorotUniform:xA,glorotNormal:wA,heNormal:$A,heUniform:vA,leCunNormal:CA,leCunUniform:NA,orthogonal:kA});let SA=0;function ix(){return SA++}let mh={};function gh(n=""){return n in mh||(mh[n]=0),mh[n]+=1,n+mh[n].toString()}function Af(n){return Array.isArray(n)&&Array.isArray(n[0])}function yh(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function wt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new R(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Lt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new R(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function bh(n){let t=0;for(let e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,r)=>s*r);return t}let lx="Variable";class Dn{constructor(t,e="float32",s=lx,r=!0,o=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=ix(),s=s==null?lx:s,this.originalName=Zb(s),this.name=Qb(this.originalName),this.trainable_=r,this.constraint=o,this.val=ub(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),TA(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function TA(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function tX(n,t,e,s){return new Dn(n,t,e,!0,s)}function eX(n,t,e){return new Dn(re(n),t,e)}function nX(n,t,e){return new Dn(Ct(n),t,e)}function sX(n,t,e){let s=Tn(n);return new Dn(s,t,e)}function rX(n,t,e){let s=Le(n);return new Dn(s,t,e)}function oX(n,t,e){return new Dn(Cu(n),t,e)}function aX(n,t,e,s,r,o="randomUniform"){return new Dn(wr(n,t,e,s),s,o)}function iX(n,t=0,e=1,s,r,o="truncatedNormal"){if(s=s||"float32",s!=="float32"&&s!=="int32")throw new gt(`randomNormal does not support dType ${s}.`);return new Dn(ul(n,t,e,s,r),s,o)}function lX(n,t=0,e=1,s,r,o="randomNormal"){if(s=s||"float32",s!=="float32"&&s!=="int32")throw new gt(`randomNormalVariable does not support dType ${s}.`);return new Dn(Rp(n,t,e,s,r),s,o)}function cX(n,t){return n.write(t)}function uX(n,t){return n.write(Z(n.read(),t))}function hX(n,t){return n.write(at(n.read(),t))}function Df(n){return n.map(t=>t.read())}function Rf(n){n.forEach(t=>{t[0].write(t[1])})}function dX(n,t){let e=t.map(r=>r.read()),s=Np(n,e);return t.map(r=>s.grads[r.name])}class ve{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Rn{constructor(t,e,s,r,o,a,i){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=i,this.id=ix(),a!=null&&(this.originalName=Zb(a),this.name=Qb(this.originalName)),this.rank=e.length}}let EA=0;class xh{constructor(t,e){this.callArgs=e,this.id=EA++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let s of t.inboundLayers)s!=null&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let AA=0;class Tt extends dr{constructor(t={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=AA++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let s=this.getClassName();e=fs(s)+"_"+gh(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let o=null;t.batchSize!=null&&(o=t.batchSize),s=[o].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new bn(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new R(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Be(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Be(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Yn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Yn(`Layer ${this.name} is not connected, no input to return.`);return Be(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Yn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Yn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Be(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Mt(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=Mt(this.inputSpec);if(t.length!==e.length)throw new R(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){let r=t[s],o=e[s];if(o==null)continue;let a=r.rank;if(o.ndim!=null&&a!==o.ndim)throw new R(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new R(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new R(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&r.dtype!==o.dtype)throw new R(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);if(o.axes){let i=r.shape;for(let l in o.axes){let c=Number(l),u=o.axes[l],h=c>=0?i[c]:i[i.length+c];if(u!=null&&[u,null].indexOf(h)===-1)throw new R(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${i}.`)}}if(o.shape!=null)for(let i=0;i<o.shape.length;++i){let l=o.shape[i],c=r.shape[i];if(l!=null&&c!=null&&l!==c)throw new R(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let s=Mt(t),r=!0;for(let a of s)if(!(a instanceof Rn)){r=!1;break}let o=!0;for(let a of s)if(a instanceof Rn){o=!1;break}if(r===o)throw new R("Arguments to apply() must be all SymbolicTensors or all Tensors");return Sr(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let a=[];for(let i of Mt(t))a.push(i.shape);this.build(Be(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let a=this.call(t,e),i=Mt(a),l=[];for(let c of i)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(a=Be(l),this.activityRegularizer!=null)throw new gt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=DA(t),i=this.computeOutputShape(a),l,c=RA(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?l=i.map((u,h)=>new Rn(c,u,this,Mt(t),e,this.name,h)):l=new Rn(c,i,this,Mt(t),e,this.name),this.addInboundNode(t,l,null,null,a,i,e),this._refCount++,this.activityRegularizer!=null)throw new gt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Yn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Yn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new bn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return bh(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Df(t?this.trainableWeights:this.weights)}setWeights(t){O(()=>{let e=this.weights;if(e.length!==t.length)throw new R(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let s=[],r=Df(e);for(let o=0;o<r.length;++o){let a=r[o],i=e[o],l=t[o];if(!At(a.shape,l.shape))throw new R(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([i,l])}Rf(s)})}addWeight(t,e,s,r,o,a,i){if(this._addedWeightNames.indexOf(t)!==-1)throw new R(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=jt("zeros"));let l=r.apply(e,s),c=new Dn(l,s,t,a,i);return l.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Mt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,s,r,o,a,i=null){let l=Mt(t);e=Mt(e),s=Mt(s),r=Mt(r),o=yh(o),a=yh(a);let c=[],u=[],h=[];for(let d of l)c.push(d.sourceLayer),u.push(d.nodeIndex),h.push(d.tensorIndex);new xh({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:a},i);for(let d=0;d<e.length;d++)e[d].sourceLayer=this,e[d].nodeIndex=this.inboundNodes.length-1,e[d].tensorIndex=d}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount==0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function DA(n){n=Mt(n);let t=[];for(let e of n)t.push(e.shape);return Be(t)}function RA(n){return"float32"}function cx(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{let s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{let r=[];for(let o=0;o<s.inboundLayers.length;o++){let a=s.inputTensors[o],i=s.inboundLayers[o],l=s.nodeIndices[o],c=cx(a,i,l);for(let u of c)r.indexOf(u)===-1&&r.push(u)}return r}}}class la extends Tt{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:gh("input").toString()});if(t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new R("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new R("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new R("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];let r=new Rn(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new xh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new R(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}la.className="InputLayer",X(la);function ux(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new R("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new la({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}async function zs(n){if(n==null)return;let t=[],e=[],s=[];for(let r in n){let o=n[r];if(typeof o!="number"){let a=o;t.push(a.data()),e.push(r),s.push(a)}}if(t.length>0){let r=await Promise.all(t);for(let o=0;o<r.length;++o)n[e[o]]=r[o][0];bt(s)}}function hx(n){if(n!=null)for(let t in n){let e=n[t];typeof e!="number"&&e.dispose()}}var dx;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(dx||(dx={}));let FA=125;class ca{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class px{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}}class _A extends ca{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let s=e.size==null?0:e.size;this.seen+=s;for(let r in e){let o=e[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let i=O(()=>Z(this.totals[r],_(o,s)));this.totals[r]=i,a!=null&&a.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:O(()=>{let r=_(dt(1,this.seen),this.totals[s]);e[s]=r,this.totals[s].dispose(),be(e[s])}))}}class fx extends ca{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){let t=[],e=[],s=[];for(let o in this.history){let a=this.history[o];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let l=a[i];t.push(l.data()),e.push(o),s.push(i)}}let r=await Promise.all(t);for(let o=0;o<r.length;++o)this.history[e[o]][s[o]].dispose(),this.history[e[o]][s[o]]=r[o][0]}}class mx extends ca{constructor(t,e){super();if(this.currentEpoch=0,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=FA),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");oc(this.yieldEvery)&&(this.maybeWait=P2(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){let r=[];this.yield!=null&&(await zs(s),r.push(this.yield(t,e,s))),r.push(Qu()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await zs(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let s=[];this.epochEnd!=null&&(await zs(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(Qu()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await zs(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let s=[];this.batchEnd!=null&&(await zs(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(Qu()):oc(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await zs(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await zs(t),await this.trainEnd(t))}}function gx(n,t){return n==null&&(n={}),n instanceof ca?[n]:Array.isArray(n)&&n[0]instanceof ca?n:Mt(n).map(s=>new mx(s,t))}class hn{constructor(){}static registerCallbackConstructor(t,e){N(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),hn.checkForDuplicate(e),hn.constructors[t]==null&&(hn.constructors[t]=[]),hn.constructors[t].push(e)}static checkForDuplicate(t){for(let e in hn.constructors)hn.constructors[+e].forEach(r=>{if(r===t)throw new R("Duplicate callback constructor.")})}static clear(){hn.constructors={}}static createCallbacks(t){let e=[];for(let s in hn.constructors){let r=+s;t>=r&&e.push(...hn.constructors[r])}return e.map(s=>new s)}}hn.constructors={};function yx(n,t,e,s,r,o,a,i,l){let c=new fx,u=[new _A,...hn.createCallbacks(t)];n!=null&&u.push(...n),u.push(c);let h=new px(u);return h.setParams({epochs:e,initialEpoch:s,samples:r,steps:o,batchSize:a,verbose:t,doValidation:i,metrics:l}),{callbackList:h,history:c}}function Fn(n,t={},e=!1){return wl(n,rn.getMap().classNameMap,t,"layer",e)}function wh(n,t){return O(()=>{n.dtype!=="float32"&&(n=n.asType("float32"));let e=ht(kl(n),t,!0),s=Qi(e.shape,de()),r=Ae(jn(e,s));return dt(n,r)})}function ms(n,t){return O(()=>Zt(kl(at(t,n)),-1))}function ua(n,t){return O(()=>Zt(ue(at(t,n)),-1))}function Ms(n,t){return O(()=>{let e=at(n,t),s=Me(ue(n),de(),Number.MAX_VALUE),r=ue(dt(e,s));return _(100,Zt(r,-1))})}function Ff(n,t){return O(()=>{let e=Me(t,de(),Number.MAX_VALUE),s=qe(Z(1,e)),r=Me(n,de(),Number.MAX_VALUE),o=qe(Z(1,r));return Zt(kl(at(s,o)),-1)})}function OA(n,t){return O(()=>{let e=jn(0,at(1,_(n,t)));return Zt(kl(e),-1)})}function LA(n,t){return O(()=>{let e=jn(0,at(1,_(n,t)));return Zt(e,-1)})}function PA(n,t){return O(()=>{let e=ht(_(n,t),-1),s=ln(_(at(1,n),t),-1);return jn(0,Z(1,at(s,e)))})}function zA(n,t){return O(()=>{let e=Math.log(2),s=at(t,n),r=at(Z(s,Xo(_(-2,s))),e);return Zt(r,-1)})}function Sl(n,t,e=!1){return O(()=>{if(e)t=il(t);else{let s=ht(t,t.shape.length-1,!0);t=dt(t,s)}return t=Me(t,de(),1-de()),Jt(ht(_(n.toFloat(),qe(t)),t.shape.length-1))})}function $h(n,t,e=!1){return O(()=>{let s=Ko(eA(n)).toInt();t=Me(t,de(),1-de());let r=t.shape,o=hr(s,r[r.length-1]).reshape(r);return Sl(o,t,e)})}function MA(n,t){if(!At(n.shape,t.shape))throw new R(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return O(()=>{let e=t.relu(),s=t.abs().neg();return e.sub(t.mul(n)).add(s.exp().log1p())})}function vh(n,t){return O(()=>{let e;return e=Me(t,de(),1-de()),e=qe(dt(e,at(1,e))),Zt(MA(n,e),-1)})}function _f(n,t){return O(()=>{let e=Me(n,de(),1),s=Me(t,de(),1);return ht(_(n,qe(dt(e,s))),-1)})}function BA(n,t){return O(()=>{let e=qe(Z(de(),t));return Zt(at(t,_(n,e)),-1)})}function Ch(n,t){return O(()=>{let e=wh(n,-1),s=wh(t,-1),r=_(e,s);return Jt(ht(r,-1))})}let pX=ms,fX=ms,mX=ua,gX=ua,yX=Ms,bX=Ms,xX=Ff,wX=Ff,$X=_f,vX=_f,CX=Ch,Nh={meanSquaredError:ms,meanAbsoluteError:ua,meanAbsolutePercentageError:Ms,meanSquaredLogarithmicError:Ff,squaredHinge:OA,hinge:LA,categoricalHinge:PA,logcosh:zA,categoricalCrossentropy:Sl,sparseCategoricalCrossentropy:$h,binaryCrossentropy:vh,kullbackLeiblerDivergence:_f,poisson:BA,cosineProximity:Ch};function Of(n){if(typeof n=="string"){if(n in Nh)return Nh[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new R(t)}else return n}function Lf(n,t){return O(()=>{let e=_(.5,Le(t)),s=Cl(an(t,e),n.dtype);return Zt(cs(n,s),-1)})}function Pf(n,t){return O(()=>Cl(cs(ji(n,-1),ji(t,-1)),"float32"))}function bx(n,t){return O(()=>gn(n.equal(1),t.equal(1)).sum().cast("float32"))}function VA(n,t){return O(()=>gn(n.equal(1),t.equal(0)).sum().cast("float32"))}function WA(n,t){return O(()=>gn(n.equal(0),t.equal(1)).sum().cast("float32"))}function xx(n,t){return O(()=>{let e=bx(n,t),s=WA(n,t),r=e.add(s);return Oe(an(r,0),e.div(r),0).cast("float32")})}function UA(n,t){return O(()=>{let e=bx(n,t),s=VA(n,t),r=e.add(s);return Oe(an(r,0),e.div(r),0).cast("float32")})}function wx(n,t){return vh(n,t)}function $x(n,t){return n.rank===t.rank&&(n=n.squeeze([n.rank-1])),t=t.argMax(-1),t.dtype!==n.dtype&&(t=t.asType(n.dtype)),cs(n,t).asType("float32")}function NX(n,t){throw new gt}function kX(n,t){throw new gt}let GA=ms,HA=ms,jA=ua,qA=ua,KA=Ms,XA=Ms,zf=Sl,YA=Ch,vx=$h,kh={binaryAccuracy:Lf,categoricalAccuracy:Pf,precision:xx,categoricalCrossentropy:zf,sparseCategoricalCrossentropy:vx,mse:GA,MSE:HA,mae:jA,MAE:qA,mape:KA,MAPE:XA,cosine:YA};function JA(n){if(typeof n=="string"&&n in kh)return kh[n];if(typeof n!="string"&&n!=null)return n;throw new R(`Unknown metric ${n}`)}function Ih(n){if(cn(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(let e of Object.keys(Nh))if(Nh[e]===n){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(kh))if(kh[e]===n){t=e;break}return t!==void 0?t:n.name}}function ZA(n){let t={Adagrad:()=>Cr.adagrad(.01),Adadelta:()=>Cr.adadelta(1,.95,de()),Adam:()=>Cr.adam(.001,.9,.999,de()),Adamax:()=>Cr.adamax(.002,.9,.999,de(),0),RMSProp:()=>Cr.rmsprop(.001,.9,0,de()),SGD:()=>Cr.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new R(`Unknown Optimizer ${n}`)}let Cx=1*1024*1024;function Nx(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Mf(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let s=JSON.stringify(n);s.length>Cx&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Cx}.`)}}function Mf(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){let t=Object.keys(n);for(let e of t)if(typeof e!="string"||!Mf(n[e]))return!1;return!0}else if(Array.isArray(n)){for(let t of n)if(!Mf(t))return!1;return!0}else return!1;else{let t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function QA(n,t,e,s=console.log){let r=eD(n),o=["Layer (type)","Output shape","Param #"];r?(t=t||65,e=e||[.45,.85,1]):(t=t||98,e=e||[.33,.55,.67,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u)));let a;if(!r){o.push("Receives inputs"),a=[];for(let u in n.nodesByDepth)a.push(...n.nodesByDepth[u])}s("_".repeat(t)),Sh(o,e,s),s("=".repeat(t));let i=n.layers;for(let u=0;u<i.length;++u)r?nD(i[u],e,s):sD(i[u],e,a,s),s((u===i.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();let l=tD(n),c=bh(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function tD(n){let t;return n.collectedTrainableWeights!=null?t=bh(n.collectedTrainableWeights):t=bh(n.trainableWeights),t}function eD(n){let t=!0,e=[],s=[];for(let r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(let r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(let r of n.layers){let o=!1;for(let a of r.inboundNodes)if(s.indexOf(a)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function Sh(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function nD(n,t,e){let s;try{s=JSON.stringify(n.outputShape)}catch(i){s="multiple"}let r=n.name,o=n.getClassName(),a=[`${r} (${o})`,s,n.countParams().toString()];Sh(a,t,e)}function sD(n,t,e,s){let r;try{r=JSON.stringify(n.outputShape)}catch(u){r="multiple"}let o=[];for(let u of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(u)===-1))for(let h=0;h<u.inboundLayers.length;++h){let d=u.inboundLayers[h].name,p=u.nodeIndices[h],f=u.tensorIndices[h];o.push(`${d}[${p}][${f}]`)}let a=n.name,i=n.getClassName(),l=o.length===0?"":o[0],c=[`${a} (${i})`,r,n.countParams().toString(),l];Sh(c,t,s);for(let u=1;u<o.length;++u)Sh(["","","",o[u]],t,s)}function kx(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function Tl(n,t){if(n===null)return null;if(typeof n=="string")return kr(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],s=n.length;for(let r=0;r<s;++r){let o=n[r];kx(t,r,o)?e.push(o):e.push(Tl(o,t))}return e}else{let e={};for(let s of Object.keys(n)){let r=n[s];if(s==="name"&&typeof r=="string")e[s]=r;else{let o=kr(s);e[o]=Tl(r,o)}}return e}}function Bf(n,t){if(n==null)return null;if(typeof n=="string")return fs(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],s=n.length;for(let r=0;r<s;++r){let o=n[r];kx(t,r,o)?e.push(o):e.push(Bf(o,t))}return e}else{let e={};for(let s of Object.keys(n)){let r=n[s],o=fs(s);(s==="name"||s==="className")&&typeof r=="string"?e[o]=r:e[o]=Bf(r,s)}return e}}let Th="3.2.0";function rD(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return rt(t,n.dtype)}catch(e){throw new R(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Bs{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Bs)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=rD(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new R(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Rn){if(this.id2Value[t.id]==null)throw new R(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new R(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Rn){if(this.id2Value[t.id]==null)throw new R(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new R(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&bt(this.id2Mask)}}let Vf={},Ix={};function El(n,t,e,s){let r=e==null?!1:e.training,o=Array.isArray(n),a=o?n:[n],i=a.map(f=>f.name),l=[],c=t.names();for(let f of i)c.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);s!=null&&(s.maxNumTensors=-Infinity,s.minNumTensors=Infinity);let u=i.join(",")+"|"+t.names().join(","),h,d;if(Vf[u]==null){let f=oD(a,t);h=f.sorted,d=f.recipientCounts,Vf[u]=h,Ix[u]=d}h=Vf[u],d={},r||Object.assign(d,Ix[u]);let p=new Bs(t);for(let f=0;f<h.length;++f){if(s!=null){let E=mu().numTensors;E>s.maxNumTensors&&(s.maxNumTensors=E),E<s.minNumTensors&&(s.minNumTensors=E)}let m=h[f],g=m.sourceLayer;if(g instanceof la)continue;let y=[],b=[],C=[],w=!1;for(let E of m.inputs){let F=p.getValue(E),P=p.getMask(E);y.push(F),b.push(P),P!=null&&(w=!0),r||(d[E.name]--,d[E.name]===0&&!t.hasKey(E)&&i.indexOf(E.name)===-1&&!F.isDisposed&&E.sourceLayer.stateful!==!0&&C.push(F))}w&&(e=e||{},e.mask=b[0]);let v=Mt(g.apply(y,e)),I=null;g.supportsMasking&&(I=g.computeMask(y,b));let k=iD(m),T=Array.isArray(k)?k:[k];for(let E=0;E<T.length;++E){p.hasKey(T[E])||p.add(T[E],v[E],Array.isArray(I)?I[0]:I);let F=i.indexOf(T[E].name);F!==-1&&(l[F]=v[E])}r||bt(C)}return p.disposeMasks(),o?l:l[0]}function oD(n,t){N(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){let r=Sx(n[0],t);e=r.sorted,s=r.recipientMap}else{let r=new Set;for(let o of n){let{sorted:a,recipientMap:i}=Sx(o,t);for(let l of a)r.has(l.name)||(e.push(l),r.add(l.name));for(let l in i)s[l]==null&&(s[l]=new Set),i[l].forEach(c=>s[l].add(c))}}return{sorted:e,recipientCounts:aD(s)}}function aD(n){let t={};for(let e in n)t[e]=n[e].size;return t}function Sx(n,t){let e=new Set,s=[],r={};for(let i of t.names())e.add(i);let o=[],a=[];for(o.push(n);o.length>0;){let i=o[o.length-1];if(e.has(i.name)){o.pop();continue}let l=a[a.length-1]===o.length-1;if(i.inputs.length===0||l)o.pop(),s.push(i),e.add(i.name),l&&a.pop();else{a.push(o.length-1);for(let c of i.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(i.name),!e.has(c.name)&&o.push(c)}}return{sorted:s,recipientMap:r}}function iD(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(let r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}class _n extends Tt{constructor(t){super({});if(this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=gh(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Os(this.inputs).length!==this.inputs.length)throw new R(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Os(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let C=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(v)}for(let b of this.inputs){let C=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;cn(w===0,"input layer has >1 nodes"),cn(v===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let C=this.inputLayers[b];if(!(C instanceof la))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},s={},r={},o={},a={},i=[],l=(b,C,w,v,I,k)=>{(v==null||I==null||k==null)&&(v=b.sourceLayer,I=b.nodeIndex,k=b.tensorIndex);let T=v.inboundNodes[I];if(w.indexOf(T)!==-1)throw new bn(`The tensor ${b.name} at layer "${v.name}" is part of a cycle.`);if(C.indexOf(T)!==-1)return;this.containerNodes.add(_n.nodeKey(v,I)),v.id in a||(a[v.id]=Object.keys(a).length),w.indexOf(T)===-1&&w.push(T);let E=T.inboundLayers.length;for(let F=0;F<E;F++){let P=T.inputTensors[F],M=T.inboundLayers[F],z=T.nodeIndices[F],U=T.tensorIndices[F];l(P,C,w,M,z,U)}for(C.push(T);w.indexOf(T)>=0;)w.splice(w.indexOf(T),1);i.push(T)},c=[],u=[];for(let b of this.outputs)l(b,c,u);let h=i.slice().reverse();for(let b of h){s[b.id]=b,b.id in e||(e[b.id]=0);let C=e[b.id],w=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];C=Math.max(C,w),r[b.outboundLayer.id]=C,o[b.outboundLayer.id]=b.outboundLayer,e[b.id]=C;for(let v=0;v<b.inboundLayers.length;v++){let I=b.inboundLayers[v],k=b.nodeIndices[v],T=I.inboundNodes[k],E=e[T.id]==null?0:e[T.id];e[T.id]=Math.max(C+1,E),s[T.id]=T}}let d={};for(let b in e){let C=e[b];C in d||(d[C]=[]),d[C].push(s[b])}let p={};for(let b in r){let C=r[b];C in p||(p[C]=[]),p[C].push(o[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(rh);this.layers=[];for(let b of f){let C=p[b];C.sort((w,v)=>{let I=a[w.id],k=a[v.id];return I<k?-1:I>k?1:0});for(let w of C)w instanceof _n&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(d).map(b=>parseInt(b,10)).sort(rh);let m=this.inputs.slice(),g=[];for(let b of f)for(let C of d[b]){let w=C.outboundLayer;if(w!=null){for(let v of C.inputTensors)if(m.indexOf(v)===-1)throw new bn(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(let v of C.outputTensors)m.push(v);g.push(w.name)}}this.nodesByDepth=d;let y=this.layers.map(b=>b.name);for(let b of y){let C=y.filter(w=>w===b).length;if(C!==1)throw new bn(`The name "${b}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new xh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new R("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let s={},r=0;for(let a of this.layers)for(let i of a.weights){if(s[i.originalName]!=null)throw new R(`Duplicate weight name: ${i.originalName}`);s[i.originalName]=i,r++}let o=[];for(let a in t){let i=a;if(s[a]==null){let l=a.split("/");i=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[i]!=null)o.push([s[i],t[a]]);else if(e)throw new R(`Provided weight data has no target variable: ${a}`);delete s[i]}if(e){let a=[];for(let i in s)a.push(i);if(a.length>0)throw new R(`${a.length} of ${r} weights are not set: ${a}`)}Rf(o)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Th}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let s=Bf(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return O(()=>{t=Mt(t);let s=new Bs;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return El(this.outputs,s,e)})}computeMask(t,e){return O(()=>{t=Mt(t);let s;return e==null?s=Nr(null,t.length):s=Mt(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){let e=yh(t);if(e.length!==this.inputLayers.length)throw new R(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let s={};for(let i=0;i<e.length;i++){let l=this.inputLayers[i],c=e[i],u=l.name+"_0_0";s[u]=c}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(rh);if(r.length>1)for(let i of r){let l=this.nodesByDepth[i];for(let c of l){let u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;let h=[];for(let m=0;m<c.inboundLayers.length;m++){let g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],C=`${g.name}_${y}_${b}`,w=s[C];h.push(w)}let d=u.computeOutputShape(Be(h)),p=yh(d),f=u.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){let g=`${u.name}_${f}_${m}`;s[g]=p[m]}}}let o=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let l=this.outputLayers[i],c=this.outputLayersNodeIndices[i],u=this.outputLayersTensorIndices[i],h=`${l.name}_${c}_${u}`;a.push(h)}for(let i=0;i<a.length;i++){let l=a[i];cn(l in s),o.push(s[l])}return Be(o)}runInternalGraph(t,e){e==null&&(e=Nr(null,t.length));let s={};for(let l=0;l<this.inputs.length;++l){let c=this.inputs[l],u=t[l],h=e[l];s[c.id]=[u,h]}let r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(rh);for(let l of r){let c=this.nodesByDepth[l];for(let u of c){let h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(let m of d)m.id in s&&f.push(s[m.id]);if(f.length===d.length){let m={},g,y,b,C;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){let[w,v]=f[0];m.mask==null&&(m.mask=v),b=Mt(h.call(w,m)),C=Mt(h.computeMask(w,v)),g=[w],y=[v]}else g=f.map(w=>w[0]),y=f.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Mt(h.call(g,m)),C=Mt(h.computeMask(g,y));if(h.activityRegularizer)throw new gt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){let v=p[w],I=b[w],k=C[w];s[v.id]=[I,k]}}}}let o=[],a=[],i=[];for(let l of this.outputs){cn(l.id in s,`Could not compute output ${l.name} : ${l.id}`);let[c,u]=s[l.id];i.push(c.shape),o.push(c),a.push(u)}return[o,a,i]}buildNodeConversionMap(t){let e={},s;for(let r of this.layers){s=r instanceof _n?1:0;for(let o=0;o<r.inboundNodes.length;o++){let a=_n.nodeKey(r,o);this.containerNodes.has(a)&&(e[a]=s,s+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new R(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new R("Provide either a layer name or layer index");for(let s of this.layers)if(s.name===t)return s;throw new R(`No such layer: ${t}`)}calculateLosses(){return O(()=>{let t=[];for(let e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){let r=_n.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(let a of this.layers){let i=a.getClassName(),l=a.getConfig(),c=[];for(let h=0;h<a.inboundNodes.length;h++){let d=a.inboundNodes[h],p=_n.nodeKey(a,h),f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch(m){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){let m=[];for(let g=0;g<d.inboundLayers.length;g++){let y=d.inboundLayers[g],b=d.nodeIndices[g],C=d.tensorIndices[g],w=_n.nodeKey(y,b),v=e[w];v==null&&(v=0),m.push([y.name,v,C,f])}c.push(m)}}}let u={};u.name=a.name,u.className=i,u.config=l,u.inboundNodes=c,s.push(u)}t.layers=s;let r=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],l=this.inputLayersNodeIndices[a],c=_n.nodeKey(i,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);let h=this.inputLayersTensorIndices[a];r.push([i.name,u,h])}t.inputLayers=r;let o=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=_n.nodeKey(i,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);let h=this.outputLayersTensorIndices[a];o.push([i.name,u,h])}return t.outputLayers=o,t}static fromConfig(t,e,s={},r=!1){let o={},a={};function i(g,y){g.name in a?a[g.name].push(y):a[g.name]=[y]}function l(g,y){let b=[],C;for(let w of y){let v=w[0],I=w[1],k=w[2];if(C=w[3]==null?{}:w[3],!(v in o)){i(g,y);return}let T=o[v];if(T.inboundNodes.length<=I){i(g,y);return}let E=T.inboundNodes[I];b.push(E.outputTensors[k])}b.length>0&&g.apply(Be(b),C)}function c(g){let y=g.name,b=Fn(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(r),o[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new R(`Corrupted configuration, expected array for nodeData: ${w}`);i(b,w)})}let u=e.name,h=e.layers;for(let g of h)c(g);for(;!L2(a);)for(let g of h){let y=o[g.name];if(y.name in a){let b=a[y.name];delete a[y.name];for(let C of b)l(y,C)}}let d=[],p=[],f=e.inputLayers;for(let g of f){let y=g[0],b=g[1],C=g[2];cn(y in o);let v=o[y].inboundNodes[b].outputTensors;d.push(v[C])}let m=e.outputLayers;for(let g of m){let y=g[0],b=g[1],C=g[2];cn(y in o);let v=o[y].inboundNodes[b].outputTensors;p.push(v[C])}return new t({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new R("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){O(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Tx(n,t,e){let s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){let r=[];return t.forEach(o=>{o in n?r.push(n[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function Ex(n,t){return Tx(n,t,"classWeight")}function IX(n,t){return Tx(n,t,"sampleWeight")}async function Ax(n,t,e,s){if(t!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let r=O(()=>{if(n.shape.length===1)return n.clone();if(n.shape.length===2)if(n.shape[1]>1){let i=1;return n.argMax(i)}else{if(n.shape[1]===1)return n.reshape([n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());bt(r);let a=[];return o.forEach(i=>{if(e[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(e[i])}),Je(a,"float32")}else return null}function lD(n,t){return _(n,t)}let cD=32;function Dx(n,t){let e,s,r=t;e=r.xs,s=r.ys,N(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let o=Rx("input",n.inputNames,e),a=Rx("output",n.outputNames,s),i=o[0].shape[0];N(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),N(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)N(o[l].shape[0]===i,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)N(a[l].shape[0]===i,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);return{xs:o,ys:a}}function Rx(n,t,e){if(e instanceof Dt)return[e];if(Array.isArray(e))return N(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{let s=[];for(let r of t){if(e[r]==null)throw new R(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function uD(n){if(n.length===3)throw new gt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function hD(n,t,e){let s=e.batchesPerEpoch!=null;if(N(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),N(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),N(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),N(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),N(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{let r=e.validationData!=null,o,a;if(r)if(Fx(e.validationData))N(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=uD(e.validationData);o=g.xs,a=g.ys}let i=n.makeTrainFunction(),l=n.getDedupedMetricsNames(),c;r?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();let u=gx(e.callbacks,e.yieldEvery),h=e.verbose==null?1:e.verbose,{callbackList:d,history:p}=yx(u,h,e.epochs,null,null,dD(t,e),null,r,c);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=e.initialEpoch==null?0:e.initialEpoch,m=await t.iterator();for(;f<e.epochs;){let g={};await d.onEpochBegin(f);let y=0,b=0;for(s||(m=await t.iterator());s?y<e.batchesPerEpoch:!0;){let C=await m.next();if(s&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){let{xs:w,ys:v}=Dx(n,C.value),I={};I.batch=b,I.size=w[0].shape[0],await d.onBatchBegin(b,I);let k=[];if(e.classWeight!=null){let F=Ex(e.classWeight,n.outputNames);for(let P=0;P<F.length;++P)k.push(await Ax(v[P],null,F[P]))}let T=w.concat(v).concat(k),E=i(T);bt(T);for(let F=0;F<l.length;++F){let P=l[F],M=E[F];I[P]=M,be(M)}await d.onBatchEnd(b,I),hx(I),b++,y++}if(s?y>=e.batchesPerEpoch:C.done){if(r){let w;Fx(e.validationData)?w=Mt(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):w=Mt(n.evaluate(o,a,{batchSize:e.validationBatchSize==null?cD:e.validationBatchSize,verbose:0}));for(let v=0;v<n.metricsNames.length;++v)g[`val_${n.metricsNames[v]}`]=w[v]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function dD(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Fx(n){return typeof n.iterator=="function"}function pD(n){return typeof n.next=="function"}async function fD(n,t,e){e=e||{};let s=e.batches!=null,r=n.testFunction,o=[];if(e.verbose>0)throw new gt("Verbose mode is not implemented yet.");N(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let a=pD(t)?t:await t.iterator(),i=0,l=0;for(;s?l<e.batches:!0;){let c=await a.next();if(o=O(()=>{if(c.value){let{xs:u,ys:h}=Dx(n,c.value),d=u.concat(h),p=O(()=>r(d));if(bt(d),l===0)for(let m=0;m<p.length;++m)o.push(ut(0));let f=d[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],y=o[m];o[m]=O(()=>Z(o[m],_(f,g))),l>0&&bt(y)}bt(p),i+=f,++l}return o}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<o.length;++c){let u=o[c];o[c]=dt(o[c],i),bt(u)}return Be(o)}function Wf(n){N(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Al(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Tr(s,t,e-t)):Tr(n,t,e-t)}function Uf(n,t){return O(()=>n==null?null:Array.isArray(n)?n.map(e=>Uf(e,t)):sx(n,t.dtype==="int32"?t:t.toInt()))}function Gf(n,t){let e=[],s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}async function mD(n,t,e,s,r,o,a,i,l,c,u,h,d,p,f){r==null&&(r=32),o==null&&(o=1),u==null&&(u=!0),d==null&&(d=0);let m=!1;if(l!=null&&c!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new R("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=n.checkNumSamples(e,r,p,"steps_per_epoch"),y;g!=null&&(y=An(0,g)),a==null&&(a=1);let{callbackList:b,history:C}=yx(i,a,o,d,g,p,r,m,h);b.setModel(n),n.history=C,await b.onTrainBegin(),n.stopTraining_=!1;for(let w=d;w<o;++w){await b.onEpochBegin(w);let v={};if(p!=null)throw new gt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new gt("batch shuffling is not implemneted yet");u&&yd(y);let I=Je(y),k=Gf(g,r);for(let T=0;T<k.length;++T){let E={};if(await b.onBatchBegin(T,E),O(()=>{let F=k[T][0],P=k[T][1],M=Tr(I,F,P-F);E.batch=T,E.size=P-F;let z=Uf(e,M),U=t(z);for(let B=0;B<s.length;++B){let V=s[B],K=U[B];E[V]=K,be(K)}if(T===k.length-1&&m){let B=n.testLoop(l,c,r);for(let V=0;V<s.length;++V){let K=s[V],j=B[V];be(j),v["val_"+K]=j}}}),await b.onBatchEnd(T,E),hx(E),n.stopTraining_)break}I.dispose()}if(await b.onEpochEnd(w,v),n.stopTraining_)break}return await b.onTrainEnd(),await n.history.syncData(),n.history}async function gD(n,t,e,s={}){if(n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;let r,o,a,i,l,c,u;try{let h=s.batchSize==null?32:s.batchSize;Wf(h);let d=!1,p=await n.standardizeUserData(t,e,s.sampleWeight,s.classWeight,d,h);r=p[0],o=p[1],u=p[2];let f=!1,m;if(s.validationData!=null&&s.validationData.length>0){if(f=!0,s.validationData.length===2)a=s.validationData[0],i=s.validationData[1];else throw s.validationData.length===3?new gt("validationData including sample weights is not supported yet."):new R(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);let k=!0,T=await n.standardizeUserData(a,i,null,null,k,h);l=T[0],c=T[1],m=l.concat(c)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){f=!0;let k=Math.floor(r[0].shape[0]*(1-s.validationSplit)),T=r[0].shape[0];l=Al(r,k,T),r=Al(r,0,k),c=Al(o,k,T),o=Al(o,0,k),m=l.concat(c)}else s.validationSteps!=null&&(f=!0);let g=r.concat(o).concat(u);n.checkTrainableWeightsConsistency();let y=n.makeTrainFunction(),b=n.getDedupedMetricsNames(),C,w;f?(n.makeTestFunction(),C=n.testFunction,w=b.slice().concat(b.map(k=>"val_"+k))):(C=null,m=[],w=b.slice());let v=gx(s.callbacks,s.yieldEvery);return await mD(n,y,g,b,h,s.epochs,s.verbose,v,C,m,s.shuffle,w,s.initialEpoch,null,null)}finally{n.isTraining=!1,Er(r,t),Er(o,e),Er(l,a),Er(c,i),u!=null&&bt(u)}}function _x(n){let t=[];n instanceof Dt&&(n=[n]);for(let e=0;e<n.length;++e){let s=n[e];if(s.rank===1)t.push(Nl(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Er(n,t){if(n==null)return;let e=[];if(t instanceof Dt)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(let r in t){let o=t[r];e.push(o.id)}let s=[];if(n instanceof Dt)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{e.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(let r in n){let o=n[r];e.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}function yD(n){return n instanceof Dt}function Hf(n){return Array.isArray(n)}function Ox(n){return!yD(n)&&!Hf(n)}function Lx(n,t,e,s=!0,r=""){if(t==null||t.length===0){if(n!=null){let a=!1;if(Hf(n)&&n.length>0)a=!0;else if(Ox(n)){for(let i in n)if(n.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new R(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(a=>null);let o;if(Ox(n)){n=n,o=[];for(let a of t){if(n[a]==null)throw new R(`No data provided for "${a}". Need data for each key in: ${t}`);o.push(n[a])}}else if(Hf(n)){if(n=n,n.length!==t.length)throw new R(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,t.length>1)throw new R(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=_x(o),e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let i=o[a];if(i.shape.length!==e[a].length)throw new R(`Error when checking ${r}: expected ${t[a]} to have ${e[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<e[a].length;++l){if(l===0&&!s)continue;let c=i.shape[l],u=e[a][l];if(u!=null&&u>=0&&c!==u)throw new R(`Error when checking ${r}: expected ${t[a]} to have shape [${e[a]}], but got array with shape [${i.shape}].`)}}return o}function bD(n,t,e){let s=Os(n.map(o=>o.shape[0]));s.sort();let r=Os(t.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new R(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>1)throw new R(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!At(s,r))throw new R(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function xD(n,t,e){let s=[ms,vh,Sl];for(let r=0;r<n.length;++r){let o=n[r],a=t[r],i=e[r];if(a!=null){if(a===Sl&&o.shape[o.shape.length-1]===1)throw new R(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){let l=o.shape.slice(1),c=i.slice(1);for(let u=0;u<l.length;++u){let h=l[u],d=c[u];if(d!=null&&h!==d)throw new R(`A target Tensor with shape ${o.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Px(n,t,e,s=!0,r=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new R(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new R(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let i=o[a];if(i.shape.length!==e[a].length)throw new R(`Error when checking ${r}: expected ${t[a]} to have ${e[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<e[a].length;++l){if(l===0&&!s)continue;let c=i.shape[l],u=e[a][l];if(u!=null&&u!==c)throw new R(`Error when checking ${r}: expected ${t[a]} to have shape ${JSON.stringify(e[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function wD(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{let s=[];for(let r of t){let o=e.hasOwnProperty(r)?e[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}let $D="layers-model";class gs extends _n{constructor(t){super(t);this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new R("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");QA(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=ZA(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof hs))throw new R("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let a in t.loss)if(this.outputNames.indexOf(a)===-1)throw new R(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)t.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),e.push(Of(t.loss[a]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new R(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(i=>Of(i))}else{let a=Of(t.loss);this.outputs.forEach(i=>{e.push(a)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Sr("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=wD(t.metrics,this.outputNames),o=(a,i,l)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([l,a])};Sr("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;let i=r[a];(c=>{let u="",h,d,p;for(let f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===vh?["accuracy","acc"].indexOf(f)!==-1?d=Lf:["crossentropy","ce"].indexOf(f)!==-1&&(d=wx):this.lossFunctions[a]===$h?["accuracy","acc"].indexOf(f)!==-1?d=$x:["crossentropy","ce"].indexOf(f)!==-1&&(d=vx):["accuracy","acc"].indexOf(f)!==-1?d=Pf:["crossentropy","ce"].indexOf(f)!==-1&&(d=zf);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=d,h=u+y}else p=JA(f),h=u+Ih(f);let m;Sr(h,()=>{m=p}),o(a,h,m)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){let r=s.batchSize==null?32:s.batchSize;Wf(r);let o=!0,a=this.standardizeUserDataXY(t,e,o,r);try{let i=a[0].concat(a[1]);this.makeTestFunction();let l=this.testFunction,c=this.testLoop(l,i,r,s.verbose,s.steps);return Be(c)}finally{Er(a[0],t),Er(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),fD(this,t,e)}checkNumSamples(t,e,s,r="steps"){let o;if(s!=null){if(o=null,e!=null)throw new R(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?o=t[0].shape[0]:o=t.shape[0];else throw new R(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new R("`outputs` is an empty Array, which is not allowed.");let s=Array.isArray(e),r=s?e:[e],o=this.retrieveSymbolicTensors(r),a=new Bs;if(t instanceof Dt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new R(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],t[l])}else for(let l of this.inputs){let c=t[l.name];if(c==null)throw new R(`No value is provided for the model's input ${l.name}`);a.add(l,c)}let i=El(o,a);return s?i:i[0]}retrieveSymbolicTensors(t){let e=Nr(null,t.length),s=t.length;for(let r of this.layers){let o=Array.isArray(r.output)?r.output:[r.output],a=o.map(i=>i.name);for(let i=0;i<t.length;++i){let l=a.indexOf(t[i]);if(l!==-1&&(e[i]=o[l],s--),s===0)break}if(s===0)break}if(s>0){let r=[];throw e.forEach((o,a)=>{o==null&&r.push(t[a])}),new R(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,s=!1){return O(()=>{let r=this.checkNumSamples(t);if(s)throw new gt("Verbose predictLoop() is not implemented yet.");let o=Gf(r,e),a=this.outputs.map(i=>[]);for(let i=0;i<o.length;++i)O(()=>{let c=o[i][0],u=o[i][1],h=Al(t,c,u),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});let p=new Bs(d);return El(this.outputs,p)}).forEach((c,u)=>a[u].push(c));return Be(a.map(i=>ee(i,0)))})}predict(t,e={}){let s=_x(t);Px(s,this.inputNames,this.feedInputShapes,!1);try{let r=e.batchSize==null?32:e.batchSize;return Wf(r),this.predictLoop(s,r)}finally{Er(s,t)}}predictOnBatch(t){Px(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,r){if(this.optimizer_==null)throw new bn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let o=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===$h?o.push(i.slice(0,i.length-1).concat([1])):o.push(i)}if(t=Lx(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Lx(e,this.feedOutputNames,o,!1,"target"),bD(t,e,null),xD(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!=0)throw new R(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,r,o=!0,a){let[i,l]=this.standardizeUserDataXY(t,e,o,a);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){let u=Ex(r,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await Ax(l[h],null,u[h]))}return[i,l,c]}testLoop(t,e,s,r=0,o){return O(()=>{let a=this.checkNumSamples(e,s,o,"steps"),i=[];if(r>0)throw new gt("Verbose mode is not implemented yet.");if(o!=null)throw new gt("steps mode in testLoop() is not implemented yet");{let l=Gf(a,s),c=Je(An(0,a));for(let u=0;u<l.length;++u){let h=l[u][0],d=l[u][1],p=Tr(c,h,d-h),f=Uf(e,p),m=t(f);if(u===0)for(let g=0;g<m.length;++g)i.push(ut(0));for(let g=0;g<m.length;++g){let y=m[g];i[g]=Z(i[g],_(d-h,y))}}for(let u=0;u<i.length;++u)i[u]=dt(i[u],a)}return i})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){let r=t[s],o=r;Hb(t,r)>1&&(o+=`_${Hb(t.slice(0,s),r)}`),e.push(o)}return e}makeTrainFunction(){return t=>{let e=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});let d=new Bs(h),p=El(this.outputs,d,{training:!0}),f;for(let m=0;m<this.lossFunctions.length;++m){let y=this.lossFunctions[m](r[m],p[m]);o[m]!=null&&(y=lD(y,o[m]));let b=Zt(y);e.push(b),m===0?f=y:f=Z(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=e[m];else{let y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Zt(y(r[b],p[b]))}be(g),a.push(g)}return f=Zt(f),this.calculateLosses().forEach(m=>{f=Z(f,m)}),f},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(i,c,l)].concat(a)}}makeTestFunction(){this.testFunction=t=>O(()=>{let e=[],s,r=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:r[c]});let i=new Bs(a),l=El(this.outputs,i);for(let c=0;c<this.lossFunctions.length;++c){let u=this.lossFunctions[c],h=Zt(u(o[c],l[c]));c===0?s=h:s=Z(s,h),e.push(s)}for(let c=0;c<this.metricsTensors.length;++c){let u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],d=Zt(u(o[h],l[h]));e.push(d)}return e})}async fit(t,e,s={}){return gD(this,t,e,s)}async fitDataset(t,e){return hD(this,t,e)}async trainOnBatch(t,e){let s=await this.standardizeUserData(t,e),r=s[0],o=s[1],i=this.makeTrainFunction()(r.concat(o)),l=[];for(let c of i){let u=await c.data();l.push(u[0])}return bt(i),Be(l)}getNamedWeights(t){let e=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||e.push({name:r[a].originalName,tensor:o[a]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=mu().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-mu().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=fs(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>fs(e))}else{let e=Object.keys(this.loss);t={};let s=this.loss;for(let r of e)if(typeof s[r]=="string")t[r]=fs(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[fs(Ih(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>fs(Ih(t)));{let t={};for(let e in this.metrics)t[e]=fs(Ih(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Tl(t.optimizer_config),s=Fn(e),r;if(typeof t.loss=="string")r=kr(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(a=>kr(a));else if(t.loss!=null){r={};for(let a in t.loss)r[a]=kr(t.loss[a])}let o;if(Array.isArray(t.metrics))o=t.metrics.map(a=>kr(a));else if(t.metrics!=null){o={};for(let a in t.metrics)o[a]=kr(t.metrics[a])}this.compile({loss:r,metrics:o,optimizer:s})}async save(t,e){if(typeof t=="string"){let c=Md(t);if(c.length===0)throw new R(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new R(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new R("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let s=await Pd(this.getNamedWeights(e)),r=!1,o=null,i={modelTopology:this.toJSON(o,r),format:$D,generatedBy:`TensorFlow.js tfjs-layers v${Th}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let c="optimizer",{data:u,specs:h}=await Pd(await this.optimizer.getWeights(),c);s.specs.push(...h),s.data=iu([s.data,u])}if(this.userDefinedMetadata!=null){let c=!0;Nx(this.userDefinedMetadata,this.name,c),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=s.data,i.weightSpecs=s.specs,t.save(i)}setUserDefinedMetadata(t){Nx(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}gs.className="Model",X(gs);class zx extends gs{}zx.className="Functional",X(zx);async function vD(n,t){"modelTopology"in n||(n={modelTopology:n}),n=n;let e=n.modelTopology;e.model_config!=null&&(e=e.model_config);let s=Tl(e),r=Fn(s,t);if(n.weightsManifest!=null){let o=await xy(n.weightsManifest,n.pathPrefix,r.weights.map(i=>i.originalName)),a={};for(let i of r.weights)a[i.originalName]=o[i.originalName];r.loadWeights(a),bt(o)}return r}async function CD(n,t){if(t==null&&(t={}),typeof n=="string"){let e=Bd(n,t);if(e.length===0)e.push(uu(n,t));else if(e.length>1)throw new R(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return ND(n,void 0,t)}async function ND(n,t,e){if(e==null&&(e={}),n.load==null)throw new R("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let s=await n.load(),r=s.modelTopology;r.model_config!=null&&(r=r.model_config);let o=e.strict==null?!0:e.strict,a=s.weightData!=null&&s.weightSpecs!=null&&o,i=Fn(Tl(r),t,a),l=s.trainingConfig;if(l!=null&&i.loadTrainingConfig(l),s.userDefinedMetadata!=null&&i.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new R("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:u}=kD(s.weightData,s.weightSpecs);i.loadWeights(c,o),i.optimizer!=null&&u.length>0&&await i.optimizer.setWeights(u),bt(c),bt(u.map(h=>h.tensor))}return i}function kD(n,t){let e=au(n,t),s={},r=[];return t.forEach(o=>{o.group==="optimizer"?r.push({name:o.name,tensor:e[o.name]}):s[o.name]=e[o.name]}),{modelWeights:s,optimizerWeights:r}}class Ar extends gs{constructor(t){super({inputs:[],outputs:[]});if(t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:gh("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new R(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Ar||t instanceof gs,s;if(e){if(s=t,s.outputs.length!==1)throw new R("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new R("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new R("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=ux({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new R(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new R("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=cx(this.outputs[0])}this.inboundNodes=[],new xh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Nr(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Lt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new gs({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new bn("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new bn("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new bn("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new bn("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},r=!1){let o,a={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new R("Legacy serialization format not supported yet.");o=e}else N(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=e.layers,delete e.layers,a=e;let i=new t(a);if(!(i instanceof Ar))throw new gt(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let l of o){let u=Fn(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),i.add(u)}return i}set stopTraining(t){if(this.model==null)throw new R("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new R("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}Ar.className="Sequential",X(Ar);function ID(n){return new gs(n)}function SD(n){return new Ar(n)}function TD(n,t){return t==null&&(t={}),CD(n,t)}function Mx(n){return ux(n)}function ED(n,t){hn.registerCallbackConstructor(n,t)}class Ze extends dr{getConfig(){return{}}}class Bx extends Ze{apply(t,e=1){return sA(t,e)}}Bx.className="elu",X(Bx);class Vx extends Ze{apply(t){return Ou(t)}}Vx.className="selu",X(Vx);class Wx extends Ze{apply(t){return Xn(t)}}Wx.className="relu",X(Wx);class Ux extends Ze{apply(t){return O(()=>Zo(6,Xn(t)))}}Ux.className="relu6",X(Ux);class Gx extends Ze{apply(t){return t}}Gx.className="linear",X(Gx);class Hx extends Ze{apply(t){return Gn(t)}}Hx.className="sigmoid",X(Hx);class jx extends Ze{apply(t){return oA(t)}}jx.className="hardSigmoid",X(jx);class qx extends Ze{apply(t){return Xo(t)}}qx.className="softplus",X(qx);class Kx extends Ze{apply(t){return rA(t)}}Kx.className="softsign",X(Kx);class Xx extends Ze{apply(t){return Ho(t)}}Xx.className="tanh",X(Xx);class jf extends Ze{apply(t,e=-1){return il(t,e)}}jf.className="softmax",X(jf);class Yx extends Ze{apply(t,e=-1){return Tu(t,e)}}Yx.className="logSoftmax",X(Yx);class Jx extends Ze{apply(t,e=1){return O(()=>Gn(t.mul(e)).mul(t))}}Jx.className="swish",X(Jx);function Vs(n){return n.getClassName()}function qf(n,t={}){return wl(n,rn.getMap().classNameMap,t,"activation")}function Ws(n){if(n==null){let t={};return t.className="linear",t.config={},qf(t)}if(typeof n=="string"){let t={};return t.className=n,t.config={},qf(t)}else return n instanceof Ze?n:qf(n)}function Kf(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Zx extends dr{}class Dl extends Zx{constructor(t){super();Kf(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return O(()=>{let e=re([1]);return this.hasL1&&(e=Z(e,ht(_(this.l1,ue(t))))),this.hasL2&&(e=Z(e,ht(_(this.l2,kl(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}Dl.className="L1L2",X(Dl);function AD(n){return Kf(n),new Dl({l1:n!=null?n.l1:null,l2:0})}function DD(n){return Kf(n),new Dl({l2:n!=null?n.l2:null,l1:0})}let Qx={l1l2:"L1L2"};function Pt(n){return hf(n)}function tw(n,t={}){return wl(n,rn.getMap().classNameMap,t,"regularizer")}function qt(n){if(n==null)return null;if(typeof n=="string"){let e={className:n in Qx?Qx[n]:n,config:{}};return tw(e)}else return n instanceof Zx?n:tw(n)}class Xf extends Tt{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=wt(t);let s=Xn(t);return this.maxValue!=null&&(s=Me(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}Xf.className="ReLU",X(Xf);class Yf extends Tt{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let s=wt(t);return tl(s,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Yf.className="LeakyReLU",X(Yf);class Jf extends Tt{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=jt(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qt(t.alphaRegularizer),this.alphaConstraint=fe(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new R(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Lt(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new ve({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=wt(t),rl(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Qt(this.alphaInitializer),alphaRegularizer:Pt(this.alphaRegularizer),alphaConstraint:pe(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}Jf.className="PReLU",X(Jf);class Zf extends Tt{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new gt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let s=wt(t);return qo(s)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Zf.className="ELU",X(Zf);class Qf extends Tt{constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let s=wt(t);return s.mul(Cl(s.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}Qf.className="ThresholdedReLU",X(Qf);class tm extends Tt{constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new jf().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let s=wt(t);return this.softmax(s,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}tm.className="Softmax",X(tm);function ha(n,t,e){if(typeof n=="number")return Nr(n,t);if(n.length!==t)throw new R(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){let r=n[s];if(!J2(r))throw new R(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function On(n,t,e,s,r=1){if(n==null)return n;let o=t+(t-1)*(r-1),a;return e==="same"?a=n:a=n-o+1,Math.floor((a+s-1)/s)}function Eh(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Ps([e-t,0]);else if(s==="same")n=n*t;else throw new R(`Unsupport padding mode: ${s}.`);return n}function em(n,t){return O(()=>(Ht(t),t==="channelsFirst"?Rt(n,[0,2,3,1]):n))}function ew(n,t){return O(()=>(Ht(t),t==="channelsFirst"?Rt(n,[0,2,3,4,1]):n))}function nw(n,t,e,s=1,r="valid",o,a=1){return O(()=>{if(o==null&&(o=En()),Ht(o),n.shape.length!==3)throw new R(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new R(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new R(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(n=Rt(n,[0,2,1])),r==="causal")throw new gt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=xu(n,t,s,r==="same"?"same":"valid","NWC",a);return e!=null&&(i=Zn(i,e)),i})}function SX(n,t,e=1,s="valid",r,o=1){return O(()=>(Ht(r),nw(n,t,null,e,s,r,o)))}function TX(n,t,e=[1,1],s="valid",r,o){return O(()=>(Ht(r),nm(n,t,null,e,s,r,o)))}function nm(n,t,e,s=[1,1],r="valid",o,a,i=null){return O(()=>{if(o==null&&(o=En()),Ht(o),n.rank!==3&&n.rank!==4)throw new R(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new R(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=em(n,o);if(r==="causal")throw new gt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=jp({x:l,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:e,activation:i}),o==="channelsFirst"&&(l=Rt(l,[0,3,1,2])),l})}function EX(n,t,e=[1,1,1],s="valid",r,o){return O(()=>(Ht(r),sw(n,t,null,e,s,r,o)))}function sw(n,t,e,s=[1,1,1],r="valid",o,a){return O(()=>{if(o==null&&(o=En()),Ht(o),n.rank!==4&&n.rank!==5)throw new R(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new R(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let i=ew(n,o);if(r==="causal")throw new gt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=yp(i,t,s,r==="same"?"same":"valid","NDHWC",a),e!=null&&(i=Zn(i,e)),o==="channelsFirst"&&(i=Rt(i,[0,4,1,2,3])),i})}class Ah extends Tt{constructor(t,e){super(e);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ah.verifyArgs(e),this.rank=t,$e(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new gt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ha(e.kernelSize,t,"kernelSize"),this.strides=ha(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,un(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ht(this.dataFormat),this.activation=Ws(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=jt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=fe(e.biasConstraint),this.biasRegularizer=qt(e.biasRegularizer),this.activityRegularizer=qt(e.activityRegularizer),this.dilationRate=ha(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new R(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new R(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new R(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(cn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!pf(t.kernelSize,"number",1,3))throw new R(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Vs(this.activation),useBias:this.useBias,biasInitializer:Qt(this.biasInitializer),biasRegularizer:Pt(this.biasRegularizer),activityRegularizer:Pt(this.activityRegularizer),biasConstraint:pe(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class da extends Ah{constructor(t,e){super(t,e);this.kernel=null,da.verifyArgs(e),this.filters=e.filters,$e(this.filters,"filters"),this.kernelInitializer=jt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=fe(e.kernelConstraint),this.kernelRegularizer=qt(e.kernelRegularizer)}build(t){t=Lt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new R(`The channel dimension of the input should be defined. Found ${t[e]}`);let s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return O(()=>{t=wt(t);let s,r=this.bias==null?null:this.bias.read(),o=qb(this.activation.getClassName());if(o!=null&&this.rank===2)s=nm(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=nw(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=nm(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=sw(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new gt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Lt(t);let e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<s.length;++o){let a=On(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);e.push(a)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){let t={filters:this.filters,kernelInitializer:Qt(this.kernelInitializer),kernelRegularizer:Pt(this.kernelRegularizer),kernelConstraint:pe(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new R(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class pa extends da{constructor(t){super(2,t);pa.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!pf(t.kernelSize,"number",1,2))throw new R(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}pa.className="Conv2D",X(pa);class Rl extends da{constructor(t){super(3,t);Rl.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new R(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}Rl.className="Conv3D",X(Rl);class sm extends pa{constructor(t){super(t);if(this.inputSpec=[new ve({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new R(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Lt(t),t.length!==4)throw new R("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new R("The channel dimension of the inputs should be defined. Found `None`.");let s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return O(()=>{let s=wt(t);if(s.shape.length!==4)throw new R(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);let r=s.shape,o=r[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let l=r[a],c=r[i],u=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=Eh(l,d,u,this.padding),m=Eh(c,p,h,this.padding),g=[o,f,m,this.filters];this.dataFormat!=="channelsLast"&&(s=Rt(s,[0,2,3,1]));let y=wu(s,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Rt(y,[0,3,1,2])),this.bias!=null&&(y=Zn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=Lt(t);let e=t.slice(),s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);let a=this.kernelSize[0],i=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return e[s]=this.filters,e[r]=Eh(e[r],l,a,this.padding),e[o]=Eh(e[o],c,i,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}}sm.className="Conv2DTranspose",X(sm);class rw extends da{constructor(t,e){super(t,e);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new R("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new R("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new R(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=jt(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qt(e.depthwiseRegularizer),this.depthwiseConstraint=fe(e.depthwiseConstraint),this.pointwiseInitializer=jt(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qt(e.pointwiseRegularizer),this.pointwiseConstraint=fe(e.pointwiseConstraint)}build(t){if(t=Lt(t),t.length<this.rank+2)throw new R(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new R(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let s=t[e],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let i=0;i<this.rank;++i)o.push(1);o.push(s*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ve({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return O(()=>{t=wt(t);let s;if(this.rank===1)throw new gt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Rt(t,[0,2,3,1])),s=Op(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Zn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Rt(s,[0,3,1,2])),s})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Qt(this.depthwiseInitializer),t.pointwiseInitializer=Qt(this.pointwiseInitializer),t.depthwiseRegularizer=Pt(this.depthwiseRegularizer),t.pointwiseRegularizer=Pt(this.pointwiseRegularizer),t.depthwiseConstraint=pe(this.depthwiseConstraint),t.pointwiseConstraint=pe(this.pointwiseConstraint),t}}rw.className="SeparableConv";class rm extends rw{constructor(t){super(2,t)}}rm.className="SeparableConv2D",X(rm);class Fl extends da{constructor(t){super(1,t);Fl.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!pf(t.kernelSize,"number",1,1))throw new R(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Fl.className="Conv1D",X(Fl);class om extends Tt{constructor(t){super(t);typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return O(()=>{if(t=wt(t),this.dataFormat==="channelsLast"){let s=ah(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ah(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let s=ah(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ah(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}om.className="Cropping2D",X(om);class am extends Tt{constructor(t){super(t);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ht(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,K2(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{let e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return O(()=>{let s=wt(t),r=s.shape;if(this.dataFormat==="channelsFirst"){s=Rt(s,[0,2,3,1]);let o=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?s.resizeNearestNeighbor([o,a]):s.resizeBilinear([o,a]);return Rt(i,[0,3,1,2])}else{let o=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?s.resizeNearestNeighbor([o,a]):s.resizeBilinear([o,a])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}am.className="UpSampling2D",X(am);function RD(n,t,e=[1,1],s="valid",r,o){return O(()=>{r==null&&(r=En()),Ht(r);let a=em(n,r);if(n.rank!==4)throw new R(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new R(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=jo(a,t,e,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(a=Rt(a,[0,3,1,2])),a})}class im extends Ah{constructor(t){super(2,t);this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=jt(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=fe(t.depthwiseConstraint),this.depthwiseRegularizer=qt(t.depthwiseRegularizer)}build(t){if(t=Lt(t),t.length<4)throw new R(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new R(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let s=t[e],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return O(()=>{t=wt(t);let s=RD(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Zn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=Lt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=On(e,this.kernelSize[0],this.padding,this.strides[0]),a=On(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,o,a]:[t[0],o,a,r]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Qt(this.depthwiseInitializer),t.depthwiseRegularizer=Pt(this.depthwiseRegularizer),t.depthwiseConstraint=pe(this.depthwiseRegularizer),t}}im.className="DepthwiseConv2D",X(im);function ow(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new R("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return t=r(t),e=r(e),{inputs:n,initialState:t,constants:e}}function aw(n,t,e,s=!1,r,o,a=!1,i=!1){return O(()=>{let l=t.shape.length;if(l<3)throw new R(`Input should be at least 3D, but is ${l}D.`);let c=[1,0].concat(An(2,l));if(t=Rt(t,c),o!=null)throw new gt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=r.asType("bool").asType("float32"),r.rank===l-1&&(r=je(r,-1)),r=Rt(r,c)),s&&(t=Ke(t,0),r!=null&&(r=Ke(r,0)));let u=[],h,d=e,p=t.shape[0],f=yn(t),m;r!=null&&(m=yn(r));for(let y=0;y<p;++y){let b=f[y],C=O(()=>n(b,d));if(r==null)h=C[0],d=C[1];else{let w=O(()=>{let v=m[y],I=Le(v).sub(v),k=C[0].mul(v).add(d[0].mul(I)),T=d.map((E,F)=>C[1][F].mul(v).add(E.mul(I)));return{output:k,newStates:T}});h=w.output,d=w.newStates}i&&u.push(h)}let g;return i&&(g=Ye(u,1)),[h,g,d]})}class Ln extends Tt{constructor(t){super(t);let e;if(t.cell==null)throw new R("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Fh({cells:t.cell}):e=t.cell,e.stateSize==null)throw new R("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ve({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return An(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Af(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let s=e[0],r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){let o=[];for(let a of e)o.push([t[0],a]);return[r].concat(o)}else return r}computeMask(t,e){return O(()=>{Array.isArray(e)&&(e=e[0]);let s=this.returnSequences?e:null;if(this.returnState){let r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){let e=null;if(this.numConstants!=null)throw new gt("Constants support is not implemented in RNN yet.");Af(t)&&(t=t[0]),t=t;let s=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new ve({shape:[s,null,...r]});let o=[t[0]].concat(t.slice(2));if(e!=null)throw new gt("Constants support is not implemented in RNN yet.");this.cell.build(o);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!At(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new R(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new ve({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){O(()=>{if(!this.stateful)throw new Yn("Cannot call resetStates() on an RNN Layer that is not stateful.");let s=this.inputSpec[0].shape[0];if(s==null)throw new R("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>re([s,r])):this.states_=[re([s,this.cell.stateSize])];else if(t==null)bt(this.states_),this.keptStates!=null&&(bt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>re([s,r])):this.states_[0]=re([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new R(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):bt(this.states_);for(let r=0;r<this.states_.length;++r){let o=t[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[s,a];if(!At(o.shape,i))throw new R(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>be(r.clone()))})}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});let o=ow(t,s,r,this.numConstants);t=o.inputs,s=o.initialState,r=o.constants;let a=[],i=[];if(s!=null){e.initialState=s,a=a.concat(s),this.stateSpec=[];for(let c of s)this.stateSpec.push(new ve({shape:c.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(e.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Rn){let c=[t].concat(a),u=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=u;let d=super.apply(c,e);return this.inputSpec=h,d}else return super.apply(t,e)}call(t,e){return O(()=>{let s=e==null?null:e.mask,r=e==null?null:e.training,o=e==null?null:e.initialState;t=wt(t),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(t));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new R(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},c=aw((f,m)=>{let g=this.cell.call([f].concat(m),i);return[g[0],g.slice(1)]},t,o,this.goBackwards,s,null,this.unroll,this.returnSequences),u=c[0],h=c[1],d=c[2];this.stateful&&this.resetStates(d,r);let p=this.returnSequences?h:u;return this.returnState?[p].concat(d):p})}getInitialState(t){return O(()=>{let e=re(t.shape);return e=ht(e,[1,2]),e=Nl(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?$f(e,[1,s]):e):this.cell.stateSize>1?[$f(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let s=this.cell.getConfig();return this.getClassName()===Ln.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,t,e)}static fromConfig(t,e,s={}){let r=e.cell,o=Fn(r,s);return new t(Object.assign(e,{cell:o}))}}Ln.className="RNN",X(Ln);class fa extends Tt{}class Dh extends fa{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,$e(this.units,"units"),this.activation=Ws(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qt(t.kernelRegularizer),this.recurrentRegularizer=qt(t.recurrentRegularizer),this.biasRegularizer=qt(t.biasRegularizer),this.kernelConstraint=fe(t.kernelConstraint),this.recurrentConstraint=fe(t.recurrentConstraint),this.biasConstraint=fe(t.biasConstraint),this.dropout=ia([1,Ps([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ia([1,Ps([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Lt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return O(()=>{if(t=t,t.length!==2)throw new R(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];let r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Us({ones:()=>Le(t),rate:this.dropout,training:r})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Us({ones:()=>Le(s),rate:this.recurrentDropout,training:r}));let o,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?o=Jn(_(t,a),this.kernel.read()):o=Jn(t,this.kernel.read()),this.bias!=null&&(o=Zn(o,this.bias.read())),i!=null&&(s=_(s,i));let l=Z(o,Jn(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Vs(this.activation),useBias:this.useBias,kernelInitializer:Qt(this.kernelInitializer),recurrentInitializer:Qt(this.recurrentInitializer),biasInitializer:Qt(this.biasInitializer),kernelRegularizer:Pt(this.kernelRegularizer),recurrentRegularizer:Pt(this.recurrentRegularizer),biasRegularizer:Pt(this.biasRegularizer),activityRegularizer:Pt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}Dh.className="SimpleRNNCell",X(Dh);class lm extends Ln{constructor(t){t.cell=new Dh(t),super(t)}call(t,e){return O(()=>{this.cell.dropoutMask!=null&&(bt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let s=e==null?null:e.mask,r=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:o})})}static fromConfig(t,e){return new t(e)}}lm.className="SimpleRNN",X(lm);class Rh extends fa{constructor(t){super(t);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new R("GRUCell does not support reset_after parameter set to true.");this.units=t.units,$e(this.units,"units"),this.activation=Ws(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ws(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qt(t.kernelRegularizer),this.recurrentRegularizer=qt(t.recurrentRegularizer),this.biasRegularizer=qt(t.biasRegularizer),this.kernelConstraint=fe(t.kernelConstraint),this.recurrentConstraint=fe(t.recurrentConstraint),this.biasConstraint=fe(t.biasConstraint),this.dropout=ia([1,Ps([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ia([1,Ps([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Lt(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return O(()=>{if(t=t,t.length!==2)throw new R(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let s=e.training==null?!1:e.training,r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Us({ones:()=>Le(t),rate:this.dropout,training:s,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Us({ones:()=>Le(r),rate:this.recurrentDropout,training:s,count:3}));let o=this.dropoutMask,a=this.recurrentDropoutMask,i,l,c;0<this.dropout&&this.dropout<1&&(t=_(t,o[0]));let u=Jn(t,this.kernel.read());this.useBias&&(u=Zn(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_(r,a[0]));let h=this.recurrentKernel.read(),[d,p]=Xe(h,[2*this.units,this.units],h.rank-1),f=Jn(r,d),[m,g,y]=Xe(u,3,u.rank-1),[b,C]=Xe(f,2,f.rank-1);i=this.recurrentActivation.apply(Z(m,b)),l=this.recurrentActivation.apply(Z(g,C));let w=Jn(_(l,r),p);c=this.activation.apply(Z(y,w));let v=Z(_(i,r),_(Z(1,Jt(i)),c));return[v,v]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Vs(this.activation),recurrentActivation:Vs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Qt(this.kernelInitializer),recurrentInitializer:Qt(this.recurrentInitializer),biasInitializer:Qt(this.biasInitializer),kernelRegularizer:Pt(this.kernelRegularizer),recurrentRegularizer:Pt(this.recurrentRegularizer),biasRegularizer:Pt(this.biasRegularizer),activityRegularizer:Pt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}Rh.className="GRUCell",X(Rh);class cm extends Ln{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Rh(t),super(t)}call(t,e){return O(()=>{this.cell.dropoutMask!=null&&(bt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let s=e==null?null:e.mask,r=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}cm.className="GRU",X(cm);class _l extends fa{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,$e(this.units,"units"),this.activation=Ws(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ws(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=qt(t.kernelRegularizer),this.recurrentRegularizer=qt(t.recurrentRegularizer),this.biasRegularizer=qt(t.biasRegularizer),this.kernelConstraint=fe(t.kernelConstraint),this.recurrentConstraint=fe(t.recurrentConstraint),this.biasConstraint=fe(t.biasConstraint),this.dropout=ia([1,Ps([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ia([1,Ps([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Lt(t);let s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let o=this.biasInitializer,a=this.units;r=new(e=class extends wn{apply(l,c){let u=o.apply([a]),h=new lh().apply([a]),d=o.apply([a*2]);return nx(nx(u,h),d)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return O(()=>{let s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new R(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1],o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Us({ones:()=>Le(t),rate:this.dropout,training:s,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Us({ones:()=>Le(r),rate:this.recurrentDropout,training:s,count:4}));let a=this.dropoutMask,i=this.recurrentDropoutMask,l,c,u,h;0<this.dropout&&this.dropout<1&&(t=_(t,a[0]));let d=Jn(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_(r,i[0])),d=Z(d,Jn(r,this.recurrentKernel.read())),this.useBias&&(d=Zn(d,this.bias.read()));let[p,f,m,g]=Xe(d,4,d.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),u=Z(_(c,o),_(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);let y=_(h,this.activation.apply(u));return[y,y,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Vs(this.activation),recurrentActivation:Vs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Qt(this.kernelInitializer),recurrentInitializer:Qt(this.recurrentInitializer),biasInitializer:Qt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Pt(this.kernelRegularizer),recurrentRegularizer:Pt(this.recurrentRegularizer),biasRegularizer:Pt(this.biasRegularizer),activityRegularizer:Pt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}_l.className="LSTMCell",X(_l);class um extends Ln{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new _l(t),super(t)}call(t,e){return O(()=>{this.cell.dropoutMask!=null&&(bt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let s=e==null?null:e.mask,r=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}um.className="LSTM",X(um);class Fh extends fa{constructor(t){super(t);this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return O(()=>{t=t;let s=t.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(s.splice(0,i.stateSize.length)):r.push(s.splice(0,1));r.reverse();let o=[],a;for(let i=0;i<this.cells.length;++i){let l=this.cells[i];s=r[i],i===0?a=[t[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,e),o.push(a.slice(1))}s=[];for(let i of o.slice().reverse())s.push(...i);return[a[0]].concat(s)})}build(t){Af(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,r)=>{Sr(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(e)};return Object.assign({},t,r)}static fromConfig(t,e,s={}){let r=[];for(let o of e.cells)r.push(Fn(o,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return Df(t)}setWeights(t){let e=[];for(let s of this.cells){let r=s.weights.length,o=t.splice(r);for(let a=0;a<s.weights.length;++a)e.push([s.weights[a],o[a]])}Rf(e)}}Fh.className="StackedRNNCells",X(Fh);function Us(n){let{ones:t,rate:e,training:s=!1,count:r=1}=n,o=()=>rx(t(),e),a=()=>Il(o,t,s);return!r||r<=1?be(a().clone()):Array(r).fill(void 0).map(a).map(l=>be(l.clone()))}var FD=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e};class AX extends fa{}class iw extends Ln{constructor(t){if(t.unroll)throw new gt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new gt("It is not possible at the moment to stack convolutional cells.");super(t);this.inputSpec=[new ve({ndim:5})]}call(t,e){return O(()=>{if(this.cell.dropoutMask!=null&&(bt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new R("ConvRNN2D cell does not support constants");let s=e==null?null:e.mask,r=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:o})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return O(()=>{let{stateSize:e}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],a=re(o);return Array.isArray(e)?Array(e.length).fill(a):[a]})}resetStates(t,e=!1){O(()=>{if(!this.stateful)throw new Yn("Cannot call resetStates() on an RNN Layer that is not stateful.");let s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new R("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>re(o)):this.states_=[re(o)];else if(t==null)bt(this.states_),this.keptStates!=null&&(bt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>re(o)):this.states_[0]=re(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new R(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):bt(this.states_);for(let i=0;i<this.states_.length;++i){let l=t[i],c=o;if(!At(l.shape,c))throw new R(`State ${i} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[i]=l}}this.states_=this.states_.map(i=>be(i.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:s,kernelSize:r,padding:o,strides:a,dilationRate:i}=this.cell,l=e==="channelsFirst",c=t[l?3:2],u=t[l?4:3],h=On(c,r[0],o,a[0],i[0]),d=On(u,r[1],o,a[1],i[1]);return[...t.slice(0,2),...l?[s,h,d]:[h,d,s]]}}iw.className="ConvRNN2D";class _h extends _l{constructor(t){let{filters:e,kernelSize:s,strides:r,padding:o,dataFormat:a,dilationRate:i}=t;super(Object.assign({},t,{units:e}));this.filters=e,$e(this.filters,"filters"),this.kernelSize=ha(s,2,"kernelSize"),this.kernelSize.forEach(l=>$e(l,"kernelSize")),this.strides=ha(r||1,2,"strides"),this.strides.forEach(l=>$e(l,"strides")),this.padding=o||"valid",un(this.padding),this.dataFormat=a||"channelsLast",Ht(this.dataFormat),this.dilationRate=ha(i||1,2,"dilationRate"),this.dilationRate.forEach(l=>$e(l,"dilationRate"))}build(t){var e;t=Lt(t);let s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new R(`The channel dimension of the input should be defined. Found ${t[s]}`);let r=t[s],o=4,a=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let c=this.biasInitializer,u=this.filters;l=new(e=class extends wn{apply(d,p){let f=c.apply([u]),m=Tn([u]),g=c.apply([u*2]);return wf([f,m,g])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return O(()=>{if(t.length!==3)throw new R(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=e.training||!1,r=t[0],o=t[1],a=t[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Us({ones:()=>Le(r),rate:this.dropout,training:s,count:i}));let l=this.dropoutMask,c=(J,Y,tt)=>!Y||!Y[tt]?J:_(Y[tt],J),u=c(r,l,0),h=c(r,l,1),d=c(r,l,2),p=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Us({ones:()=>Le(o),rate:this.recurrentDropout,training:s,count:i}));let f=this.recurrentDropoutMask,m=c(o,f,0),g=c(o,f,1),y=c(o,f,2),b=c(o,f,3),C=3,[w,v,I,k]=Xe(this.kernel.read(),i,C),[T,E,F,P]=this.useBias?Xe(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,w,T,this.padding),h=this.inputConv(h,v,E,this.padding),d=this.inputConv(d,I,F,this.padding),p=this.inputConv(p,k,P,this.padding);let[M,z,U,B]=Xe(this.recurrentKernel.read(),i,C);m=this.recurrentConv(m,M),g=this.recurrentConv(g,z),y=this.recurrentConv(y,U),b=this.recurrentConv(b,B);let V=this.recurrentActivation.apply(Z(u,m)),K=this.recurrentActivation.apply(Z(h,g)),j=Z(_(K,a),_(V,this.activation.apply(Z(d,y)))),q=_(this.recurrentActivation.apply(Z(p,b)),this.activation.apply(j));return[q,q,j]})}getConfig(){let t=super.getConfig(),{units:e}=t,s=FD(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},s,r)}inputConv(t,e,s,r){let o=ls(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Zn(o,s,this.dataFormat):o}recurrentConv(t,e){return ls(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}_h.className="ConvLSTM2DCell",X(_h);class hm extends iw{constructor(t){let e=new _h(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}hm.className="ConvLSTM2D",X(hm);class Oh extends Tt{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return s}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);if(0<this.rate&&this.rate<1){let r=e.training==null?!1:e.training,o=this.getNoiseShape(s);return Il(()=>rx(s,this.rate,o,this.seed),()=>s,r)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}Oh.className="Dropout",X(Oh);class dm extends Oh{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}}dm.className="SpatialDropout1D",X(dm);class pm extends Tt{constructor(t){super(t);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,$e(this.units,"units"),this.activation=Ws(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=jt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=fe(t.kernelConstraint),this.biasConstraint=fe(t.biasConstraint),this.kernelRegularizer=qt(t.kernelRegularizer),this.biasRegularizer=qt(t.biasRegularizer),this.activityRegularizer=qt(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Lt(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Lt(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t),r=qb(this.activation.getClassName()),o;return r!=null?o=Jn(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=Jn(s,this.kernel.read()),this.bias!=null&&(o=Zn(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){let t={units:this.units,activation:Vs(this.activation),useBias:this.useBias,kernelInitializer:Qt(this.kernelInitializer),biasInitializer:Qt(this.biasInitializer),kernelRegularizer:Pt(this.kernelRegularizer),biasRegularizer:Pt(this.biasRegularizer),activityRegularizer:Pt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),biasConstraint:pe(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}pm.className="Dense",X(pm);class fm extends Tt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Lt(t);for(let e of t.slice(1))if(e==null)throw new R(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Ls(t,1)]}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){let r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=s.transpose(r)}return nA(s)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}}fm.className="Flatten",X(fm);class mm extends Tt{constructor(t){super(t);this.supportsMasking=!0,this.activation=Ws(t.activation)}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);return this.activation.apply(s)})}getConfig(){let t={activation:Vs(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}mm.className="Activation",X(mm);class gm extends Tt{constructor(t){super(t);this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return O(()=>(t=wt(t),tA(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}gm.className="RepeatVector",X(gm);class ym extends Tt{constructor(t){super(t);this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let s="Total size of new array must be unchanged.",r=e.slice(),o=1,a=null;for(let l=0;l<r.length;++l){let c=r[l];if(this.isUnknown(c))if(a===null)a=l;else throw new R("Can only specifiy one unknown dimension.");else o*=c}let i=Ls(t);if(a!==null){if(o===0||i%o!=0)throw new R(s);r[a]=i/o}else if(i!==o)throw new R(s);return r}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return s.reshape(o)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}ym.className="Reshape",X(ym);class bm extends Tt{constructor(t){super(t);if(t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=An(1,t.dims.length+1);if(!At(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ve({ndim:this.dims.length+1})]}computeOutputShape(t){t=Lt(t);let e=t.slice();return this.dims.forEach((s,r)=>{e[r+1]=t[s]}),e}call(t,e){return Rt(wt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}bm.className="Permute",X(bm);class xm extends Tt{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let s=wt(t),r=-1;return Hi(yr(s,this.maskValue),r)}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t),r=-1,o=!0,a=Hi(yr(s,this.maskValue),r,o);return s.mul(a.asType(s.dtype))})}}xm.className="Masking",X(xm);class wm extends Tt{constructor(t){super(t);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Mt(t.inputLength))}this.inputDim=t.inputDim,$e(this.inputDim,"inputDim"),this.outputDim=t.outputDim,$e(this.outputDim,"outputDim"),this.embeddingsInitializer=jt(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qt(t.embeddingsRegularizer),this.activityRegularizer=qt(t.activityRegularizer),this.embeddingsConstraint=fe(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return O(()=>this.maskZero?(t=wt(t),yr(t,Ct(t))):null)}computeOutputShape(t){if(t=Lt(t),this.inputLength==null)return[...t,this.outputDim];let e=Mt(this.inputLength);if(e.length!==t.length-1)throw new R(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<e.length;++r){let o=e[r],a=t[r+1];if(o!=null&&a!=null&&o!==a)throw new R(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);o==null&&(e[s]=a),s++}}return[t[0],...e,this.outputDim]}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);return s.dtype!=="int32"&&(s=Cl(s,"int32")),sx(this.embeddings.read(),s.as1D()).reshape(Lt(this.computeOutputShape(s.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Qt(this.embeddingsInitializer),embeddingsRegularizer:Pt(this.embeddingsRegularizer),activityRegularizer:Pt(this.activityRegularizer),embeddingsConstraint:pe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}wm.className="Embedding",X(wm);class Dr extends Tt{constructor(t){super(t||{});this.supportsMasking=!0}mergeFunction(t){throw new gt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){let o=t[t.length-e.length+r],a=e[r];if(o==null||a==null||o<0||a<0)s.push(null);else if(o===1)s.push(a);else if(a===1)s.push(o);else{if(o!==a)throw new R("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(o)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Lt(t)]),t=t,t.length<2)throw new R(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let o of t)o!=null&&o[0]!==null&&e.push(o[0]);if(e=Os(e),e.length>1)throw new R(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let o=1;o<t.length;++o){let a=t[o]==null?null:t[o].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}let r=t.map(o=>o.length);t.indexOf(null)===-1&&Os(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return O(()=>{if(t=t,this.reshapeRequired){let s=[],r=t.map(o=>o.rank);if(r.indexOf(null)===-1){let o=Ps(r);for(let a of t){let i=a.rank;for(let l=0;l<o-i;++l)a=Nl(a,1);s.push(a)}return this.mergeFunction(s)}else{let o=!1;for(let l of t){let c=l.rank;if(c==null){let u=l.shape,h=u[0],d=u.slice(1).concat([h]),p=l.reshape([h].concat(Ls(u.slice(1))));p=Rt(p,[1,0]),p=p.reshape(d),s.push(p),o=!0}else if(c>1){let u=An(1,c).concat([0]);s.push(Rt(l,u)),o=!0}else s.push(l)}let a=this.mergeFunction(s),i=a.rank;if(o){if(i==null){let l=a.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));a=Rt(a.reshape([-1,u]),[1,0]).reshape(h)}else if(i>1){let l=[i-1].concat(An(0,i-1));a=Rt(a,l)}}return a}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){let o=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let s=[];for(let r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=Os(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return O(()=>{if(e==null)return null;if(!Array.isArray(e))throw new R("`mask` should be an Array");if(!Array.isArray(t))throw new R("`inputs` should be an Array");if(e.length!==t.length)throw new R(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:je(r,0));let s=e[0];for(let r=1;r<e.length-1;++r)s=gn(s,e[r]);return s})}}class Ol extends Dr{constructor(t){super(t)}mergeFunction(t){return O(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Z(e,t[s]);return e})}}Ol.className="Add",X(Ol);function DX(n){return Array.isArray(n)?new Ol({}).apply(n):new Ol(n)}class Ll extends Dr{constructor(t){super(t)}mergeFunction(t){return O(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=_(e,t[s]);return e})}}Ll.className="Multiply",X(Ll);function RX(n){return Array.isArray(n)?new Ll({}).apply(n):new Ll(n)}class Pl extends Dr{constructor(t){super(t)}mergeFunction(t){return O(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Z(e,t[s]);return _(1/t.length,e)})}}Pl.className="Average",X(Pl);function FX(n){return Array.isArray(n)?new Pl({}).apply(n):new Pl(n)}class zl extends Dr{constructor(t){super(t)}mergeFunction(t){return O(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=jn(e,t[s]);return e})}}zl.className="Maximum",X(zl);function _X(n){return Array.isArray(n)?new zl({}).apply(n):new zl(n)}class Ml extends Dr{constructor(t){super(t)}mergeFunction(t){return O(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Zo(e,t[s]);return e})}}Ml.className="Minimum",X(Ml);function OX(n){return Array.isArray(n)?new Ml({}).apply(n):new Ml(n)}class Bl extends Dr{constructor(t){super(t);this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new R("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let r of t)if(r!=null){e=!1;break}if(e)return;let s=[];for(let r=0;r<t.length;++r){let o=t[r].slice();o.splice(this.axis,1);let a=!1;for(let i of s)if(At(i,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new R("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return O(()=>wf(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new R("A `Concatenate` layer should be called on a list of inputs.");let e=t,s=e[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(let o of e.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new R("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new R("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new R(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return O(()=>{let s=!0;if(e.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;let r=[];for(let a=0;a<t.length;++a)e[a]==null?r.push(Le(t[a]).asType("bool")):e[a].rank<t[a].rank?r.push(je(e[a],-1)):r.push(e[a]);let o=ee(r,this.axis);return yu(o,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}Bl.className="Concatenate",X(Bl);function LX(n){return Array.isArray(n)?new Bl({}).apply(n):new Bl(n)}function Vl(n,t){for(;n<0;)n+=t;return n}function _D(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new gt("batchDot is not implemented for tensors of 4D or higher rank yet");if(N(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),N(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new gt("batchDot is not implemented for complex64-type Tensors yet.");let s=n.shape.length,r=t.shape.length;e==null&&(e=[s-1,r-2]);let o=e;return O(()=>{let a;if(s>r){a=s-r;let l=[];for(let c=0;c<a;++c)l.push(1);t=t.reshape(t.shape.concat(l))}else if(r>s){a=r-s;let l=[];for(let c=0;c<a;++c)l.push(1);n=n.reshape(n.shape.concat(l))}else a=0;let i;if(n.shape.length===2&&t.shape.length===2)o[0]===o[1]?i=n.mul(t).sum(o[0]):i=n.transpose([1,0]).mul(t).sum(o[1]);else{let l=o[0]!==n.shape.length-1,c=o[1]===t.shape.length-1;i=n.matMul(t,l,c)}if(a>0){let l;s>r?l=s+r-3:l=s-1;let c=[];for(let u=l;u<l+a;++u)c.push(u);i=i.squeeze(c)}return i.shape.length===1&&(i=i.expandDims(1)),i})}class $m extends Dr{constructor(t){super(t);this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){N(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],s=t[1];if(e.length>3||s.length>3)throw new gt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(e,s);if(e[r[0]]!==s[r[1]])throw new R(`Dimension incompatibility: ${e[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new R(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,a)=>Vl(o,t[a].shape.length)):r=[Vl(this.axes,e.shape.length),Vl(this.axes,s.shape.length)],this.normalize&&(e=wh(e,r[0]),s=wh(s,r[1])),_D(e,s,r)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Vl(this.axes,t.length),Vl(this.axes,e.length)],s}computeOutputShape(t){N(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new gt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(e,s);e.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);let o=e.concat(s);return o.length===1&&o.push(1),o}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}$m.className="Dot",X($m);class vm extends Tt{constructor(t){super(t);this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);return Il(()=>ih(s.shape,0,this.stddev).add(s),()=>s,e.training||!1)})}}vm.className="GaussianNoise",X(vm);class Cm extends Tt{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return O(()=>{this.invokeCallHook(t,e);let s=wt(t);return this.rate>0&&this.rate<1?Il(()=>{let o=Math.sqrt(this.rate/(1-this.rate));return s.mul(ih(s.shape,1,o))},()=>s,e.training||!1):s})}}Cm.className="GaussianDropout",X(Cm);class Nm extends Tt{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||wt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return O(()=>{if(this.rate<1&&this.rate>0){let s=this._getNoiseShape(t);return Il(()=>{let o=wt(t),a=1.6732632423543772,i=1.0507009873554805,l=-a*i,c=Rs(wr(s),this.rate);c=Cl(c,"float32");let u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate;return o.mul(c).add(c.add(-1).mul(l)).mul(u).add(h)},()=>wt(t),e.training||!1)}return t})}}Nm.className="AlphaDropout",X(Nm);function Wl(n,t,e,s,r,o=.001){let a;if(n.rank===2)a=Wy(n,t,e,s,r,o);else if(n.rank===3)a=Uy(n,t,e,s,r,o);else if(n.rank===4)a=Gy(n,t,e,s,r,o);else throw new gt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function OD(n,t,e,s,r=.001){return O(()=>{let o=Au(n,s),a=o.mean,i=o.variance;return[Wl(n,a,i,e,t,r),a,i]})}function LD(n,t,e,s,r=.001){return O(()=>{let o=Au(n,s),a=o.mean,i=o.variance,l=[];for(let f of An(0,n.rank))s.indexOf(f)!==-1?l.push(1):l.push(n.shape[f]);let c=a.reshape(l),u=i.reshape(l),h=t==null?null:t.reshape(l),d=e==null?null:e.reshape(l);return[Wl(n,c,u,d,h,r),a,i]})}function PD(n,t,e,s,r=.001){return At(s.slice().sort(),An(0,n.rank-1))?OD(n,t,e,s,r):LD(n,t,e,s,r)}class km extends Tt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=jt(t.betaInitializer||"zeros"),this.gammaInitializer=jt(t.gammaInitializer||"ones"),this.movingMeanInitializer=jt(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jt(t.movingVarianceInitializer||"ones"),this.betaConstraint=fe(t.betaConstraint),this.gammaConstraint=fe(t.gammaConstraint),this.betaRegularizer=qt(t.betaRegularizer),this.gammaRegularizer=qt(t.gammaRegularizer)}build(t){t=Lt(t);let e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new R(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ve({ndim:t.length,axes:{[e]:s}})];let r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return O(()=>{let s=e.training==null?!1:e.training,r=wt(t),o=r.shape,a=o.length,i=An(0,a),l=this.axis>=0?this.axis:this.axis+a;i.splice(l,1);let c=Nr(1,a);c[l]=o[l];let u=i.slice();u.sort();let h=!At(u,An(0,a).slice(0,a-1)),d=()=>{if(h){let b=this.movingMean.read().reshape(c),C=this.movingVariance.read().reshape(c),w=this.center?this.beta.read().reshape(c):null,v=this.scale?this.gamma.read().reshape(c):null;return Wl(r,b,C,w,v,this.epsilon)}else return Wl(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();let[p,f,m]=PD(r,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(b,C,w)=>{O(()=>{let v=1-w,I=b.read(),k=I.sub(C).mul(v);b.write(I.sub(k))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Qt(this.betaInitializer),gammaInitializer:Qt(this.gammaInitializer),movingMeanInitializer:Qt(this.movingMeanInitializer),movingVarianceInitializer:Qt(this.movingVarianceInitializer),betaRegularizer:Pt(this.betaRegularizer),gammaRegularizer:Pt(this.gammaRegularizer),betaConstraint:pe(this.betaConstraint),gammaConstraint:pe(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}km.className="BatchNormalization",X(km);class Im extends Tt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=jt(t.betaInitializer||"zeros"),this.gammaInitializer=jt(t.gammaInitializer||"ones"),this.betaRegularizer=qt(t.betaRegularizer),this.gammaRegularizer=qt(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Lt(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=e);for(let o of this.axis)if(o<0||o>=e)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==Os(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let s=this.axis.map(o=>t[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){let s=wt(t),r=s.shape,o=r.length;return O(()=>{let a=!0,{mean:i,variance:l}=Au(s,this.axis,a),c=Nr(1,o);for(let m of this.axis)c[m]=r[m];let u=m=>m!=null&&m.shape.length!==o&&this.axis!==[o-1]?m.reshape(c):m,h=u(this.gamma.read()),d=u(this.beta.read()),p=[],f=[];for(let m=0;m<o;++m)this.axis.indexOf(m)!==-1?(p.push(r[m]),f.push(1)):(p.push(1),f.push(r[m]));return i=i.tile(p),l=l.tile(p),h=h.tile(f),d=d.tile(f),Wl(s,i,l,d,h,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Qt(this.betaInitializer),gammaInitializer:Qt(this.gammaInitializer),betaRegularizer:Pt(this.betaRegularizer),gammaRegularizer:Pt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Im.className="LayerNormalization",X(Im);function PX(n,t){return O(()=>{if(n.rank!==3)throw new R(`temporalPadding expects input tensor to be 3-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[1,1]),t.length!==2)throw new R(`temporalPadding expects input padding pattern to be a length-2 array, but received a length-${t.length} array.`);return qn(n,[[0,0],t,[0,0]])})}function zD(n,t,e){return O(()=>{if(n.rank!==4)throw new R(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new R("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=En()),e!=="channelsLast"&&e!=="channelsFirst")throw new R(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],qn(n,s)})}class Sm extends Tt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?En():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new R(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new R(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new R(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Lt(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return O(()=>zD(wt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Sm.className="ZeroPadding2D",X(Sm);function Lh(n,t,e,s,r,o){return O(()=>{Ht(r),Yb(o),un(s),e==null&&(e=[1,1]),s==null&&(s="valid"),r==null&&(r=En()),o==null&&(o="max"),n=em(n,r);let a,i=s==="same"?"same":"valid";return o==="max"?a=nl(n,t,e,i):a=Ki(n,t,e,i),r==="channelsFirst"&&(a=Rt(a,[0,3,1,2])),a})}function lw(n,t,e,s,r,o){return O(()=>{Ht(r),Yb(o),un(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),r==null&&(r=En()),o==null&&(o="max"),n=ew(n,r);let a,i=s==="same"?"same":"valid";return o==="max"?a=Sp(n,t,e,i):a=fp(n,t,e,i),r==="channelsFirst"&&(a=Rt(a,[0,4,1,2,3])),a})}class cw extends Tt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new R(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if($e(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new R(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);$e(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,un(this.padding),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){t=Lt(t);let e=On(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return O(()=>{this.invokeCallHook(t,e),t=Nl(wt(t),2);let s=this.poolingFunction(wt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Fs(s,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Tm extends cw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),Lh(t,e,s,r,o,"max")}}Tm.className="MaxPooling1D",X(Tm);class Em extends cw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),Lh(t,e,s,r,o,"avg")}}Em.className="AveragePooling1D",X(Em);class uw extends Tt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new R(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];$e(this.poolSize,"poolSize"),$e(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ht(this.dataFormat),un(this.padding),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Lt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=On(e,this.poolSize[0],this.padding,this.strides[0]),s=On(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return O(()=>(this.invokeCallHook(t,e),this.poolingFunction(wt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Am extends uw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),Lh(t,e,s,r,o,"max")}}Am.className="MaxPooling2D",X(Am);class Dm extends uw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),Lh(t,e,s,r,o,"avg")}}Dm.className="AveragePooling2D",X(Dm);class hw extends Tt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new R(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];$e(this.poolSize,"poolSize"),$e(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ht(this.dataFormat),un(this.padding),this.inputSpec=[new ve({ndim:5})]}computeOutputShape(t){t=Lt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=On(e,this.poolSize[0],this.padding,this.strides[0]),s=On(s,this.poolSize[1],this.padding,this.strides[1]),r=On(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return O(()=>(this.invokeCallHook(t,e),this.poolingFunction(wt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Rm extends hw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),lw(t,e,s,r,o,"max")}}Rm.className="MaxPooling3D",X(Rm);class Fm extends hw{constructor(t){super(t)}poolingFunction(t,e,s,r,o){return Ht(o),un(r),lw(t,e,s,r,o,"avg")}}Fm.className="AveragePooling3D",X(Fm);class dw extends Tt{constructor(t){super(t);this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new gt}}class _m extends dw{constructor(t){super(t||{})}call(t,e){return O(()=>{let s=wt(t);return Zt(s,1)})}}_m.className="GlobalAveragePooling1D",X(_m);class Om extends dw{constructor(t){super(t||{})}call(t,e){return O(()=>{let s=wt(t);return ln(s,1)})}}Om.className="GlobalMaxPooling1D",X(Om);class pw extends Tt{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ht(this.dataFormat),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new gt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Lm extends pw{call(t,e){return O(()=>{let s=wt(t);return this.dataFormat==="channelsLast"?Zt(s,[1,2]):Zt(s,[2,3])})}}Lm.className="GlobalAveragePooling2D",X(Lm);class Pm extends pw{call(t,e){return O(()=>{let s=wt(t);return this.dataFormat==="channelsLast"?ln(s,[1,2]):ln(s,[2,3])})}}Pm.className="GlobalMaxPooling2D",X(Pm);class fw extends Tt{constructor(t){super(t);this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){let r=e.layer,o=Fn(r,s);delete e.layer;let a={layer:o};return Object.assign(a,e),new t(a)}}class zm extends fw{constructor(t){super(t);this.supportsMasking=!0}build(t){if(t=Lt(t),t.length<3)throw new R(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Lt(t);let e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,e){return O(()=>(t=wt(t),aw((a,i)=>[wt(this.layer.call(a,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}zm.className="TimeDistributed",X(zm);function MD(n){Ir(q2,"BidirectionalMergeMode",n)}let BD="concat";class Mm extends fw{constructor(t){super(t);let e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=Fn(s),e.goBackwards=e.goBackwards!==!0;let r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=Fn(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?BD:t.mergeMode,MD(this.mergeMode),t.weights)throw new gt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,r,o;return this.returnState&&(o=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Be(r)}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});let o=ow(t,s,r,this.numConstants);if(t=o.inputs,s=o.initialState,r=o.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,e);let a=[],i=[];if(s!=null){let c=s.length;if(c%2>0)throw new R("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,a.push(...s);let u=s.map(h=>new ve({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),i.push(...u)}if(r!=null)throw new gt("Support for constants in Bidirectional layers is not implemented yet.");let l=a[0]instanceof Rn;for(let c of a)if(c instanceof Rn!==l)throw new R("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let c=[t].concat(a),u=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=u;let d=super.apply(c,e);return this.inputSpec=h,d}else return super.apply(t,e)}call(t,e){return O(()=>{let s=e.initialState,r,o;if(s==null)r=this.forwardLayer.call(t,e),o=this.backwardLayer.call(t,e);else{let l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),o=this.backwardLayer.call(t,Object.assign(e,{initialState:c}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=Ke(o,1));let i;return this.mergeMode==="concat"?i=wf([r,o]):this.mergeMode==="sum"?i=Z(r,o):this.mergeMode==="ave"?i=_(.5,Z(r,o)):this.mergeMode==="mul"?i=_(r,o):this.mergeMode==null&&(i=[r,o]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Sr(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Sr(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){let o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let s=Fn(e.layer);if(delete e.layer,e.numConstants!=null)throw new gt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=e;return r.layer=s,new t(r)}}Mm.className="Bidirectional",X(Mm);function VD(n){return new la(n)}function WD(n){return new Zf(n)}function UD(n){return new Xf(n)}function GD(n){return new Yf(n)}function HD(n){return new Jf(n)}function jD(n){return new tm(n)}function qD(n){return new Qf(n)}function KD(n){return new Fl(n)}function XD(n){return new pa(n)}function YD(n){return new sm(n)}function JD(n){return new Rl(n)}function ZD(n){return new rm(n)}function QD(n){return new om(n)}function tR(n){return new am(n)}function eR(n){return new im(n)}function nR(n){return new mm(n)}function sR(n){return new pm(n)}function rR(n){return new Oh(n)}function oR(n){return new dm(n)}function aR(n){return new fm(n)}function iR(n){return new gm(n)}function lR(n){return new ym(n)}function cR(n){return new bm(n)}function uR(n){return new wm(n)}function hR(n){return new Ol(n)}function dR(n){return new Pl(n)}function pR(n){return new Bl(n)}function fR(n){return new zl(n)}function mR(n){return new Ml(n)}function gR(n){return new Ll(n)}function yR(n){return new $m(n)}function bR(n){return new km(n)}function xR(n){return new Im(n)}function wR(n){return new Sm(n)}function Bm(n){return new Em(n)}function $R(n){return Bm(n)}function vR(n){return Bm(n)}function Vm(n){return new Dm(n)}function CR(n){return Vm(n)}function NR(n){return Vm(n)}function Wm(n){return new Fm(n)}function kR(n){return Wm(n)}function IR(n){return Wm(n)}function SR(n){return new _m(n)}function TR(n){return new Lm(n)}function mw(n){return new Om(n)}function gw(n){return new Pm(n)}function yw(n){return new Tm(n)}function bw(n){return new Am(n)}function ER(n){return new Rm(n)}function AR(n){return new cm(n)}function DR(n){return new Rh(n)}function RR(n){return new um(n)}function FR(n){return new _l(n)}function _R(n){return new lm(n)}function OR(n){return new Dh(n)}function LR(n){return new hm(n)}function PR(n){return new _h(n)}function zR(n){return new Ln(n)}function MR(n){return new Fh(n)}function BR(n){return new Mm(n)}function VR(n){return new zm(n)}let WR=mw,UR=gw,GR=yw,HR=bw;function jR(n){return new vm(n)}function qR(n){return new Cm(n)}function KR(n){return new Nm(n)}function XR(n){return new xm(n)}var YR=Object.freeze({__proto__:null,inputLayer:VD,elu:WD,reLU:UD,leakyReLU:GD,prelu:HD,softmax:jD,thresholdedReLU:qD,conv1d:KD,conv2d:XD,conv2dTranspose:YD,conv3d:JD,separableConv2d:ZD,cropping2D:QD,upSampling2d:tR,depthwiseConv2d:eR,activation:nR,dense:sR,dropout:rR,spatialDropout1d:oR,flatten:aR,repeatVector:iR,reshape:lR,permute:cR,embedding:uR,add:hR,average:dR,concatenate:pR,maximum:fR,minimum:mR,multiply:gR,dot:yR,batchNormalization:bR,layerNormalization:xR,zeroPadding2d:wR,averagePooling1d:Bm,avgPool1d:$R,avgPooling1d:vR,averagePooling2d:Vm,avgPool2d:CR,avgPooling2d:NR,averagePooling3d:Wm,avgPool3d:kR,avgPooling3d:IR,globalAveragePooling1d:SR,globalAveragePooling2d:TR,globalMaxPooling1d:mw,globalMaxPooling2d:gw,maxPooling1d:yw,maxPooling2d:bw,maxPooling3d:ER,gru:AR,gruCell:DR,lstm:RR,lstmCell:FR,simpleRNN:_R,simpleRNNCell:OR,convLstm2d:LR,convLstm2dCell:PR,rnn:zR,stackedRNNCells:MR,bidirectional:BR,timeDistributed:VR,globalMaxPool1d:WR,globalMaxPool2d:UR,maxPool1d:GR,maxPool2d:HR,Layer:Tt,RNN:Ln,RNNCell:fa,input:Mx,gaussianNoise:jR,gaussianDropout:qR,alphaDropout:KR,masking:XR});function JR(n,t){return Lf(n,t)}function ZR(n,t){return wx(n,t)}function QR(n,t){return $x(n,t)}function tF(n,t){return Pf(n,t)}function eF(n,t){return zf(n,t)}function nF(n,t){return xx(n,t)}function sF(n,t){return UA(n,t)}function rF(n,t){return Ch(n,t)}function oF(n,t){return ua(n,t)}function aF(n,t){return Ms(n,t)}function iF(n,t){return Ms(n,t)}function lF(n,t){return Ms(n,t)}function cF(n,t){return ms(n,t)}function uF(n,t){return ms(n,t)}function hF(n,t){return ms(n,t)}var dF=Object.freeze({__proto__:null,binaryAccuracy:JR,binaryCrossentropy:ZR,sparseCategoricalAccuracy:QR,categoricalAccuracy:tF,categoricalCrossentropy:eF,precision:nF,recall:sF,cosineProximity:rF,meanAbsoluteError:oF,meanAbsolutePercentageError:aF,MAPE:iF,mape:lF,meanSquaredError:cF,MSE:uF,mse:hF});var pF=Object.freeze({__proto__:null,modelFromJSON:vD});function fF(n){return new Dl(n)}function mF(n){return AD(n)}function gF(n){return DD(n)}var yF=Object.freeze({__proto__:null,l1l2:fF,l1:mF,l2:gF});class xw extends ca{constructor(){super(...arguments);this.model=null}setModel(t){if(!(t instanceof gs))throw new Error("model must be a LayersModel, not some other Container");this.model=t}}function Ph(n,t){return n<t}function ww(n,t){return n>t}class $w extends xw{constructor(t){super();if(t==null&&(t={}),t.restoreBestWeights)throw new gt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Ph:this.mode==="max"?this.monitorFunc=ww:this.monitor.indexOf("acc")!==-1?this.monitorFunc=ww:this.monitorFunc=Ph,this.monitorFunc===Ph&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Ph?Infinity:-Infinity}async onEpochEnd(t,e){await zs(e);let s=this.getMonitorValue(e);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}}function bF(n){return new $w(n)}let xF={earlyStopping:bF};var Pn;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Pn||(Pn={}));var vw;(function(n){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(vw||(vw={}));let Um={};function wF(n,t){let e={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:t};Um[n]=e}function Cw(n){return Um[n]}function $F(n){delete Um[n]}function $(n,t,e,s,r){let o=t.inputParams[n];if(o&&o.inputIndexStart!==void 0){let i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return We(t.inputNames[o.inputIndexStart],e,s,r);if(o.type==="tensors")return t.inputNames.slice(i,l).map(d=>We(d,e,s,r));let c=We(t.inputNames.slice(i)[0],e,s,r),u=c.dataSync();return o.type==="number"?u[0]:sn(c.shape,u)}let a=t.attrParams[n];return a&&a.value}function We(n,t,e,s){let[r,o]=Qe(n);if(s!=null){let i=s.getHashTableHandleByName(r);if(i!=null)return i}let a=e.currentContextIds.find(i=>!!t[zh(r,i)]);return a!==void 0?t[zh(r,a)][o]:void 0}function vF(n,t,e){return t[zh(n,e.currentContextId)]}function ys(n,t){let[e,s]=Qe(n);return[zh(e,t&&t.currentContextId),s]}function zh(n,t){return t?`${n}-${t}`:n}function Qe(n){let t=n.split(":");return t.length===1?[n,0]:[t[0],Number(t[t.length-1])]}function zX(n,t){let e=[];for(let s=0;s<n.length;s+=t)e.push(n.slice(s,s+t));return e}function Mh(n,t,e){let s=$("pad",n,t,e);if(s==="explicit"){s=$("explicitPaddings",n,t,e);let r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function bs(n){return n.kept?n:Ts(n)}var CF=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var NF=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),kF=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var IF=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var SF=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var TF=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var EF=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var AF=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]}),DF=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}]});var RF=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var FF=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var _F=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var OF=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var LF=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var PF=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var zF=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var MF=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class Nw{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[CF,NF,kF,IF,SF,TF,EF,FF,RF,AF,_F,OF,LF,PF,zF,MF,DF],e=[].concat(...t.map(s=>s.json));this.opMappers=e.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,e={}){let s=t.node,r=[],o=[],a=[],i=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{}),l=[],c=[],u={},h={};e!=null&&(u=this.mapSignatureEntries(e.inputs),h=this.mapSignatureEntries(e.outputs));let d=Object.keys(i);d.forEach(m=>{let g=i[m];g.inputNames.forEach(y=>{let[b]=ys(y);g.inputs.push(i[b]),i[b].children.push(g)})}),Object.keys(h).length===0?d.forEach(m=>{let g=i[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{let[g]=ys(m),y=i[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{let[g]=ys(m),y=i[g];y&&(y.signatureKey=u[m],l.push(y))}):l=r;let p={};t.library!=null&&t.library.function!=null&&(p=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));let f={nodes:i,inputs:l,outputs:c,weights:o,placeholders:r,signature:e,functions:p};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){let e=Cw(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.substr(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return e.inputs!=null&&(s.inputParams=e.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),e.attrs!=null&&(s.attrParams=e.attrs.reduce((r,o)=>{let a=o.type,i;switch(o.type){case"string":i=Gm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Gm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=Zm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Zm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=jm(t.attr,o.tfName,o.defaultValue||0),i===void 0&&!!o.tfDeprecatedName&&(i=jm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=Jm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Jm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=Hm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Hm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=tg(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=tg(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=Ym(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ym(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=Qm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Qm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=Km(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Km(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=Xm(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Xm(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=Iw(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Iw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return r[o.name]={value:i,type:a},r},{})),s}mapFunction(t){let e=t.nodeDef,s=[],r=[],o={};e!=null&&(o=e.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));let a=[],i=[];t.signature.inputArg.forEach(h=>{let[d]=ys(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:qm(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,a.push(p),o[d]=p}),Object.keys(o).forEach(h=>{let d=o[h];d.inputNames.forEach(p=>{let[f]=ys(p);d.inputs.push(o[f]),o[f].children.push(d)})});let c=t.ret;t.signature.outputArg.forEach(h=>{let[d,p]=ys(c[h.name]),f=o[d];f!=null&&(f.defaultOutput=p,i.push(f))});let u=this.mapArgsToSignature(t);return{nodes:o,inputs:a,outputs:i,weights:r,placeholders:s,signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return e!=null&&(s=e[s]),{name:s,dtype:t.type}}}function BF(n){let t=G().global;if(typeof t.atob!="undefined")return t.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function kw(n,t){let e=Array.isArray(n)?String.fromCharCode.apply(null,n):BF(n);return t?e:e.toLowerCase()}function Gm(n,t,e,s=!1){let r=n[t];return r!=null?kw(r.s,s):e}function Hm(n,t,e){let s=n[t];return s?s.b:e}function jm(n,t,e){let s=n[t]||{},r=s.i!=null?s.i:s.f!=null?s.f:e;return typeof r=="number"?r:parseInt(r,10)}function qm(n){switch(typeof n=="string"&&(n=Pn[n]),n){case Pn.DT_FLOAT:return"float32";case Pn.DT_INT32:case Pn.DT_INT64:case Pn.DT_INT8:case Pn.DT_UINT8:return"int32";case Pn.DT_BOOL:return"bool";case Pn.DT_DOUBLE:return"float32";case Pn.DT_STRING:return"string";default:return null}}function Iw(n,t,e){let s=n[t];return s&&s.func?s.func.name:e}function Km(n,t,e){let s=n[t];return s&&s.type?qm(s.type):e}function Xm(n,t,e){let s=n[t];return s&&s.list&&s.list.type?s.list.type.map(r=>qm(r)):e}function Sw(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Ym(n,t,e){let s=n[t];return s&&s.shape?Sw(s.shape):e}function Jm(n,t,e){let s=n[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):e}function Zm(n,t,e,s=!1){let r=n[t];return r&&r.list&&r.list.s?r.list.s.map(o=>kw(o,s)):e}function Qm(n,t,e){let s=n[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>Sw(r)):e}function tg(n,t,e){let s=n[t];return s&&s.list&&s.list.b?s.list.b:e}class VF{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(t){return We(t,this.tensorMap,this.context)}getAttr(t,e){let s=this.node.rawAttrs[t];if(s.tensor!=null)return We(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return jm(this.node.rawAttrs,t,e);if(s.s!=null)return Gm(this.node.rawAttrs,t,e);if(s.b!=null)return Hm(this.node.rawAttrs,t,e);if(s.shape!=null)return Ym(this.node.rawAttrs,t,e);if(s.type!=null)return Km(this.node.rawAttrs,t,e);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Jm(this.node.rawAttrs,t,e);if(s.list.s!=null)return Zm(this.node.rawAttrs,t,e);if(s.list.shape!=null)return Qm(this.node.rawAttrs,t,e);if(s.list.b!=null)return tg(this.node.rawAttrs,t,e);if(s.list.type!=null)return Xm(this.node.rawAttrs,t,e)}return e}}let WF=(n,t,e)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[Z($("a",n,t,e),$("b",n,t,e))];case"AddN":return[Vy($("tensors",n,t,e))];case"FloorMod":case"Mod":return[Ep($("a",n,t,e),$("b",n,t,e))];case"Mul":return[_($("a",n,t,e),$("b",n,t,e))];case"RealDiv":case"Div":return[dt($("a",n,t,e),$("b",n,t,e))];case"DivNoNan":return[wp($("a",n,t,e),$("b",n,t,e))];case"FloorDiv":return[gu($("a",n,t,e),$("b",n,t,e))];case"Sub":return[at($("a",n,t,e),$("b",n,t,e))];case"Minimum":return[Zo($("a",n,t,e),$("b",n,t,e))];case"Maximum":return[jn($("a",n,t,e),$("b",n,t,e))];case"Pow":return[Kn($("a",n,t,e),$("b",n,t,e))];case"SquaredDifference":return[Vu($("a",n,t,e),$("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},n5="arithmetic";let UF=(n,t,e)=>{switch(n.op){case"Abs":case"ComplexAbs":return[ue($("x",n,t,e))];case"Acos":return[rp($("x",n,t,e))];case"Acosh":return[op($("x",n,t,e))];case"Asin":return[ip($("x",n,t,e))];case"Asinh":return[lp($("x",n,t,e))];case"Atan":return[cp($("x",n,t,e))];case"Atan2":return[up($("x",n,t,e),$("y",n,t,e))];case"Atanh":return[hp($("x",n,t,e))];case"Ceil":return[mp($("x",n,t,e))];case"Complex":return[ks($("real",n,t,e),$("imag",n,t,e))];case"Cos":return[Ji($("x",n,t,e))];case"Cosh":return[$u($("x",n,t,e))];case"Elu":return[qo($("x",n,t,e))];case"Erf":return[$p($("x",n,t,e))];case"Exp":return[on($("x",n,t,e))];case"Expm1":return[vp($("x",n,t,e))];case"Floor":return[Ko($("x",n,t,e))];case"Log":return[qe($("x",n,t,e))];case"Log1p":return[Iu($("x",n,t,e))];case"Imag":return[Nu($("x",n,t,e))];case"Neg":return[Jt($("x",n,t,e))];case"Reciprocal":return[Fp($("x",n,t,e))];case"Real":return[ol($("x",n,t,e))];case"Relu":return[Xn($("x",n,t,e))];case"Round":return[_p($("x",n,t,e))];case"Selu":return[Ou($("x",n,t,e))];case"Sigmoid":return[Gn($("x",n,t,e))];case"Sin":return[Lu($("x",n,t,e))];case"Sign":return[Lp($("x",n,t,e))];case"Sinh":return[Pu($("x",n,t,e))];case"Softplus":return[Xo($("x",n,t,e))];case"Sqrt":return[Ae($("x",n,t,e))];case"Square":return[Ot($("x",n,t,e))];case"Tanh":return[Ho($("x",n,t,e))];case"Tan":return[Mp($("x",n,t,e))];case"ClipByValue":return[Me($("x",n,t,e),$("clipValueMin",n,t,e),$("clipValueMax",n,t,e))];case"Relu6":return[Fu($("x",n,t,e))];case"Rsqrt":return[_u(We(n.inputNames[0],t,e))];case"Prod":return[Du($("x",n,t,e),$("axes",n,t,e))];case"LeakyRelu":return[tl($("x",n,t,e),$("alpha",n,t,e))];case"Prelu":return[rl($("x",n,t,e),$("alpha",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},s5="basic_math";function $n(n,t,e=""){if(!(typeof n=="number"||typeof t=="number")){N(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let s=0;s<n.length;s++){let r=n[s],o=t[s];N(r<0||o<0||r===o,()=>e+` Shapes ${n} and ${t} must match`)}}}function Tw(n){return!(typeof n=="number"||n.some(t=>t<0))}function Ul(n,t,e){let s=eg(n,e),r=!Tw(s);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(o=>{s=eg(o.shape,s)}),!Tw(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function eg(n,t){if(typeof n=="number")return t;if(typeof t=="number")return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);let e=[];for(let s=0;s<n.length;++s){let r=n[s],o=t[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[s]=r>=0?r:o}return e}class GF{constructor(t,e,s,r,o,a,i){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=ut(0),be(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),$n(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,be(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,r)=>this.write(s,e[r]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return Sn([],[0].concat(this.elementShape));let s=this.readMany(t);return $n(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Ye(s,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Sn([],[0].concat(this.elementShape));let e=[];for(let r=0;r<this.size();r++)e.push(r);let s=this.readMany(e);return $n(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ee(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,yn(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0,r=t.map(l=>(s+=l,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let o=s===0?0:e.size/s,a=[];O(()=>{e=L(e,[1,s,o]);for(let l=0;l<t.length;++l){let c=l===0?0:r[l-1],u=[0,c,0],h=[1,t[l],o];a[l]=L(St(e,u,h),this.elementShape)}return a});let i=[];for(let l=0;l<t.length;l++)i[l]=l;this.writeMany(i,a)}}class ma{constructor(t,e,s,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t!=null&&t.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);$n(e,o.shape,"TensorList shape mismatch: "),be(o)}),this.idTensor=ut(0),this.maxNumElements=r,be(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ma([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);$n(t,this.elementShape,"TensorList shape mismatch: ");let r=Ul(this.elementShape,this.tensors,t);return O(()=>{let o=this.tensors.map(a=>L(a,r));return Ye(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let s=Ul(this.elementShape,this.tensors,t),r=this.tensors.pop();return $n(r.shape,t,"TensorList shape mismatch: "),L(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if($n(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");be(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);$n(this.tensors[t].shape,e,"TensorList shape mismatch: ");let r=Ul(this.elementShape,this.tensors,e);return L(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);$n(this.elementShape,e.shape,"TensorList shape mismatch: "),be(e),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);$n(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=Ul(this.elementShape,this.tensors,s);return t.length===0?Sn([],[0].concat(r)):O(()=>{let o=t.map(a=>L(this.tensors[a],r));return Ye(o,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);$n(this.elementShape,e,"TensorList shape mismatch: ");let s=Ul(this.elementShape,this.tensors,e);return this.size()===0?Sn([],[0].concat(s)):O(()=>{let r=this.tensors.map(o=>L(o,s));return ee(r,0)})}}function HF(n,t,e){let s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);let r=n.shape.slice(1);$n(r,t,"TensorList shape mismatch: ");let o=yn(n);return new ma(o,t,s)}function jF(n,t,e){return new ma([],n,t,e)}function qF(n,t,e,s){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);let r=Math.max(...t);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);let o=new ma([],e,n.dtype,s),a=yn(n,0);return t.forEach((i,l)=>{o.setItem(i,a[l])}),o}function KF(n,t,e){let s=0,r=t.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);let o=n.shape.slice(1),a=eg(o,e),i=s===0?0:n.size/s,l=O(()=>{let u=[];n=L(n,[1,s,i]);for(let h=0;h<t.length;++h){let d=h===0?0:r[h-1],p=[0,d,0],f=[1,t[h],i];u[h]=L(St(n,p,f),a)}return n.dispose(),u}),c=new ma([],e,n.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}let XF=async(n,t,e)=>{switch(n.op){case"If":case"StatelessIf":{let s=$("thenBranch",n,t,e),r=$("elseBranch",n,t,e),o=$("cond",n,t,e),a=$("args",n,t,e);return(await o.data())[0]?e.functionMap[s].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap):e.functionMap[r].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let s=$("body",n,t,e),r=$("cond",n,t,e),o=$("args",n,t,e),a=await e.functionMap[r].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap),i=o.map(u=>u.id),l=await a[0].data();a.forEach(u=>{!u.kept&&i.indexOf(u.id)===-1&&u.dispose()});let c=o;for(;l[0];){let u=c;c=await e.functionMap[s].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);let h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});let d=await e.functionMap[r].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{let s=$("pred",n,t,e);return[bs(s)]}case"Switch":{let s=$("pred",n,t,e),r=$("data",n,t,e);return r.kept||(r=bs(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let s=n.inputNames.find(r=>We(r,t,e)!==void 0);if(s){let r=We(s,t,e);return[bs(r)]}return}case"Enter":{let s=$("frameName",n,t,e),r=$("tensor",n,t,e);return e.enterFrame(s),[bs(r)]}case"Exit":{let s=$("tensor",n,t,e);return e.exitFrame(),[bs(s)]}case"NextIteration":{let s=$("tensor",n,t,e);return e.nextIteration(),[bs(s)]}case"TensorArrayV3":{let s=$("size",n,t,e),r=$("dtype",n,t,e),o=$("elementShape",n,t,e),a=$("dynamicSize",n,t,e),i=$("clearAfterRead",n,t,e),l=$("identicalElementShapes",n,t,e),c=$("name",n,t,e),u=new GF(c,r,s,o,l,a,i);return e.addTensorArray(u),[u.idTensor,ut(1)]}case"TensorArrayWriteV3":{let s=$("tensorArrayId",n,t,e),r=$("index",n,t,e),o=$("tensor",n,t,e),a=e.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{let s=$("tensorArrayId",n,t,e),r=$("index",n,t,e);return[e.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{let s=$("tensorArrayId",n,t,e),r=$("indices",n,t,e),o=$("dtype",n,t,e);return[e.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{let s=$("tensorArrayId",n,t,e),r=$("indices",n,t,e),o=$("tensor",n,t,e),a=e.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{let s=$("tensorArrayId",n,t,e),r=e.getTensorArray(s.id),o=$("dtype",n,t,e);return[r.concat(o)]}case"TensorArraySplitV3":{let s=$("tensorArrayId",n,t,e),r=$("tensor",n,t,e),o=$("lengths",n,t,e),a=e.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{let s=$("tensorArrayId",n,t,e),r=e.getTensorArray(s.id);return[ut(r.size(),"int32")]}case"TensorArrayCloseV3":{let s=$("tensorArrayId",n,t,e),r=e.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let s=$("tensorListId",n,t,e),r=$("index",n,t,e),o=$("tensor",n,t,e),a=e.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{let s=$("tensorListId",n,t,e),r=$("index",n,t,e),o=$("elementShape",n,t,e),a=$("elementDType",n,t,e);return[e.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{let s=$("indices",n,t,e),r=$("tensor",n,t,e),o=$("elementShape",n,t,e),a=$("numElements",n,t,e),i=qF(r,s,o,a);return e.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let s=$("elementShape",n,t,e),r=$("elementDType",n,t,e),o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";let a=$(o,n,t,e),i=jF(s,r,a);return e.addTensorList(i),[i.idTensor]}case"TensorListGather":{let s=$("tensorListId",n,t,e),r=$("indices",n,t,e),o=$("elementShape",n,t,e),a=$("elementDType",n,t,e);return[e.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{let s=$("tensorListId",n,t,e),r=$("elementShape",n,t,e),o=$("elementDType",n,t,e),a=$("numElements",n,t,e);return[e.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{let s=$("tensor",n,t,e),r=$("elementShape",n,t,e),o=$("elementDType",n,t,e),a=HF(s,r,o);return e.addTensorList(a),[a.idTensor]}case"TensorListConcat":{let s=$("tensorListId",n,t,e),r=e.getTensorList(s.id),o=$("dtype",n,t,e),a=$("elementShape",n,t,e);return[r.concat(o,a)]}case"TensorListPushBack":{let s=$("tensorListId",n,t,e),r=$("tensor",n,t,e),o=e.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{let s=$("tensorListId",n,t,e),r=$("elementShape",n,t,e),o=$("elementDType",n,t,e);return[e.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{let s=$("tensor",n,t,e),r=$("elementShape",n,t,e),o=$("lengths",n,t,e),a=KF(s,o,r);return e.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},r5="control";function Ew(n,t,e){let[s,r]=$("fusedOps",n,t,e),o=s==="biasadd",a=r==="prelu",i=s==="fusedbatchnorm",l=$("numArgs",n,t,e);if(o){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");let c=$("strides",n,t,e),u=Mh(n,t,e),h=$("dataFormat",n,t,e).toUpperCase(),d=$("dilations",n,t,e),[p,f]=$("args",n,t,e),m=$("leakyreluAlpha",n,t,e);return{stride:c,pad:u,dataFormat:h,dilations:d,biasArg:p,preluArg:f,activationFunc:r,leakyreluAlpha:m}}let YF=(n,t,e)=>{switch(n.op){case"Conv1D":{let s=$("stride",n,t,e),r=$("pad",n,t,e),o=$("dataFormat",n,t,e).toUpperCase(),a=$("dilation",n,t,e);return[xu($("x",n,t,e),$("filter",n,t,e),s,r,o,a)]}case"Conv2D":{let s=$("strides",n,t,e),r=Mh(n,t,e),o=$("dataFormat",n,t,e).toUpperCase(),a=$("dilations",n,t,e);return[ls($("x",n,t,e),$("filter",n,t,e),[s[1],s[2]],r,o,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:s,pad:r,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:c,leakyreluAlpha:u}=Ew(n,t,e);return[jp({x:$("x",n,t,e),filter:$("filter",n,t,e),strides:[s[1],s[2]],pad:r,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:r,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:c,leakyreluAlpha:u}=Ew(n,t,e);return[bb({x:$("x",n,t,e),filter:$("filter",n,t,e),strides:[s[1],s[2]],pad:r,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=$("outputShape",n,t,e),r=$("strides",n,t,e),o=Mh(n,t,e);return[wu($("x",n,t,e),$("filter",n,t,e),s,[r[1],r[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=$("strides",n,t,e),r=Mh(n,t,e),o=$("dilations",n,t,e),a=$("dataFormat",n,t,e).toUpperCase();return[jo($("input",n,t,e),$("filter",n,t,e),[s[1],s[2]],r,a,[o[1],o[2]])]}case"Conv3D":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("dataFormat",n,t,e).toUpperCase(),a=$("dilations",n,t,e);return[yp($("x",n,t,e),$("filter",n,t,e),[s[1],s[2],s[3]],r,o,[a[1],a[2],a[3]])]}case"AvgPool":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("kernelSize",n,t,e);return[Ki($("x",n,t,e),[o[1],o[2]],[s[1],s[2]],r)]}case"MaxPool":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("kernelSize",n,t,e);return[nl($("x",n,t,e),[o[1],o[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("kernelSize",n,t,e),a=$("includeBatchInIndex",n,t,e),{result:i,indexes:l}=ab($("x",n,t,e),[o[1],o[2]],[s[1],s[2]],r,a);return[i,l]}case"AvgPool3D":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("kernelSize",n,t,e);return[fp($("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("kernelSize",n,t,e);return[Sp($("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{let s=$("strides",n,t,e),r=$("pad",n,t,e),o=$("dilations",n,t,e),a=s[1],i=s[2],l=o[1],c=o[2];return[xp($("x",n,t,e),$("filter",n,t,e),[a,i],r,[l,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},o5="convolution";let JF=(n,t,e)=>{switch(n.op){case"Fill":{let s=$("shape",n,t,e),r=$("dtype",n,t,e),o=$("value",n,t,e);return[Qi(s,o,r)]}case"LinSpace":{let s=$("start",n,t,e),r=$("stop",n,t,e),o=$("num",n,t,e);return[nb(s,r,o)]}case"Multinomial":{let s=$("logits",n,t,e),r=$("numSamples",n,t,e),o=$("seed",n,t,e);return[ib(s,r,o)]}case"OneHot":{let s=$("indices",n,t,e),r=$("depth",n,t,e),o=$("onValue",n,t,e),a=$("offValue",n,t,e);return[hr(s,r,o,a)]}case"Ones":return[Tn($("shape",n,t,e),$("dtype",n,t,e))];case"OnesLike":return[Le($("x",n,t,e))];case"RandomUniform":return[wr($("shape",n,t,e),$("minval",n,t,e),$("maxval",n,t,e),$("dtype",n,t,e))];case"Range":{let s=$("start",n,t,e),r=$("stop",n,t,e),o=$("step",n,t,e);return[Ru(s,r,o,$("dtype",n,t,e))]}case"TruncatedNormal":{let s=$("shape",n,t,e),r=$("mean",n,t,e),o=$("stdDev",n,t,e),a=$("seed",n,t,e);return[ul(s,r,o,$("dtype",n,t,e),a)]}case"Zeros":return[re($("shape",n,t,e),$("dtype",n,t,e))];case"ZerosLike":return[Ct($("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},a5="creation";function ng(n,t,e){let s=$("boxes",n,t,e),r=$("scores",n,t,e),o=$("maxOutputSize",n,t,e),a=$("iouThreshold",n,t,e),i=$("scoreThreshold",n,t,e),l=$("softNmsSigma",n,t,e);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}let ZF=async(n,t,e)=>{switch(n.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}=ng(n,t,e),c=await _s.nonMaxSuppressionWithScoreAsync(s,r,o,a,i,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=ng(n,t,e),l=$("padToMaxOutputSize",n,t,e),c=await _s.nonMaxSuppressionPaddedAsync(s,r,o,a,i,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=ng(n,t,e);return[await _s.nonMaxSuppressionAsync(s,r,o,a,i)]}case"Where":{let s=rt($("condition",n,t,e),"bool"),r=[await Wp(s)];return s.dispose(),r}case"ListDiff":return cb($("x",n,t,e),$("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}},i5="dynamic";let QF=(n,t,e)=>{switch(n.op){case"TopKV2":{let s=$("x",n,t,e),r=$("k",n,t,e),o=$("sorted",n,t,e),a=Bp(s,r,o);return[a.values,a.indices]}case"Unique":{let s=$("x",n,t,e),r=Wu(s);return[r.values,r.indices]}case"UniqueV2":{let s=$("x",n,t,e),r=$("axis",n,t,e),o=Wu(s,r);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},l5="evaluation";let t_=(n,t,e)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":let s=$("default",n,t,e);return[We(n.name,t,e)||s];case"Placeholder":return[We(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=$("x",n,t,e);return[bs(c)]}case"IdentityN":return $("x",n,t,e).map(c=>bs(c));case"Snapshot":let r=$("x",n,t,e);return[bs(r)];case"Shape":return[Je($("x",n,t,e).shape,"int32")];case"ShapeN":return $("x",n,t,e).map(c=>Je(c.shape));case"Size":return[ut($("x",n,t,e).size,"int32")];case"Rank":return[ut($("x",n,t,e).rank,"int32")];case"NoOp":return[ut(1)];case"Print":let o=$("x",n,t,e),a=$("data",n,t,e),i=$("message",n,t,e),l=$("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}},c5="graph";class e_{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=ut(0),this.tensorMap=new Map,be(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(t,e){this.checkKeyAndValueTensor(t,e);let s=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),O(()=>{let r=yn(e),o=s.length,a=r.length;N(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){let l=s[i],c=r[i];be(c),this.tensorMap.set(l,c)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let s=await t.data();return O(()=>{let r=[];for(let o=0;o<s.length;o++){let a=s[o],i=this.findWithDefault(a,e);r.push(i)}return Ye(r)})}findWithDefault(t,e){let s=this.tensorMap.get(t);return s!=null?s:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}let n_=async(n,t,e,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{let r=$("keyDType",n,t,e),o=$("valueDType",n,t,e),a=new e_(r,o);return s.addHashTable(n.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let r=$("tableHandle",n,t,e,s),o=$("keys",n,t,e),a=$("values",n,t,e);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{let r=$("tableHandle",n,t,e,s),o=$("keys",n,t,e),a=$("defaultValue",n,t,e);return[await s.getHashTableById(r.id).find(o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},u5="hash_table";let s_=(n,t,e)=>{switch(n.op){case"ResizeBilinear":{let s=$("images",n,t,e),r=$("size",n,t,e),o=$("alignCorners",n,t,e),a=$("halfPixelCenters",n,t,e);return[_s.resizeBilinear(s,[r[0],r[1]],o,a)]}case"ResizeNearestNeighbor":{let s=$("images",n,t,e),r=$("size",n,t,e),o=$("alignCorners",n,t,e),a=$("halfPixelCenters",n,t,e);return[_s.resizeNearestNeighbor(s,[r[0],r[1]],o,a)]}case"CropAndResize":{let s=$("image",n,t,e),r=$("boxes",n,t,e),o=$("boxInd",n,t,e),a=$("cropSize",n,t,e),i=$("method",n,t,e),l=$("extrapolationValue",n,t,e);return[_s.cropAndResize(s,r,o,a,i,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},h5="image";let r_=(n,t,e)=>{switch(n.op){case"Equal":return[cs($("a",n,t,e),$("b",n,t,e))];case"NotEqual":return[yr($("a",n,t,e),$("b",n,t,e))];case"Greater":return[an($("a",n,t,e),$("b",n,t,e))];case"GreaterEqual":return[Rs($("a",n,t,e),$("b",n,t,e))];case"Less":return[ku($("a",n,t,e),$("b",n,t,e))];case"LessEqual":return[gr($("a",n,t,e),$("b",n,t,e))];case"LogicalAnd":return[gn($("a",n,t,e),$("b",n,t,e))];case"LogicalNot":return[el($("a",n,t,e))];case"LogicalOr":return[Eu($("a",n,t,e),$("b",n,t,e))];case"Select":case"SelectV2":return[Oe($("condition",n,t,e),$("a",n,t,e),$("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},d5="logical";let o_=(n,t,e)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[It($("a",n,t,e),$("b",n,t,e),$("transposeA",n,t,e),$("transposeB",n,t,e))];case"Transpose":return[Rt($("x",n,t,e),$("perm",n,t,e))];case"_FusedMatMul":let[s,r]=$("fusedOps",n,t,e),o=s==="biasadd",a=r==="prelu",i=$("numArgs",n,t,e),l=$("leakyreluAlpha",n,t,e);if(o){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,u]=$("args",n,t,e);return[Xu({a:$("a",n,t,e),b:$("b",n,t,e),transposeA:$("transposeA",n,t,e),transposeB:$("transposeB",n,t,e),bias:c,activation:r,preluActivationWeights:u,leakyreluAlpha:l})];default:throw TypeError(`Node type ${n.op} is not implemented`)}},p5="matrices";let a_=(n,t,e)=>{switch(n.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[fr($("x",n,t,e),$("mean",n,t,e),$("variance",n,t,e),$("offset",n,t,e),$("scale",n,t,e),$("epsilon",n,t,e))];case"FusedBatchNormV3":return[fr($("x",n,t,e),$("mean",n,t,e),$("variance",n,t,e),$("offset",n,t,e),$("scale",n,t,e),$("epsilon",n,t,e))];case"LRN":return[Cp($("x",n,t,e),$("radius",n,t,e),$("bias",n,t,e),$("alpha",n,t,e),$("beta",n,t,e))];case"Softmax":return[il($("x",n,t,e))];case"LogSoftmax":return[Tu($("x",n,t,e))];case"SparseToDense":return[Up($("sparseIndices",n,t,e),$("outputShape",n,t,e),$("sparseValues",n,t,e),$("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},f5="normalization";let i_=(n,t,e)=>{switch(n.op){case"Max":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[ln($("x",n,t,e),a,i)]}case"Mean":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[Zt($("x",n,t,e),a,i)]}case"Min":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[Jo($("x",n,t,e),a,i)]}case"Sum":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[ht($("x",n,t,e),a,i)]}case"All":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[yu($("x",n,t,e),a,i)]}case"Any":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[Hi($("x",n,t,e),a,i)]}case"ArgMax":{let a=$("axis",n,t,e);return[ji($("x",n,t,e),a)]}case"ArgMin":{let a=$("axis",n,t,e);return[ap($("x",n,t,e),a)]}case"Prod":{let a=$("axis",n,t,e),i=$("keepDims",n,t,e);return[Du($("x",n,t,e),a,i)]}case"Cumsum":{let a=$("axis",n,t,e),i=$("exclusive",n,t,e),l=$("reverse",n,t,e);return[vu($("x",n,t,e),a,i,l)]}case"Bincount":let s=$("x",n,t,e),r=$("weights",n,t,e),o=$("size",n,t,e);return[Hy(s,r,o)];case"DenseBincount":{let a=$("x",n,t,e),i=$("weights",n,t,e),l=$("size",n,t,e),c=$("binaryOutput",n,t,e);return[Jy(a,i,l,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},m5="reduction";let l_=(n,t,e)=>{switch(n.op){case"ConcatV2":case"Concat":{let s=$("n",n,t,e),r=$("axis",n,t,e),o=$("tensors",n,t,e);return o=o.slice(0,s),[ee(o,r)]}case"Gather":{let s=$("x",n,t,e),r=$("indices",n,t,e);return[mr(s,rt(r,"int32"),0)]}case"GatherV2":{let s=$("axis",n,t,e),r=$("batchDims",n,t,e),o=$("x",n,t,e),a=$("indices",n,t,e);return[mr(o,rt(a,"int32"),s,r)]}case"Reverse":{let s=$("dims",n,t,e),r=[];for(let a=0;a<s.length;a++)s[a]&&r.push(a);let o=$("x",n,t,e);return[Ke(o,r)]}case"ReverseV2":{let s=$("axis",n,t,e),r=$("x",n,t,e);return[Ke(r,s)]}case"Slice":{let s=$("begin",n,t,e),r=$("size",n,t,e);return[St($("x",n,t,e),s,r)]}case"StridedSlice":{let s=$("begin",n,t,e),r=$("end",n,t,e),o=$("strides",n,t,e),a=$("beginMask",n,t,e),i=$("endMask",n,t,e),l=$("ellipsisMask",n,t,e),c=$("newAxisMask",n,t,e),u=$("shrinkAxisMask",n,t,e),h=$("x",n,t,e);return[zp(h,s,r,o,a,i,l,c,u)]}case"Pack":return O(()=>{let s=$("axis",n,t,e),r=$("tensors",n,t,e),o=r[0].shape,a=Fs(r[0]).shape,i=r.map(l=>{let c=At(l.shape,o);if(!c&&!At(Fs(l).shape,a))throw new Error("the input tensors shape does not match");return c?l:L(l,o)});return[Ye(i,s)]});case"Unpack":{let s=$("axis",n,t,e),r=$("tensor",n,t,e);return yn(r,s)}case"Tile":{let s=$("reps",n,t,e);return[Ds($("x",n,t,e),s)]}case"Split":case"SplitV":{let s=$("axis",n,t,e),r=$("numOrSizeSplits",n,t,e),o=$("x",n,t,e);return Xe(o,r,s)}case"ScatterNd":{let s=$("indices",n,t,e),r=$("values",n,t,e),o=$("shape",n,t,e);return[db(s,r,o)]}case"GatherNd":{let s=$("x",n,t,e),r=$("indices",n,t,e);return[pb(s,r)]}case"SparseToDense":{let s=$("sparseIndices",n,t,e),r=$("outputShape",n,t,e),o=$("sparseValues",n,t,e),a=$("defaultValue",n,t,e);return[Up(s,o,r,o.dtype===a.dtype?a:rt(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},g5="slice_join";let c_=(n,t,e)=>{switch(n.op){case"FFT":return[ll($("x",n,t,e))];case"IFFT":return[ea($("x",n,t,e))];case"RFFT":return[cl($("x",n,t,e))];case"IRFFT":return[Bu($("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},y5="spectral";let u_=(n,t,e)=>{switch(n.op){case"Cast":return[rt($("x",n,t,e),$("dtype",n,t,e))];case"ExpandDims":{let s=$("axis",n,t,e);return[je($("x",n,t,e),s)]}case"Squeeze":{let s=$("axis",n,t,e);return[Fs($("x",n,t,e),s)]}case"Reshape":return[L($("x",n,t,e),$("shape",n,t,e))];case"MirrorPad":return[Tp($("x",n,t,e),$("padding",n,t,e),$("mode",n,t,e))];case"PadV2":case"Pad":return[qn($("x",n,t,e),$("padding",n,t,e),$("constantValue",n,t,e))];case"SpaceToBatchND":{let s=$("blockShape",n,t,e),r=$("paddings",n,t,e);return[sl($("x",n,t,e),s,r)]}case"BatchToSpaceND":{let s=$("blockShape",n,t,e),r=$("crops",n,t,e);return[Xi($("x",n,t,e),s,r)]}case"DepthToSpace":{let s=$("blockSize",n,t,e),r=$("dataFormat",n,t,e).toUpperCase();return[bp($("x",n,t,e),s,r)]}case"BroadcastTo":return[Yi($("x",n,t,e),$("shape",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},b5="transformation";function Aw(n,t,e,s){let r=((o,a,i)=>{switch(o.category){case"arithmetic":return O(()=>WF(o,a,i));case"basic_math":return O(()=>UF(o,a,i));case"control":return XF(o,a,i);case"convolution":return O(()=>YF(o,a,i));case"creation":return O(()=>JF(o,a,i));case"dynamic":return ZF(o,a,i);case"evaluation":return O(()=>QF(o,a,i));case"image":return O(()=>s_(o,a,i));case"graph":return O(()=>t_(o,a,i));case"logical":return O(()=>r_(o,a,i));case"matrices":return O(()=>o_(o,a,i));case"normalization":return O(()=>a_(o,a,i));case"reduction":return O(()=>i_(o,a,i));case"slice_join":return O(()=>l_(o,a,i));case"spectral":return O(()=>c_(o,a,i));case"transformation":return O(()=>u_(o,a,i));case"hash_table":return n_(o,a,i,s);case"custom":let l=Cw(o.op);if(l&&l.customExecutor)return l.customExecutor(new VF(o,a,i));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return nr(r)?r.then(o=>[].concat(o)):[].concat(r)}class Dw{constructor(t={},e={},s={},r={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function Rw(n,t,e,s){let r=new Set,o=[],a=null,i=null,l=new Set,c=Object.keys(n).map(d=>Qe(d)[0]),u=[];s!=null&&(u=s.map(d=>Qe(d.name)[0]));let h=[...t];for(;h.length>0;){let d=h.pop();if((Fw(d)||m_(d)||g_(d))&&a==null&&(a=d,i=a.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),e[d.name]==null&&c.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:t,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:i}}function h_(n,t,e){let{usedNodes:s,inputs:r}=e,o=[],a=Object.keys(r).map(u=>Qe(u)[0]).map(u=>n.nodes[u]),i=n.initNodes;a.forEach(u=>{s.has(u.name)&&o.push(u)}),n.weights.forEach(u=>{s.has(u.name)&&o.push(u)}),i!=null&&i.forEach(u=>{s.has(u.name)&&o.push(u)});let l=new Set,c=[];for(;o.length>0;){let u=o.pop();l.add(u.name),t[u.name]||c.push(u),u.children.forEach(h=>{!l.has(h.name)&&s.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&o.push(h)})}return c}let d_=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],p_=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],f_=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function Fw(n){return d_.indexOf(n.op)>=0}function m_(n){return p_.indexOf(n.op)>=0}function g_(n){return f_.indexOf(n.op)>=0}class Bh{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Bh(t.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let s=t.map(o=>o.name).sort(),r=e.map(o=>o.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,e){let s=Rw(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){let i=e.map(c=>c.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return h_(this.graph,this.weightMap,s)}execute(t,e){t=this.mapInputs(t);let s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let r=s.map(h=>this.graph.nodes[Qe(h)[0]]),o=e.map(h=>Qe(h)[0]),a=o.map(h=>this.graph.nodes[h]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(r,a),l=this.compiledMap.get(i);l==null&&(l=this.compile(t,a),this.compiledMap.set(i,l));let c={},u={};return O(()=>{let h=new Dw(this.weightMap,c,u,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(t).forEach(m=>{let[g,y]=Qe(m),b=[];b[y]=t[m],d[g]=b});let p=this.getFrozenTensorIds(d),f={};for(let m=0;m<l.length;m++){let g=l[m];if(!d[g.name]){let y=Aw(g,d,h,this._resourceManager);if(nr(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);d[g.name]=y,this.checkTensorForDisposal(g.name,g,d,h,p,o,f)}}return this.parent==null&&h.dispose(p),e.map(m=>We(m,d,h))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(e)}checkTensorForDisposal(t,e,s,r,o,a,i){e.category==="control"||a.indexOf(t)!==-1||(s[t].forEach(l=>{l!=null&&(i[l.id]=(i[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if(l.category!=="control"){let c=vF(l.name,s,r);c!=null&&c.forEach(u=>{if(u&&!o.has(u.id)){let h=i[u.id];h===1?(u.dispose(),delete i[u.id]):h!=null&&i[u.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,s=!1,r={},o={}){s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));let a=new Dw(this.weightMap,r,o,this.functionExecutorMap),i=await this.executeWithControlFlow(t,a,e,s),l=e.map(d=>We(d,i,a)),c=l.map(d=>d.id),u=Object.keys(t).map(d=>t[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.keys(i).forEach(d=>{i[d].forEach(f=>{f&&!f.isDisposed&&!h.has(f.id)&&f.dispose()})}),this.parent==null&&a.dispose(h),l}async executeFunctionAsync(t,e,s){let r=t.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,r){let o=Object.keys(t),a=o.map(C=>this.graph.nodes[Qe(C)[0]]),i=s.map(C=>Qe(C)[0]),l=i.map(C=>this.graph.nodes[C]);l.length===0&&(l=this._outputs);let{usedNodes:c,missingInputs:u,dynamicNode:h,syncInputs:d}=Rw(t,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:e.currentContext})),f=Object.assign({},this.weightMap);Object.keys(t).forEach(C=>{let[w,v]=Qe(C),I=[];I[v]=t[C],f[w]=I});let m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){let C=this.processStack(a,p,e,f,y,g,i,m,c);await Promise.all(C)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter(C=>!Fw(C)&&!We(C.name,f,e)).map(C=>C.name);if(b.length>0){let C="";throw h!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${o}]. Consider providing the following inputs: [${u}]. ${C}`)}return f}processStack(t,e,s,r,o,a,i,l,c){let u=[];for(;e.length>0;){let h=e.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&$("isConstant",h.node,r,s)&&([d]=ys(h.node.name,s)),r[h.node.name]==null){let p=Aw(h.node,r,s,this._resourceManager);d||([d]=ys(h.node.name,s));let f=s.currentContext;nr(p)?u.push(p.then(m=>(r[d]=m,s.currentContext=f,this.checkTensorForDisposal(d,h.node,r,s,a,i,l),this.processChildNodes(h.node,e,s,r,o,c),m))):(r[d]=p,this.checkTensorForDisposal(d,h.node,r,s,a,i,l),this.processChildNodes(h.node,e,s,r,o,c))}else this.processChildNodes(h.node,e,s,r,o,c)}return u}processChildNodes(t,e,s,r,o,a){t.children.forEach(i=>{let[l]=ys(i.name,s);o[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(c=>!!We(c,r,s))&&(o[l]=!0,e.push({contexts:s.currentContext,node:i})):i.inputNames.every(c=>!!We(c,r,s))&&(o[l]=!0,e.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let s=t[e],[r]=Qe(e),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){let a=o.attrParams.shape.value,i=a.length===s.shape.length&&s.shape.every((l,c)=>a[c]===-1||a[c]===l);N(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&N(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){let e={};for(let s in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){let r=this._signature.inputs[s];e[r.name]=t[s]}else e[s]=t[s];return e}checkInputs(t){let e=Object.keys(t).filter(s=>{let[r]=Qe(s);return this.graph.nodes[r]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[s]=Qe(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class y_{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}let b_="?tfjs-format=file",x_="model.json";class _w{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",e==null&&(this.loadOptions={}),this.resourceManager=new y_}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=uu(t,this.loadOptions);else{let e=Bd(t,this.loadOptions);if(e.length===0)e.push(uu(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let r=au(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Bh(Nw.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let o=Nw.Instance.transformGraph(t.modelInitializer);this.initializer=new Bh(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let s=Md(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Dt)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,s,r)=>(e[s]=t[r],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let s=this.executor.execute(t,e);return s.length>1?s:s[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let s=await this.executor.executeAsync(t,e);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function w_(n,t={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&n.load==null&&(n.endsWith("/")||(n=n+"/"),n=`${n}${x_}${b_}`);let e=new _w(n,t);return await e.load(),e}let Ow="3.2.0";function $_(n,t){return Vh(n,t)}function Vh(n,t,e=new Map,s=new Set){if(n==null)return null;if(s.has(n))throw new Error("Circular references are not supported.");if(e.has(n))return e.get(n);let r=t(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(ga(n)){let o=Array.isArray(n)?[]:{};s.add(n);for(let a in n){let i=n[a],l=Vh(i,t,e,s);o[a]=l}return s.delete(n),o}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return e.set(n,r.value),r.value}function v_(n,t=Pw){return Lw(n,t)}function Lw(n,t,e=new Set){let s=n[0];if(e.has(s))throw new Error("Circular references are not supported.");let r=t(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(ga(s)){let o=Array.isArray(s)?[]:{};e.add(s);for(let a in s){let i=n.map(c=>c[a]),l=Lw(i,t,e);o[a]=l}return e.delete(s),o}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function Pw(n){return n===null?null:ga(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function zw(n,t){let e=new Map;Vh(n,t,e);for(let r of Array.from(e.keys())){let o=e.get(r);if(nr(o)){let a=await o;e.set(r,a)}}return Vh(n,t,e)}function ga(n){return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof Dt))}function C_(n){return n==null||N_(n)||Array.isArray(n)||typeof n=="object"&&n instanceof Dt||ke(n)}function N_(n){return n===null||typeof n!="object"&&typeof n!="function"}function k_(n){return $_(n,I_)}function I_(n){return n instanceof Dt?{value:n.clone(),recurse:!1}:ga(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class Mw{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),s=this.get(e);return this.set(e,this.pop()),s}}class Wh extends Mw{constructor(){super(Wh.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),s=this.length();for(let r=0;r<s;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Wh.INITIAL_CAPACITY=32;function Bw(n){return new T_(n)}function x5(n){let t=n;return Gl(()=>({value:t++,done:!1}))}function Gl(n){return new E_(n)}function Vw(n,t){return new Uw(n,t)}function w5(n,t,e){return Vw(Gl(n).take(t),e)}function S_(n,t=Gs.FAIL){return new z_(n,t)}class Ce{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],s=await t.next();for(;!s.done;)e.push(s.value),s=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),s=t(e.value);for(;!e.done&&s;)e=await this.next(),s=t(e.value)}handleErrors(t){return new L_(this,t)}filter(t){return new __(this,t)}map(t){return new O_(this,t)}mapAsync(t){return new Ww(this,t)}serialMapAsync(t){return new Ww(this,t).serial()}flatmap(t){return new P_(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new F_(this,t,e)}columnMajorBatch(t,e=!0,s=Pw){return this.rowMajorBatch(t,e).map(o=>v_(o,s))}concatenate(t,e){return new Uw(Bw([this,t]),e)}take(t){return t<0||t==null?this:new R_(this,t)}skip(t){return t<0||t==null?this:new D_(this,t)}prefetch(t){return new Gw(this,t)}shuffle(t,e){return new M_(this,t,e)}serial(){return new A_(this)}}class T_ extends Ce{constructor(t){super();this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:k_(t),done:!1}}}class E_ extends Ce{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class A_ extends Ce{constructor(t){super();this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class D_ extends Ce{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;bt(t.value)}return this.upstream.next()}}class R_ extends Ce{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class F_ extends Ce{constructor(t,e,s=!0){super();this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class __ extends Ce{constructor(t,e){super();this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;bt(t.value)}}}class O_ extends Ce{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=rs(t.value),s=this.transform(t.value),r=rs(s);for(let o of e)ru(o,r)||o.dispose();return{value:s,done:!1}}}class L_ extends Ce{constructor(t,e){super();this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class Ww extends Ce{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=rs(t.value),s=await this.transform(t.value),r=rs(s);for(let o of e)ru(o,r)||o.dispose();return{value:s,done:!1}}}class sg extends Ce{constructor(){super();this.outputQueue=new Wh,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class P_ extends sg{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=rs(t.value),s=this.transform(t.value),r=rs(s);this.outputQueue.pushAll(s);for(let o of e)ru(o,r)||o.dispose();return!0}}class Uw extends Ce{constructor(t,e){super();this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var Gs;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Gs||(Gs={}));class z_ extends Ce{constructor(t,e=Gs.FAIL){super();this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,s=0;function r(a){return a instanceof Ce?{value:a.next().then(l=>(e++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}let o=await zw(this.iterators,r);if(e===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case Gs.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Gs.SHORTEST:return{value:null,done:!0};case Gs.LONGEST:default:}return this.count++,{value:o,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class Gw extends Ce{constructor(t,e){super();this.upstream=t,this.bufferSize=e,this.buffer=new Mw(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class M_ extends Gw{constructor(t,e,s){super(t,e);this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=ta(s||Se().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}}class ya{constructor(){this.size=null}batch(t,e=!0){let s=this;N(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let r;return this.size===Infinity||this.size==null?r=this.size:e?r=Math.ceil(this.size/t):r=Math.floor(this.size/t),tn(async()=>(await s.iterator()).columnMajorBatch(t,e,W_),r)}concatenate(t){let e=this,s;return this.size===Infinity||t.size===Infinity?s=Infinity:this.size!=null&&t.size!=null?s=this.size+t.size:s=null,tn(async()=>(await e.iterator()).concatenate(await t.iterator()),s)}filter(t){let e=this,s;return this.size===Infinity?s=Infinity:s=null,tn(async()=>(await e.iterator()).filter(r=>O(()=>t(r))),s)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return tn(async()=>(await e.iterator()).map(s=>O(()=>t(s))),this.size)}mapAsync(t){let e=this;return tn(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return tn(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,s;return this.size!=null&&t>0?s=this.size*t:t===0?s=0:this.size!=null&&(t===void 0||t<0)?s=Infinity:s=null,tn(async()=>{let r=Gl(async()=>({value:await e.iterator(),done:!1}));return Vw(r.take(t))},s)}skip(t){let e=this,s;return this.size!=null&&t>=0&&this.size>=t?s=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?s=0:s=null,tn(async()=>(await e.iterator()).skip(t),s)}shuffle(t,e,s=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,o=ta(e||Se().toString());return tn(async()=>{let a=o.int32();return s&&(a+=o.int32()),(await r.iterator()).shuffle(t,a.toString())},this.size)}take(t){let e=this,s;return this.size!=null&&this.size>t?s=t:this.size!=null&&this.size<=t?s=this.size:s=null,tn(async()=>(await e.iterator()).take(t),s)}async toArray(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}ya.MAX_BUFFER_SIZE=1e4;function tn(n,t=null){return new class extends ya{constructor(){super(...arguments);this.size=t}async iterator(){return n()}}}function B_(n){return tn(async()=>Bw(n),n.length)}function V_(n){if(!ga(n))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(n))for(let e=0;e<n.length;e++)t=t==null?n[e].size:Math.min(t,n[e].size);else if(n instanceof Object)for(let e in n)t=t==null?n[e].size:Math.min(t,n[e].size);return tn(async()=>{let e=await zw(n,s=>{if(s instanceof ya)return{value:s.iterator(),recurse:!1};if(ga(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return S_(e,Gs.SHORTEST)},t)}function W_(n){if(n===null)return null;let t=n[0];return C_(t)?{value:U_(n),recurse:!1}:{value:null,recurse:!0}}function U_(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof Dt?Ye(n):Sn(n)}class Hw extends ya{constructor(t){super();this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}let Uh='"',Hl=Symbol("out"),jw=Symbol("field"),Gh=Symbol("quote"),rg=Symbol("quoteafterquote"),qw=Symbol("quoteinquote");class Kw extends ya{constructor(t,e){super();this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Hw(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(N(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&N(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((r,o)=>(r[o]=r[o]+1||1,r),{}),s=Object.keys(e).filter(r=>e[r]>1);if(N(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let s=e.value;return this.parseRow(s,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),s={},r={};for(let o=0;o<this.fullColumnNames.length;o++){let a=this.fullColumnNames[o],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let l=e[o],c=null;if(l==="")if(i&&i.default!==void 0)c=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${t}`);c=void 0}else{let u=Number(l);if(isNaN(u))i&&i.dtype==="bool"?c=this.getBoolean(l):c=l;else if(!i||!i.dtype)c=u;else switch(i.dtype){case"float32":c=u;break;case"int32":c=Math.floor(u);break;case"bool":c=this.getBoolean(l);break;default:c=u}}i&&i.isLabel?r[a]=c:s[a]=c}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let s=[],r=0,o=t.length,a=Hl;for(let i=0;i<o;i++)switch(a){case Hl:switch(t.charAt(i)){case Uh:r=i+1,a=Gh;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=Hl;break;default:a=jw,r=i;break}break;case jw:switch(t.charAt(i)){case this.delimiter:s.push(t.substring(r,i)),a=Hl,r=i+1;break;default:}break;case Gh:switch(t.charAt(i)){case Uh:a=rg;break;default:}break;case rg:switch(t.charAt(i)){case this.delimiter:s.push(t.substring(r,i-1)),a=Hl,r=i+1;break;case Uh:a=Gh;break;default:a=qw;break}break;case qw:switch(t.charAt(i)){case Uh:a=Gh;break;default:}break;default:}if(a===rg?s.push(t.substring(r,o-1)):s.push(t.substring(r)),e&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class og extends Ce{constructor(t){super();this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(G().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let e=new og(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,s=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(s.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(s.timeDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],s=0;return new Promise(r=>{let o=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-Infinity&&r({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(o),r({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,s=new Float32Array(t.length*e);return t.forEach((r,o)=>s.set(r,o*e)),s}getTensorFromAudioDataArray(t,e){let s=new Float32Array(H(e));return s.set(t,s.length-t.length),Sn(s,e)}}class ag extends Ce{constructor(t,e){super();if(this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Je([0],"int32"),this.webcamConfig.centerCrop){let s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,o=(1-s)/2,a=(1-r)/2,i=o+s,l=r+a;this.cropBox=$r([a,o,l,i],[1,4])}else this.cropBox=$r([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(G().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let s=new ag(t,e);return await s.start(),s}async start(){this.webcamConfig.facingMode&&N(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Cy(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return O(()=>{let e=je(rt(t,"float32"),0),s;s=_s.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=s.shape;return L(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class Xw{}class Yw extends Ce{split(t){return new G_(this,t)}}class G_ extends Yw{constructor(t,e){super();this.upstream=t,this.impl=new H_(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class H_ extends sg{constructor(t,e){super();this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let s of e.slice(0,-1))this.outputQueue.push(s);return this.carryover=e[e.length-1],!0}}class j_ extends Ce{decodeUTF8(){return new q_(this)}}class q_ extends Yw{constructor(t){super();this.upstream=t,this.impl=new K_(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class K_ extends sg{constructor(t){super();if(this.upstream=t,G().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=require("string_decoder");this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let s;return G().get("IS_BROWSER")?s=this.decoder.decode(e,{stream:!0}):s=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(s),!0}}class Jw extends j_{constructor(t,e={}){super();this.file=t,this.options=e,N(t instanceof Uint8Array||(G().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,s)=>{let r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,r)));else{let o=new FileReader;o.onload=i=>{let l=o.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));e(l)},o.onabort=i=>s(new Error("Aborted")),o.onerror=i=>s(new Error(i.type));let a=this.file.slice(this.offset,r);o.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}async function X_(n,t={}){let e,s;typeof n=="string"?e=n:(e=n.url,s=Y_(n));let r=await Xg(e,s);if(r.ok){let o=new Uint8Array(await r.arrayBuffer());return new Jw(o,t)}else throw new Error(r.statusText)}let Y_=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function Zw(n){return typeof n=="string"&&n.substr(0,7)==="file://"}class Qw extends Xw{constructor(t,e={}){super();this.input=t,this.options=e}async iterator(){if(Zw(this.input)&&G().get("IS_NODE")){let t=require("fs");this.input=t.readFileSync(this.input.substr(7))}return new Jw(this.input,this.options)}}class t0 extends Xw{constructor(t,e={}){super();this.url=t,this.fileOptions=e}async iterator(){return Zw(this.url)?new Qw(this.url,this.fileOptions).iterator():X_(this.url,this.fileOptions)}}function J_(n,t={}){return new Kw(new t0(n),t)}function Z_(n){let t=Gl(n);return tn(async()=>t)}function Q_(n){return tn(async()=>{let t=await n();return Gl(()=>t.next())})}async function tO(n,t){return ag.create(n,t)}async function eO(n){return og.create(n)}let e0="3.2.0";var nO=Object.freeze({__proto__:null,array:B_,Dataset:ya,zip:V_,CSVDataset:Kw,TextLineDataset:Hw,csv:J_,func:Z_,generator:Q_,microphone:eO,webcam:tO,FileDataSource:Qw,URLDataSource:t0,version_data:e0});function it(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&N(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}let sO=Uu;class Hh extends zr{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new fn(this,os())}nextDataId(){return Hh.nextDataId++}write(t,e,s){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&oa(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&Mn(s[0])){let o=s.map(a=>rr(a));r=this.write(o,t,e)}else r=this.write(s,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,s,r,o){this.data.set(t,{values:e,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){let r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return ps(r,o)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId),s=e;if(t.dtype==="string")try{s=e.map(r=>or(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(t.shape,t.dtype,s)}makeOutput(t,e,s){let r=this.write(t,e,s);return os().makeTensorFromDataId(r,e,s,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let e=Se();return t(),{kernelMs:Se()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){it([t],"where");let e=this.readSync(t.dataId);return sO(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Hh.nextDataId=0;function n0(n){let t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}let rO={kernelName:_a,backendName:"cpu",kernelFunc:n=>{let{x:t}=n.inputs,e=n.backend;it(t,"abs");let s=new Float32Array(H(t.shape)),r=e.data.get(t.dataId).values;return s=n0(r),e.makeOutput(s,t.shape,"float32")}};function ie(n){return(t,e,s,r,o)=>{let a=Nt(t,e),i=a.length,l=pt(a),c=H(a),u=ye(o,c),h=t.length,d=e.length,p=pt(t),f=pt(e),m=Zi(t,a),g=Zi(e,a);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<u.length;++y){let b=Br(y,i,l),C=b.slice(-h);m.forEach(k=>C[k]=0);let w=In(C,h,p),v=b.slice(-d);g.forEach(k=>v[k]=0);let I=In(v,d,f);u[y]=n(s[w],r[I])}return[u,a]}}function en(n){let{inputs:t,backend:e}=n,{real:s,imag:r}=t,o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,i=e.makeTensorInfo(s.shape,"complex64"),l=e.data.get(i.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",o),imag:e.makeTensorInfo(r.shape,"float32",a)},i}let oO={kernelName:dc,backendName:"cpu",kernelFunc:en};function jh(n,t,e="float32"){if(e==="complex64"){let r=jh(n,t,"float32"),o=jh(n,t,"float32");return en({inputs:{real:r,imag:o},backend:n})}let s=Ie(H(t),e);return n.makeTensorInfo(t,e,s)}function Qn(n){let{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}let aO={kernelName:io,backendName:"cpu",kernelFunc:Qn};function Rr(n){let{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,o=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,o)}let iO={kernelName:Wc,backendName:"cpu",kernelFunc:Rr};function Hs(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Qn({inputs:{x:r},backend:e});let a=jh(e,r.shape,r.dtype),i=Hs({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=en({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),l}if(r.dtype==="complex64"){let a=Rr({inputs:{input:r},backend:e}),i=Hs({inputs:{x:a},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(a),i}if(!$d(r.dtype,o)){let a=Qn({inputs:{x:r},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32"){let a=e.data.get(r.dataId).values,i=Int32Array.from(a);return e.makeTensorInfo(r.shape,"int32",i)}if(o==="bool"){let a=e.data.get(r.dataId).values,i=Ns([0],r.dtype),[l,c]=ie((u,h)=>u!==h?1:0)(r.shape,[],a,i,"bool");return e.makeTensorInfo(c,"bool",l)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}let lO={kernelName:Kr,backendName:"cpu",kernelFunc:Hs};function Ne(n,t,e,s){return e==null?({inputs:r,backend:o})=>{let{a,b:i}=r,l=o;it([a,i],n);let c=l.data.get(a.dataId).values,u=l.data.get(i.dataId).values,h=s||a.dtype,[d,p]=t(a.shape,i.shape,c,u,h);return l.makeTensorInfo(p,h,d)}:({inputs:r,backend:o})=>{let{a,b:i}=r,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){let c=Hs({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=Hs({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,C=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[v,I,k]=e(a.shape,i.shape,p,f,C,w),T=l.makeTensorInfo(k,"float32",v),E=l.makeTensorInfo(k,"float32",I),F=en({inputs:{real:T,imag:E},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(E),F}else{let c=l.data.get(a.dataId).values,u=l.data.get(i.dataId).values,h=s||a.dtype,[d,p]=t(a.shape,i.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function ig(n){return(t,e,s,r,o,a)=>{let i=Nt(t,e),l=H(i),c=i.length,u=pt(i),h=ye("float32",l),d=ye("float32",l),p=Zi(t,i),f=Zi(e,i),m=ps(s,r),g=ps(o,a),y=t.length,b=pt(t),C=e.length,w=pt(e);if(p.length+f.length===0)for(let v=0;v<h.length;v++){let I=v%m.length,k=v%g.length,T=n(m[I*2],m[I*2+1],g[k*2],g[k*2+1]);h[v]=T.real,d[v]=T.imag}else for(let v=0;v<h.length;v++){let I=Br(v,c,u),k=I.slice(-y);p.forEach(M=>k[M]=0);let T=In(k,y,b),E=I.slice(-C);f.forEach(M=>E[M]=0);let F=In(E,C,w),P=n(m[T*2],m[T*2+1],g[F*2],g[F*2+1]);h[v]=P.real,d[v]=P.imag}return[h,d,i]}}let s0=ie((n,t)=>n+t),cO=ig((n,t,e,s)=>({real:n+e,imag:t+s})),jl=Ne(sr,s0,cO),uO={kernelName:sr,backendName:"cpu",kernelFunc:jl};function lg(n,t,e,s,r){let o=H(s),a=Ie(r,e);for(let i=0;i<n.length;i++){let l=n[i];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o>0?a[l]+=t[i]:a[l]+=1)}return a}function r0(n,t,e,s=!1){let r=n.shape[0],o=n.shape[1],a=vt([r,e],t.dtype);for(let i=0;i<r;i++)for(let l=0;l<o;l++){let c=n.get(i,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||(s?a.set(1,i,c):t.size>0?a.set(a.get(i,c)+t.get(i,l),i,c):a.set(a.get(i,c)+1,i,c))}return a}function ba(n){return(t,e,s)=>{let r=ye(e,t.length);for(let o=0;o<t.length;++o)r[o]=n(t[o],s);return r}}function Ft(n,t,e){return({inputs:s,attrs:r,backend:o})=>{let{x:a}=s;if(it(a,n),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,c=H(a.shape),u=e||a.dtype,h=er(u,c);for(let d=0;d<c;++d)h[d]=t(l[d],r);return i.makeTensorInfo(a.shape,u,h)}}function xa(n,t,e){return({inputs:s,attrs:r,backend:o})=>{let{x:a}=s;if(it(a,n),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,c=e||a.dtype,u=t(l,c,r);return i.makeTensorInfo(a.shape,c,u)}}let o0=ba(n=>Math.ceil(n)),hO=xa(Xr,o0),dO={kernelName:Xr,backendName:"cpu",kernelFunc:hO};function a0(n,t,e,s){let r=er(e,H(t));if(s&&e!=="string"){let o=0;n.forEach(a=>{let i=H(a.shape);r.set(a.vals,o),o+=i})}else{let o=0;n.forEach(a=>{let i=e==="string"?cf(a.vals):a.vals,l=0;for(let c=0;c<a.shape[0];++c){let u=c*t[1]+o;for(let h=0;h<a.shape[1];++h)r[u+h]=i[l++]}o+=a.shape[1]})}return r}let i0=ba(n=>Math.exp(n)),l0=xa(no,i0),pO={kernelName:no,backendName:"cpu",kernelFunc:l0};let c0=ba(n=>Math.expm1(n)),fO=xa(so,c0),mO={kernelName:so,backendName:"cpu",kernelFunc:fO};let u0=ba(n=>Math.floor(n)),gO=xa(ro,u0),yO={kernelName:ro,backendName:"cpu",kernelFunc:gO};function h0(n,t,e){let s=vt(e,n.dtype);for(let r=0;r<s.size;++r){let a=s.indexToLoc(r).slice(),i=a[0],l=a[2],c=t.locToIndex([i,l]);a[2]=t.values[c];let u=n.locToIndex(a);s.values[r]=n.values[u]}return s}let d0=ie((n,t)=>n>t?1:0),bO=Ne(ti,d0,null,"bool"),xO={kernelName:ti,backendName:"cpu",kernelFunc:bO};let p0=ie((n,t)=>n<t?1:0),wO=Ne(ni,p0,null,"bool"),$O={kernelName:ni,backendName:"cpu",kernelFunc:wO};function f0(n,t,e){let s=(t-n)/(e-1),r=Ie(e,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}let m0=ba(n=>Math.log(n)),vO=xa(ho,m0),CO={kernelName:ho,backendName:"cpu",kernelFunc:vO};function g0(n,t,e,s){let r=ye(s,H(e));for(let o=0;o<r.length;++o){let a=o*t,i=n[a];for(let l=0;l<t;++l){let c=n[a+l];c>i&&(i=c)}r[o]=i}return r}let y0=ie((n,t)=>Math.max(n,t)),NO=Ne(fo,y0),kO={kernelName:fo,backendName:"cpu",kernelFunc:NO};let b0=ie((n,t)=>Math.min(n,t)),IO=Ne(mo,b0),SO={kernelName:mo,backendName:"cpu",kernelFunc:IO};let cg=ie((n,t)=>n*t),TO=ig((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e})),ug=Ne(yo,cg,TO),EO={kernelName:yo,backendName:"cpu",kernelFunc:ug};function x0(n,t,e){let s=ss(-1,e);return cg([],t,s,n,e)}function AO(n){let{inputs:t,backend:e}=n,{x:s}=t;it(s,"neg");let r=e.data.get(s.dataId).values,[o,a]=x0(r,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,o)}let DO={kernelName:fi,backendName:"cpu",kernelFunc:AO};let w0=ie((n,t)=>n!==t?1:0),RO=Ne(mi,w0,null,"bool"),FO={kernelName:mi,backendName:"cpu",kernelFunc:RO};function hg(n,t,e,s,r){let o=t.length,a=H(t),i=pt(t),l=pt(r),c=ye(e,H(r));for(let u=0;u<a;++u){let h=Br(u,o,i),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];let p=In(d,o,l);c[p]=n[u]}return c}function vn(n){let{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:o}=e;it(r,"transpose");let a=r.shape.length,i=new Array(a);for(let h=0;h<i.length;h++)i[h]=r.shape[o[h]];let l=s.data.get(r.dataId).values,c=hg(l,r.shape,r.dtype,o,i);return{dataId:s.write(c,i,r.dtype),shape:i,dtype:r.dtype}}let _O={kernelName:Di,backendName:"cpu",kernelFunc:vn};function $0(n,t,e,s){let[r,o]=we(n,s),a=Ge(t,"int32"),i=Ie(H(r),a),l=H(o);for(let c=0;c<i.length;++c){let u=c*l,h=1;for(let d=0;d<l;++d)h*=e[u+d];i[c]=h}return{outVals:i,outShape:r,outDtype:a}}function OO(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;it(r,"prod");let i=r.shape.length,l=$t(o,r.shape),c=se(l,i),u=l,h=r,d=[];c!=null&&(h=vn({inputs:{x:r},backend:e,attrs:{perm:c}}),d.push(h),u=ae(u.length,i));let p=e.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=$0(h.shape,h.dtype,p,u),y=m;return a&&(y=ne(m,l)),d.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,f)}let LO={kernelName:Bc,backendName:"cpu",kernelFunc:OO};function v0(n,t,e,s){let r=n===t,o=n<t&&e<0,a=t<n&&e>1;if(r||o||a)return Ie(0,s);let i=Math.abs(Math.ceil((t-n)/e)),l=Ie(i,s);t<n&&e===1&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}let C0=ba(n=>1/Math.sqrt(n)),PO=xa(Co,C0),zO={kernelName:Co,backendName:"cpu",kernelFunc:PO};function N0(n,t,e,s,r){let o=Jd(s,t,e),a=H(e),i=pt(s);if(o){let h=Zd(t,i);return r==="string"?n.slice(h,h+a):n.subarray(h,h+a)}let l=r==="string"?cf(n):n,c=vt(s,r,l),u=vt(e,r);for(let h=0;h<u.size;++h){let d=u.indexToLoc(h),p=d.map((f,m)=>f+t[m]);u.set(c.get(...p),...d)}return r==="string"?_b(u.values):u.values}function Fr(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:o,size:a}=s;it(r,"slice");let[i,l]=pu(r,o,a);Yd(r,i,l);let c=e.data.get(r.dataId).values,u=N0(c,i,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,u)}let MO={kernelName:Ii,backendName:"cpu",kernelFunc:Fr};let k0=ie((n,t)=>{let e=n-t;return e*e}),BO=Ne(Do,k0),VO={kernelName:Do,backendName:"cpu",kernelFunc:BO};function I0(n,t,e,s){let r=vt(n,t.dtype);for(let o=0;o<r.size;o++){let a=r.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*e[l]+s[l];r.set(t.get(...i),...a)}return r}let S0=ie((n,t)=>n-t),WO=ig((n,t,e,s)=>({real:n-e,imag:t-s})),dg=Ne(Ro,S0,WO),UO={kernelName:Ro,backendName:"cpu",kernelFunc:dg};function T0(n,t){let e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];let s=vt(e,n.dtype);for(let r=0;r<s.values.length;++r){let o=s.indexToLoc(r),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%n.shape[l];let i=n.locToIndex(a);s.values[r]=n.values[i]}return s}function E0(n,t,e,s,r){let o=t[t.length-1],[a,i]=[n.length/o,o],l=ye(e,a*s),c=ye("int32",a*s);for(let h=0;h<a;h++){let d=h*i,p=n.subarray(d,d+i),f=[];for(let b=0;b<p.length;b++)f.push({value:p[b],index:b});f.sort((b,C)=>C.value-b.value);let m=h*s,g=l.subarray(m,m+s),y=c.subarray(m,m+s);for(let b=0;b<s;b++)g[b]=f[b].value,y[b]=f[b].index}let u=t.slice();return u[u.length-1]=s,[vt(u,e,l),vt(u,"int32",c)]}function A0(n,t,e,s){let r=$t(t,e)[0],o=[1,e[0],1];for(let f=0;f<r;f++)o[0]*=e[f];o[1]=e[r];for(let f=r+1;f<e.length;f++)o[2]*=e[f];let a={},i=new Int32Array(e[r]),l=new ce(o,s,n),c=[],u=o[0]===1&&o[2]===1;for(let f=0;f<e[r];f++){let m;if(u)m=n[f].toString();else{let g=[];for(let y=0;y<o[0];y++)for(let b=0;b<o[2];b++)g.push(l.get(y,f,b));m=g.join(",")}if(a[m]!==void 0)i[f]=a[m];else{let g=Object.keys(a).length;a[m]=g,i[f]=g,c.push(f)}}let h=o.slice();h[1]=Object.keys(a).length;let d=new ce(h,s);c.forEach((f,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)d.set(l.get(g,f,y),g,m,y)});let p=e.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:i}}var GO=Object.freeze({__proto__:null,simpleAbsImpl:n0,addImpl:s0,bincountImpl:lg,bincountReduceImpl:r0,ceilImpl:o0,concatImpl:a0,expImpl:i0,expm1Impl:c0,floorImpl:u0,gatherV2Impl:h0,greaterImpl:d0,lessImpl:p0,linSpaceImpl:f0,logImpl:m0,maxImpl:g0,maximumImpl:y0,minimumImpl:b0,multiplyImpl:cg,negImpl:x0,notEqualImpl:w0,prodImpl:$0,rangeImpl:v0,rsqrtImpl:C0,sliceImpl:N0,squaredDifferenceImpl:k0,stridedSliceImpl:I0,subImpl:S0,tileImpl:T0,topKImpl:E0,transposeImpl:hg,uniqueImpl:A0});let HO="3.2.0";sp("cpu",()=>new Hh,1);let D0=Ft(to,n=>n>=0?n:Math.exp(n)-1),jO={kernelName:to,backendName:"cpu",kernelFunc:D0};function R0(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:o}=s;it([r],"leakyRelu");let a=H(r.shape),i=e.data.get(r.dataId).values,l=ye("float32",a);for(let c=0;c<i.length;c++)l[c]=i[c]<0?o*i[c]:i[c];return e.makeTensorInfo(r.shape,"float32",l)}let qO={kernelName:ei,backendName:"cpu",kernelFunc:R0};let KO=ie((n,t)=>n<0?t*n:n);function F0(n){let{inputs:t,backend:e}=n,{x:s,alpha:r}=t;it([s,r],"prelu");let o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,[i,l]=KO(s.shape,r.shape,o,a,s.dtype);return e.makeTensorInfo(l,s.dtype,i)}let XO={kernelName:wi,backendName:"cpu",kernelFunc:F0};let _0=Ft(wo,n=>Math.max(0,n)),YO={kernelName:wo,backendName:"cpu",kernelFunc:_0};let O0=Ft($o,n=>Math.min(Math.max(0,n),6)),JO={kernelName:$o,backendName:"cpu",kernelFunc:O0};function pg(n,t,e,s,r){if(e==="linear")return Qn({inputs:{x:t},backend:n});if(e==="relu")return _0({inputs:{x:t},backend:n});if(e==="elu")return D0({inputs:{x:t},backend:n});if(e==="relu6")return O0({inputs:{x:t},backend:n});if(e==="prelu")return F0({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return R0({inputs:{x:t},backend:n,attrs:{alpha:r}});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Kt(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:o}=s,a=H(r.shape),i=wd(o,a),l=H(i);N(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);let c=e.data.get(r.dataId);if(c.complexTensorInfos!=null){let u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=i,h.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}let ZO={kernelName:$i,backendName:"cpu",kernelFunc:Kt};function L0(n){let{inputs:t,backend:e,attrs:s}=n,{a:r,b:o}=t,{transposeA:a,transposeB:i}=s;it([r,o],"matMul");let l=r.shape.length,c=o.shape.length,u=a?r.shape[l-2]:r.shape[l-1],h=i?o.shape[c-1]:o.shape[c-2],d=a?r.shape[l-1]:r.shape[l-2],p=i?o.shape[c-2]:o.shape[c-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=H(f),y=H(m),b=g===y||g===1||y===1;N(l>=2&&c>=2&&b,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);let w=(g>y?r.shape.slice(0,-2):o.shape.slice(0,-2)).concat([d,p]);N(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);let v=a?[g,u,d]:[g,d,u],I=i?[y,p,h]:[y,h,p],k=Kt({inputs:{x:r},backend:e,attrs:{shape:v}}),T=Kt({inputs:{x:o},backend:e,attrs:{shape:I}}),E=a?k.shape[1]:k.shape[2],F=a?k.shape[2]:k.shape[1],P=i?T.shape[1]:T.shape[2],M=Math.max(g,y),z=e.data.get(k.dataId).values,U=e.data.get(T.dataId).values,B=pt(k.shape),V=pt(T.shape),[K,j,q]=a?[B[0],1,B[1]]:[B[0],B[1],1],[J,Y,tt]=i?[1,V[1],V[0]]:[V[1],1,V[0]],Q=F*P,et=vt([M,F,P],k.dtype),nt=et.values,st=e.blockSize;for(let ct=0;ct<M;ct++)for(let ft=0;ft<F;ft+=st)for(let mt=0;mt<P;mt+=st)for(let xt=0;xt<E;xt+=st){let kt=Math.min(ft+st,F),_t=Math.min(mt+st,P),te=Math.min(xt+st,E);for(let Wt=ft;Wt<kt;Wt++)for(let Bt=mt;Bt<_t;Bt++){let Vt=0;for(let Ut=xt;Ut<te;Ut++){let oe=Math.min(ct,g-1)*K,ws=Math.min(ct,y-1)*tt,Fe=z[oe+Wt*j+Ut*q],es=U[Ut*J+Bt*Y+ws];Vt+=Fe*es}nt[ct*Q+(Wt*P+Bt)]+=Vt}}return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(T),e.makeTensorInfo(w,et.dtype,et.values)}let QO={kernelName:Ba,backendName:"cpu",kernelFunc:L0};function tL(n){let{inputs:t,backend:e,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s,d,p,f,m=[];d=L0({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:c},backend:e}),a&&(p=jl({inputs:{a:d,b:a},backend:e}),m.push(d),d=p),u&&(f=pg(e,d,u,i,h),m.push(d),d=f);for(let y of m)e.disposeIntermediateTensorInfo(y);return d}let eL={kernelName:Oi,backendName:"cpu",kernelFunc:tL};let nL=Ft(Vr,n=>Math.acos(n)),sL={kernelName:Vr,backendName:"cpu",kernelFunc:nL};let rL=Ft(Wr,n=>Math.acosh(n)),oL={kernelName:Wr,backendName:"cpu",kernelFunc:rL};function aL(n){let{inputs:t,backend:e}=n,s=t;it(t,"addN");let r=s.map(i=>e.data.get(i.dataId).values),o=vt(s[0].shape,s[0].dtype),a=o.values;for(let i=0;i<s.length;i++){let l=r[i];for(let c=0;c<a.length;c++)a[c]+=l[c]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}let iL={kernelName:Oa,backendName:"cpu",kernelFunc:aL};function lL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;it(r,"all");let i=$t(o,r.shape),l=i,c=se(l,r.shape.length),u=r;c!=null&&(u=vn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=ae(l.length,r.shape.length)),Ee("all",l,u.shape.length);let[h,d]=we(u.shape,l),p=H(d),f=Ie(H(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,C=m[b];for(let w=0;w<p;++w){let v=m[b+w];C=C&&v}f[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let g=e.makeTensorInfo(h,u.dtype,f);if(a){let y=ne(h,i),b=Kt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}let cL={kernelName:ic,backendName:"cpu",kernelFunc:lL};function uL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;it(r,"any");let i=$t(o,r.shape),l=i,c=se(l,r.shape.length),u=r;c!=null&&(u=vn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=ae(l.length,r.shape.length)),Ee("any",l,u.shape.length);let[h,d]=we(u.shape,l),p=H(d),f=Ie(H(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,C=m[b];for(let w=0;w<p;++w){let v=m[b+w];C=C||v}f[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let g=e.makeTensorInfo(h,u.dtype,f);if(a){let y=ne(h,i),b=Kt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}let hL={kernelName:lc,backendName:"cpu",kernelFunc:uL};function dL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o}=s;it(r,"argMax");let a=$t(o,r.shape),i=se(a,r.shape.length),l=r,c=[];i!=null&&(l=vn({inputs:{x:r},backend:e,attrs:{perm:i}}),c.push(l),a=ae(a.length,l.shape.length)),a=[a[0]],Ee("argMax",a,l.shape.length);let[u,h]=we(l.shape,a),d=H(u),p=Ie(d,"int32"),f=H(h),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],C=0;for(let w=0;w<f;++w){let v=m[y+w];v>b&&(b=v,C=w)}p[g]=C}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",p)}let pL={kernelName:La,backendName:"cpu",kernelFunc:dL};function fL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o}=s;it(r,"argMin");let a=$t(o,r.shape),i=se(a,r.shape.length),l=r,c=[];i!=null&&(l=vn({inputs:{x:r},backend:e,attrs:{perm:i}}),c.push(l),a=ae(a.length,l.shape.length)),a=[a[0]],Ee("argMin",a,l.shape.length);let[u,h]=we(l.shape,a),d=H(u),p=Ie(d,"int32"),f=H(h),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],C=0;for(let w=0;w<f;++w){let v=m[y+w];v<b&&(b=v,C=w)}p[g]=C}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",p)}let mL={kernelName:Pa,backendName:"cpu",kernelFunc:fL};let gL=Ft(Ur,n=>Math.asin(n)),yL={kernelName:Ur,backendName:"cpu",kernelFunc:gL};let bL=Ft(Gr,n=>Math.asinh(n)),xL={kernelName:Gr,backendName:"cpu",kernelFunc:bL};let wL=Ft(Hr,n=>Math.atan(n)),$L={kernelName:Hr,backendName:"cpu",kernelFunc:wL};let vL=ie((n,t)=>Math.atan2(n,t)),CL=Ne(qr,vL),NL={kernelName:qr,backendName:"cpu",kernelFunc:CL};let kL=Ft(jr,n=>Math.atanh(n)),IL={kernelName:jr,backendName:"cpu",kernelFunc:kL};function fg(n,t,e,s,r,o){let a=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=vt(r.outShape,e),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],C=r.outShape[3];for(let w=0;w<r.batchSize;++w){let v=w*y,I=w*s[0];for(let k=0;k<r.inChannels;++k)for(let T=0;T<r.outHeight;++T){let E=T*a-d,F=Math.max(0,E),P=Math.min(r.inHeight,u+E),M=v+T*b;for(let z=0;z<r.outWidth;++z){let U=z*i-p,B=Math.max(0,U),V=Math.min(r.inWidth,h+U),K=f,j=0,q=0;for(let Y=F;Y<P;Y+=l){let tt=I+Y*s[1];for(let Q=B;Q<V;Q+=c){let et=tt+Q*s[2],nt=n[et+k];o==="max"&&nt>K?K=nt:o==="avg"&&(j+=nt,q++)}if(isNaN(K))break}let J=M+z*C+k;g[J]=o==="avg"?j/q:K}}}return m}function P0(n,t,e,s,r=!1,o=!1){let a=vt(s.outShape,"int32"),i=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=vt(t,e,n);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let b=0;b<s.outHeight;++b){let C=b*i-p,w=C;for(;w<0;)w+=c;let v=Math.min(s.inHeight,h+C);for(let I=0;I<s.outWidth;++I){let k=I*l-f,T=k;for(;T<0;)T+=u;let E=Math.min(s.inWidth,d+k),F=Number.NEGATIVE_INFINITY,P=-1;for(let M=w;M<v;M+=c){let z=M-C;for(let U=T;U<E;U+=u){let B=U-k,V=m.get(g,M,U,y);V>F&&(F=V,r?P=o?((g*s.inHeight+M)*s.inWidth+U)*s.inChannels+y:(M*s.inWidth+U)*s.inChannels+y:P=z*d+B)}}a.set(P,g,b,I,y)}}return a}function z0(n,t,e,s,r,o){let a=r.strideDepth,i=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=vt(r.outShape,e),w=C.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],T=r.outShape[4];for(let E=0;E<r.batchSize;++E){let F=E*v,P=E*s[0];for(let M=0;M<r.inChannels;++M)for(let z=0;z<r.outDepth;++z){let U=z*a-m,B=U;for(;B<0;)B+=c;let V=Math.min(r.inDepth,d+U),K=F+z*I;for(let j=0;j<r.outHeight;++j){let q=j*i-g,J=q;for(;J<0;)J+=u;let Y=Math.min(r.inHeight,p+q),tt=K+j*k;for(let Q=0;Q<r.outWidth;++Q){let et=Q*l-y,nt=et;for(;nt<0;)nt+=h;let st=Math.min(r.inWidth,f+et),ct=tt+Q*T,ft=b,mt=0,xt=0;for(let _t=B;_t<V;_t+=c){let te=P+_t*s[1];for(let Wt=J;Wt<Y;Wt+=u){let Bt=te+Wt*s[2];for(let Vt=nt;Vt<st;Vt+=h){let Ut=Bt+Vt*s[3],oe=n[Ut+M];if(o==="max"&&oe>ft?ft=oe:o==="avg"&&(mt+=oe,xt++),isNaN(ft))break}if(isNaN(ft))break}if(isNaN(ft))break}let kt=ct+M;w[kt]=o==="avg"?mt/xt:ft}}}}return C}function SL(n,t){let e=vt(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*s-d,C=b;for(;C<0;)C+=a;let w=Math.min(t.inDepth,c+b);for(let v=0;v<t.outHeight;++v){let I=v*r-p,k=I;for(;k<0;)k+=i;let T=Math.min(t.inHeight,u+I);for(let E=0;E<t.outWidth;++E){let F=E*o-f,P=F;for(;P<0;)P+=l;let M=Math.min(t.inWidth,h+F),z=Number.NEGATIVE_INFINITY,U=-1;for(let B=C;B<w;B+=a){let V=B-b;for(let K=k;K<T;K+=i){let j=K-I;for(let q=P;q<M;q+=l){let J=q-F,Y=n.get(m,B,K,q,g);Y>=z&&(z=Y,U=V*u*h+j*u+J)}}}e.set(U,m,y,v,E,g)}}}return e}function TL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t;it(r,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,c=1;N(Te(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let u=mn(r.shape,o,a,c,i,l),h;if(u.filterWidth===1&&u.filterHeight===1&&At(u.inShape,u.outShape))h=Qn({inputs:{x:r},backend:e});else{let d=e.data.get(r.dataId).values,p=pt(r.shape),f=fg(d,r.shape,r.dtype,p,u,"avg");h=e.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}let EL={kernelName:za,backendName:"cpu",kernelFunc:TL};function AL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=s;it(r,"avgPool3d");let u=as(r.shape,o,a,1,i,l,c),h=e.data.get(r.dataId).values,d=z0(h,r.shape,r.dtype,pt(r.shape),u,"avg");return e.makeTensorInfo(d.shape,"float32",d.values)}let DL={kernelName:Ma,backendName:"cpu",kernelFunc:AL};function RL(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:c}=s;it([r,o],"avgPool3DGrad");let u=as(o.shape,a,i,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,C=u.dilationWidth,w=u.effectiveFilterDepth,v=u.effectiveFilterHeight,I=u.effectiveFilterWidth,k=w-1-u.padInfo.front,T=I-1-u.padInfo.left,E=v-1-u.padInfo.top,F=vt(o.shape,"float32"),P=1/(f*m*g),M=e.bufferSync(r);for(let z=0;z<u.batchSize;++z)for(let U=0;U<u.inChannels;++U)for(let B=0;B<u.inDepth;++B)for(let V=0;V<u.inHeight;++V)for(let K=0;K<u.inWidth;++K){let j=B-k,q=V-E,J=K-T,Y=0;for(let tt=0;tt<w;tt+=y){let Q=(j+tt)/h;if(!(Q<0||Q>=u.outDepth||Math.floor(Q)!==Q))for(let et=0;et<v;et+=b){let nt=(q+et)/d;if(!(nt<0||nt>=u.outHeight||Math.floor(nt)!==nt))for(let st=0;st<I;st+=C){let ct=(J+st)/p;if(ct<0||ct>=u.outWidth||Math.floor(ct)!==ct)continue;Y+=M.get(z,Q,nt,ct,U)}}}F.set(Y*P,z,B,V,K,U)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}let FL={kernelName:uc,backendName:"cpu",kernelFunc:RL};function _L(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,a=o;it([r,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:c}=s,u=mn(a.shape,i,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,C=b-1-u.padInfo.left,w=y-1-u.padInfo.top,v=vt(a.shape,"float32"),I=1/(p*f),k=e.data.get(r.dataId).values,T=vt(r.shape,"float32",k);for(let E=0;E<u.batchSize;++E)for(let F=0;F<u.inChannels;++F)for(let P=0;P<u.inHeight;++P)for(let M=0;M<u.inWidth;++M){let z=P-w,U=M-C,B=0;for(let V=0;V<y;V+=m){let K=(z+V)/h;if(!(K<0||K>=u.outHeight||Math.floor(K)!==K))for(let j=0;j<b;j+=g){let q=(U+j)/d;if(q<0||q>=u.outWidth||Math.floor(q)!==q)continue;B+=T.get(E,K,q,F)}}v.set(B*I,E,P,M,F)}return e.makeTensorInfo(v.shape,v.dtype,v.values)}let OL={kernelName:cc,backendName:"cpu",kernelFunc:_L};function LL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,scale:o,offset:a,mean:i,variance:l}=t;N(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),it([r,i,l,o,a],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);let u=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=e.data.get(l.dataId).values,p=o?e.data.get(o.dataId).values:new Float32Array([1]),f=a?e.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,C=h.length,w=0,v=0,I=0,k=0;for(let T=0;T<u.length;++T)m[T]=f[w++]+(u[T]-h[v++])*p[I++]/Math.sqrt(d[k++]+c),w>=g&&(w=0),v>=C&&(v=0),I>=y&&(I=0),k>=b&&(k=0);return e.makeTensorInfo(r.shape,r.dtype,m)}let PL={kernelName:Za,backendName:"cpu",kernelFunc:LL};function zL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:o,crops:a}=s;it([r],"batchToSpaceND");let i=o.reduce((y,b)=>y*b),l=yl(r.shape,o,i),c=bl(l.length,o.length),u=xl(r.shape,o,i),h=Jp(a,o.length),d=Zp(u,a,o.length),p=Kt({inputs:{x:r},backend:e,attrs:{shape:l}}),f=vn({inputs:{x:p},backend:e,attrs:{perm:c}}),m=Kt({inputs:{x:f},backend:e,attrs:{shape:u}}),g=Fr({inputs:{x:m},backend:e,attrs:{begin:h,size:d}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}let ML={kernelName:Va,backendName:"cpu",kernelFunc:zL};function BL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,weights:o}=t,{size:a}=s,i=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,c=lg(i,l,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,c)}let VL={kernelName:hc,backendName:"cpu",kernelFunc:BL};let WL=Ft(Yr,(n,t)=>{let e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),UL={kernelName:Yr,backendName:"cpu",kernelFunc:WL};let GL={kernelName:Wa,backendName:"cpu",kernelFunc:n=>{let{x:t}=n.inputs,e=n.backend,s=new Float32Array(H(t.shape)),r=e.data.get(t.dataId),o=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,i=e.data.get(o.dataId).values,l=e.data.get(a.dataId).values;for(let c=0;c<i.length;c++){let u=i[c],h=l[c];s[c]=Math.hypot(u,h)}return e.makeOutput(s,t.shape,"float32")}};function wa(n){let{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,o=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,o)}let HL={kernelName:Ac,backendName:"cpu",kernelFunc:wa};function $a(n){let{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,o=$t(r,t[0].shape)[0],a=ds(t.map(m=>m.shape),o);if(H(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(m=>H(m.shape)>0);if(i.length===1)return Qn({inputs:{x:i[0]},backend:e});let l=i.map(m=>m.shape);if(Kp(l,o),i[0].dtype==="complex64"){let m=i.map(w=>Rr({inputs:{input:w},backend:e})),g=i.map(w=>wa({inputs:{input:w},backend:e})),y=$a({inputs:m,backend:e,attrs:{axis:o}}),b=$a({inputs:g,backend:e,attrs:{axis:o}}),C=en({inputs:{real:y,imag:b},backend:e});return m.forEach(w=>e.disposeIntermediateTensorInfo(w)),g.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),C}let c=i.map(m=>{let g=H(m.shape.slice(o));return Kt({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=ds(c.map(m=>m.shape),1);let h=c[0].shape[0]===1,d=a0(u,a,t[0].dtype,h),p=ds(i.map(m=>m.shape),o),f=e.makeTensorInfo(p,t[0].dtype,d);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}let jL={kernelName:Ua,backendName:"cpu",kernelFunc:$a};function M0(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=s;it([r,o],"conv2d");let h=is(l),d=xe(r.shape,o.shape,a,c,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,C=d.dataFormat==="channelsLast",w=new ce(d.outShape,r.dtype),v=pt(r.shape),I=pt(o.shape),k=v[0],T=C?v[1]:v[2],E=C?v[2]:1,F=C?1:v[1],P=w.strides[0],M=C?w.strides[1]:w.strides[2],z=C?w.strides[2]:1,U=C?1:w.strides[1],B=e.data.get(r.dataId).values,V=e.data.get(o.dataId).values,K=w.values;for(let j=0;j<d.batchSize;++j){let q=j*k,J=j*P;for(let Y=0;Y<d.outHeight;++Y){let tt=J+Y*M,Q=Y*d.strideHeight-b;for(let et=0;et<p;++et){let nt=Q+et*m;if(nt<0||nt>=d.inHeight)continue;let st=et*I[0],ct=q+nt*T;for(let ft=0;ft<d.outWidth;++ft){let mt=tt+ft*z,xt=ft*d.strideWidth-y;for(let kt=0;kt<f;++kt){let _t=xt+kt*g;if(_t<0||_t>=d.inWidth)continue;let te=st+kt*I[1],Wt=ct+_t*E,Bt=te;for(let Vt=0;Vt<d.inChannels;++Vt){let Ut=B[Wt+Vt*F];for(let oe=0;oe<d.outChannels;++oe)K[mt+oe*U]+=Ut*V[Bt+oe];Bt+=d.outChannels}}}}}}return e.makeTensorInfo(w.shape,w.dtype,K)}let qL={kernelName:Ga,backendName:"cpu",kernelFunc:M0};function KL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;it([r,o],"conv2dBackpropFilter");let h=is(l),d=xe(r.shape,u,a,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",b=new ce(d.filterShape,"float32"),C=d.padInfo.left,w=d.padInfo.top,v=e.data.get(r.dataId).values,I=e.data.get(o.dataId).values,k=new ce(r.shape,r.dtype,v),T=new ce(o.shape,o.dtype,I);for(let E=0;E<m;++E){let F=Math.max(0,Math.ceil((w-E)/p)),P=Math.min(d.outHeight,(d.inHeight+w-E)/p);for(let M=0;M<g;++M){let z=Math.max(0,Math.ceil((C-M)/f)),U=Math.min(d.outWidth,(d.inWidth+C-M)/f);for(let B=0;B<d.inChannels;++B)for(let V=0;V<d.outChannels;++V){let K=0;for(let j=0;j<d.batchSize;++j)for(let q=F;q<P;++q){let J=E+q*p-w;for(let Y=z;Y<U;++Y){let tt=M+Y*f-C;y?K+=k.get(j,J,tt,B)*T.get(j,q,Y,V):K+=k.get(j,B,J,tt)*T.get(j,V,q,Y)}}b.set(K,E,M,B,V)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}let XL={kernelName:pc,backendName:"cpu",kernelFunc:KL};function YL(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=s;it([r,o],"conv2dBackpropInput");let h=pt(o.shape),d=pt(r.shape),p=is(c),f=xe(a,o.shape,i,1,l,u,!1,p),m=new ce(f.inShape,"float32"),g=m.values,y=e.data.get(r.dataId).values,b=e.data.get(o.dataId).values,[C,w,v]=h,{batchSize:I,filterHeight:k,filterWidth:T,inChannels:E,inHeight:F,inWidth:P,outChannels:M,outHeight:z,outWidth:U,strideHeight:B,strideWidth:V}=f;p=f.dataFormat;let K=k-1-f.padInfo.top,j=T-1-f.padInfo.left,q=p==="channelsLast",J=m.strides[0],Y=q?m.strides[1]:m.strides[2],tt=q?m.strides[2]:1,Q=q?1:m.strides[1],et=d[0],nt=q?d[1]:d[2],st=q?d[2]:1,ct=q?1:d[1];for(let ft=0;ft<I;++ft)for(let mt=0;mt<E;++mt)for(let xt=0;xt<F;++xt){let kt=xt-K,_t=Math.max(0,Math.ceil(kt/B)),te=Math.min(z,(k+kt)/B);for(let Wt=0;Wt<P;++Wt){let Bt=Wt-j,Vt=Math.max(0,Math.ceil(Bt/V)),Ut=Math.min(U,(T+Bt)/V),oe=0;for(let Fe=_t;Fe<te;++Fe){let es=Fe*B-kt;for(let pn=Vt;pn<Ut;++pn){let Pr=pn*V-Bt,zn=et*ft+nt*Fe+st*pn,$s=C*(k-1-es)+w*(T-1-Pr)+v*mt;for(let Xs=0;Xs<M;++Xs){let Ys=y[zn+ct*Xs],Js=b[$s+Xs];oe+=Ys*Js}}}let ws=J*ft+Y*xt+tt*Wt+Q*mt;g[ws]=oe}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}let JL={kernelName:Ha,backendName:"cpu",kernelFunc:YL};function ZL(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dilations:l}=s;it([r,o],"conv3d");let c=Es(r.shape,o.shape,a,l,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,C=g.top,w=new ce(c.outShape,r.dtype),v=e.data.get(r.dataId).values,I=e.data.get(o.dataId).values,k=w.values,T=pt(r.shape),E=pt(o.shape);for(let F=0;F<c.batchSize;++F){let P=F*T[0],M=F*w.strides[0];for(let z=0;z<c.outDepth;++z){let U=M+z*w.strides[1],B=z*c.strideDepth-y;for(let V=0;V<u;++V){let K=B+V*p;if(K<0||K>=c.inDepth)continue;let j=V*E[0],q=P+K*T[1];for(let J=0;J<c.outHeight;++J){let Y=U+J*w.strides[2],tt=J*c.strideHeight-C;for(let Q=0;Q<h;++Q){let et=tt+Q*f;if(et<0||et>=c.inHeight)continue;let nt=j+Q*E[1],st=q+et*T[2];for(let ct=0;ct<c.outWidth;++ct){let ft=Y+ct*c.outChannels,mt=ct*c.strideWidth-b;for(let xt=0;xt<d;++xt){let kt=mt+xt*m;if(kt<0||kt>=c.inWidth)continue;let _t=nt+xt*E[2],te=st+kt*c.inChannels,Wt=_t;for(let Bt=0;Bt<c.inChannels;++Bt){let Vt=v[te+Bt];for(let Ut=0;Ut<c.outChannels;++Ut)k[ft+Ut]+=Vt*I[Wt+Ut];Wt+=c.outChannels}}}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}let QL={kernelName:ja,backendName:"cpu",kernelFunc:ZL};function tP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,pad:i,filterShape:l}=s;it([r,o],"conv3dBackpropFilterV2");let c=pt(r.shape),u=pt(o.shape),h=Es(r.shape,l,a,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new ce(h.filterShape,"float32"),C=b.values,[w,v,I,k]=b.strides,T=e.data.get(o.dataId).values,[E,F,P,M]=u,z=e.data.get(r.dataId).values,[U,B,V,K]=c,j=h.padInfo.front,q=h.padInfo.left,J=h.padInfo.top;for(let Y=0;Y<m;++Y){let tt=Math.max(0,Math.ceil((j-Y)/d)),Q=Math.min(h.outDepth,(h.inDepth+j-Y)/d),et=Y*w;for(let nt=0;nt<g;++nt){let st=Math.max(0,Math.ceil((J-nt)/p)),ct=Math.min(h.outHeight,(h.inHeight+J-nt)/p),ft=nt*v+et;for(let mt=0;mt<y;++mt){let xt=Math.max(0,Math.ceil((q-mt)/f)),kt=Math.min(h.outWidth,(h.inWidth+q-mt)/f),_t=mt*I+ft;for(let te=0;te<h.inChannels;++te){let Wt=te*k+_t;for(let Bt=0;Bt<h.outChannels;++Bt){let Vt=0;for(let Ut=0;Ut<h.batchSize;++Ut){let oe=Ut*U,ws=Ut*E;for(let Fe=tt;Fe<Q;++Fe){let pn=(Y+Fe*d-j)*B+oe,Pr=Fe*F+ws;for(let zn=st;zn<ct;++zn){let Xs=(nt+zn*p-J)*V+pn,Ys=zn*P+Pr;for(let Js=xt;Js<kt;++Js){let Fg=(mt+Js*f-q)*K+Xs,_g=Js*M+Ys;Vt+=z[Fg+te]*T[_g+Bt]}}}}C[Wt+Bt]=Vt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}let eP={kernelName:fc,backendName:"cpu",kernelFunc:tP};function nP(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{pad:a,strides:i,inputShape:l}=s;it([r],"conv3dBackpropInputV2");let c=pt(r.shape),u=pt(o.shape),h=Es(l,o.shape,i,1,a),d=new ce(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=e.data.get(r.dataId).values,[C,w,v,I]=c,k=e.data.get(o.dataId).values,[T,E,F,P]=u,{batchSize:M,filterDepth:z,filterHeight:U,filterWidth:B,inChannels:V,inDepth:K,inHeight:j,inWidth:q,outChannels:J,outDepth:Y,outHeight:tt,outWidth:Q,strideDepth:et,strideHeight:nt,strideWidth:st}=h,ct=z-1-h.padInfo.front,ft=U-1-h.padInfo.top,mt=B-1-h.padInfo.left;for(let xt=0;xt<M;++xt)for(let kt=0;kt<V;++kt)for(let _t=0;_t<K;++_t){let te=_t-ct,Wt=Math.max(0,Math.ceil(te/et)),Bt=Math.min(Y,(z+te)/et);for(let Vt=0;Vt<j;++Vt){let Ut=Vt-ft,oe=Math.max(0,Math.ceil(Ut/nt)),ws=Math.min(tt,(U+Ut)/nt);for(let Fe=0;Fe<q;++Fe){let es=Fe-mt,pn=Math.max(0,Math.ceil(es/st)),Pr=Math.min(Q,(B+es)/st),zn=0;for(let $s=Wt;$s<Bt;++$s){let Xs=$s*et-te;for(let Ys=oe;Ys<ws;++Ys){let Js=Ys*nt-Ut;for(let nc=pn;nc<Pr;++nc){let Fg=nc*st-es,_g=C*xt+w*$s+v*Ys+I*nc,mK=T*(z-1-Xs)+E*(U-1-Js)+F*(B-1-Fg)+P*kt;for(let fd=0;fd<J;++fd){let gK=b[_g+fd],yK=k[mK+fd];zn+=gK*yK}}}}p[f*xt+m*_t+g*Vt+y*Fe+kt]=zn}}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}let sP={kernelName:mc,backendName:"cpu",kernelFunc:nP};let rP=Ft(Jr,n=>Math.cos(n)),oP={kernelName:Jr,backendName:"cpu",kernelFunc:rP};let aP=Ft(Zr,n=>Math.cosh(n)),iP={kernelName:Zr,backendName:"cpu",kernelFunc:aP};function lP(n){let{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:c}=s,[u,h,d,p]=r.shape,f=o.shape[0],[m,g]=i,y=vt([f,m,g,p],"float32"),b=e.data.get(o.dataId).values,C=e.data.get(a.dataId).values,w=e.data.get(r.dataId).values,v=pt(r.shape),I=pt(y.shape);for(let k=0;k<f;k++){let T=k*4,E=b[T],F=b[T+1],P=b[T+2],M=b[T+3],z=C[k];if(z>=u)continue;let U=m>1?(P-E)*(h-1)/(m-1):0,B=g>1?(M-F)*(d-1)/(g-1):0;for(let V=0;V<m;V++){let K=m>1?E*(h-1)+V*U:.5*(E+P)*(h-1);if(K<0||K>h-1){for(let j=0;j<g;j++)for(let q=0;q<p;q++){let J=q+j*I[2]+V*I[1]+k*I[0];y.values[J]=c}continue}if(l==="bilinear"){let j=Math.floor(K),q=Math.ceil(K),J=K-j;for(let Y=0;Y<g;Y++){let tt=g>1?F*(d-1)+Y*B:.5*(F+M)*(d-1);if(tt<0||tt>d-1){for(let st=0;st<p;st++){let ct=st+Y*I[2]+V*I[1]+k*I[0];y.values[ct]=c}continue}let Q=Math.floor(tt),et=Math.ceil(tt),nt=tt-Q;for(let st=0;st<p;st++){let ct=st+Q*v[2]+j*v[1]+z*v[0],ft=w[ct];ct=st+et*v[2]+j*v[1]+z*v[0];let mt=w[ct];ct=st+Q*v[2]+q*v[1]+z*v[0];let xt=w[ct];ct=st+et*v[2]+q*v[1]+z*v[0];let kt=w[ct],_t=ft+(mt-ft)*nt,te=xt+(kt-xt)*nt;ct=st+Y*I[2]+V*I[1]+k*I[0],y.values[ct]=_t+(te-_t)*J}}}else for(let j=0;j<g;++j){let q=g>1?F*(d-1)+j*B:.5*(F+M)*(d-1);if(q<0||q>d-1){for(let tt=0;tt<p;tt++){let Q=tt+j*I[2]+V*I[1]+k*I[0];y.values[Q]=c}continue}let J=Math.round(q),Y=Math.round(K);for(let tt=0;tt<p;tt++){let Q=tt+J*v[2]+Y*v[1]+z*v[0],et=tt+j*I[2]+V*I[1]+k*I[0];y.values[et]=w[Q]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}let cP={kernelName:gc,backendName:"cpu",kernelFunc:lP};function uP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,exclusive:a,reverse:i}=s;it(r,"cumsum");let l=se([o],r.shape.length),c=r;l!=null&&(c=vn({inputs:{x:r},backend:e,attrs:{perm:l}}));let u=ae(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let h=Ge(c.dtype,"int32"),d=Ie(H(c.shape),h),p=e.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=i?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){let C=m(y,b);if(b===0)d[C]=a?0:p[C];else{let w=m(y,b-1);d[C]=a?p[w]+d[w]:p[C]+d[w]}}let g=e.makeTensorInfo(c.shape,h,d);if(l!=null){let y=Yo(l),b=vn({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}let hP={kernelName:qa,backendName:"cpu",kernelFunc:uP};function dP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,weights:o}=t,{size:a,binaryOutput:i}=s;if(r.shape.length===1){let l=e.data.get(r.dataId).values,c=e.data.get(o.dataId).values,u=lg(l,c,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,u)}else if(r.shape.length===2){let l=e.bufferSync(r),c=e.bufferSync(o),u=r0(l,c,a,i);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}let pP={kernelName:yc,backendName:"cpu",kernelFunc:dP};function fP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:o,dataFormat:a}=s;N(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),N(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=r.shape[0],l=r.shape[1],c=r.shape[2],u=r.shape[3],h=l*o,d=c*o,p=u/(o*o),f=e.data.get(r.dataId).values,m=new Float32Array(i*h*d*p),g=0;for(let y=0;y<i;++y)for(let b=0;b<h;++b){let C=Math.floor(b/o),w=b%o;for(let v=0;v<d;++v){let I=Math.floor(v/o),k=v%o,T=(w*o+k)*p;for(let E=0;E<p;++E){let P=E+T+u*(I+c*(C+l*y));m[g++]=f[P]}}}return e.makeTensorInfo([i,h,d,p],r.dtype,m)}let mP={kernelName:bc,backendName:"cpu",kernelFunc:fP};function B0(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:c}=s;it([r,o],"depthwiseConv2DNative");let u=pt(r.shape),h=pt(o.shape),d=l;d==null&&(d=[1,1]),N(Te(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);let p=xe(r.shape,o.shape,a,d,i,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,C=b.left,w=b.top,v=p.outChannels/p.inChannels,I=new ce(p.outShape,r.dtype),k=e.data.get(r.dataId).values,T=e.data.get(o.dataId).values,E=I.values;for(let F=0;F<p.batchSize;++F){let P=F*u[0],M=F*I.strides[0];for(let z=0;z<p.outHeight;++z){let U=M+z*I.strides[1],B=z*p.strideHeight-C;for(let V=0;V<f;++V){let K=B+V*g;if(K<0||K>=p.inHeight)continue;let j=V*h[0],q=P+K*u[1];for(let J=0;J<p.outWidth;++J){let Y=U+J*I.strides[2],tt=J*p.strideWidth-w;for(let Q=0;Q<m;++Q){let et=tt+Q*y;if(et<0||et>=p.inWidth)continue;let nt=j+Q*h[1],st=q+et*p.inChannels,ct=Y,ft=nt;for(let mt=0;mt<p.inChannels;++mt){let xt=k[st+mt];for(let kt=0;kt<v;++kt)E[ct+kt]+=xt*T[ft+kt];ct+=v,ft+=v}}}}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}let gP={kernelName:Ka,backendName:"cpu",kernelFunc:B0};function yP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=s;it([r,o],"depthwiseConv2dNativeBackpropFilter");let h=xe(r.shape,u,a,i,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new ce(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,C=h.outChannels/h.inChannels,w=e.data.get(r.dataId).values,v=new ce(r.shape,r.dtype,w),I=e.data.get(o.dataId).values,k=new ce(o.shape,o.dtype,I);for(let T=0;T<f;++T){let E=Math.max(0,Math.ceil((b-T)/d)),F=Math.min(h.outHeight,(h.inHeight+b-T)/d);for(let P=0;P<m;++P){let M=Math.max(0,Math.ceil((y-P)/p)),z=Math.min(h.outWidth,(h.inWidth+y-P)/p);for(let U=0;U<h.outChannels;++U){let B=Math.trunc(U/C),V=U%C,K=0;for(let j=0;j<h.batchSize;++j)for(let q=E;q<F;++q){let J=T+q*d-b;for(let Y=M;Y<z;++Y){let tt=P+Y*p-y;K+=v.get(j,J,tt,B)*k.get(j,q,Y,U)}}g.set(K,T,P,B,V)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}let bP={kernelName:xc,backendName:"cpu",kernelFunc:yP};function xP(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=s;it([r,o],"depthwiseConv2DNativeBackpropInput");let h=pt(r.shape),d=pt(o.shape),p=xe(u,o.shape,a,i,l,c,!0),f=new ce(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,C=e.data.get(r.dataId).values,[w,v,I]=h,k=e.data.get(o.dataId).values,[T,E,F]=d,{batchSize:P,filterHeight:M,filterWidth:z,inChannels:U,inHeight:B,inWidth:V,outChannels:K,outHeight:j,outWidth:q,strideHeight:J,strideWidth:Y}=p,tt=M-1-p.padInfo.top,Q=z-1-p.padInfo.left,et=K/U;for(let nt=0;nt<P;++nt)for(let st=0;st<U;++st)for(let ct=0;ct<B;++ct){let ft=ct-tt,mt=Math.max(0,Math.ceil(ft/J)),xt=Math.min(j,(M+ft)/J);for(let kt=0;kt<V;++kt){let _t=kt-Q,te=Math.max(0,Math.ceil(_t/Y)),Wt=Math.min(q,(z+_t)/Y),Bt=0;for(let Vt=mt;Vt<xt;++Vt){let Ut=Vt*J-ft;for(let oe=te;oe<Wt;++oe){let ws=oe*Y-_t,Fe=w*nt+v*Vt+I*oe,es=T*(M-1-Ut)+E*(z-1-ws)+F*st;for(let pn=0;pn<et;++pn){let Pr=st*et+pn,zn=C[Fe+Pr],$s=k[es+pn];Bt+=zn*$s}}}m[g*nt+y*ct+b*kt+st]=Bt}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}let wP={kernelName:wc,backendName:"cpu",kernelFunc:xP};function $P(n){let{inputs:t,backend:e}=n,{x:s}=t,r=H(s.shape),o=e.data.get(s.dataId).values,a=vt([r,r],s.dtype),i=a.values;for(let c=0;c<o.length;c++)i[c*r+c]=o[c];let l=[...s.shape,...s.shape];return e.makeTensorInfo(l,a.dtype,a.values)}let vP={kernelName:$c,backendName:"cpu",kernelFunc:$P};let CP={kernelName:Xa,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:s,filter:r}=n,{strides:o,pad:a,dilations:i}=e,l=t,c=l.data.get(s.dataId).values,u=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:C,strideHeight:w,strideWidth:v,filterHeight:I,filterWidth:k,dilationHeight:T,dilationWidth:E,outShape:F}=qi(s.shape,r.shape,o,a,"NHWC",i),P=H(F),M=F.length,z=er(s.dtype,P);for(let B=0;B<p;++B)for(let V=0;V<y;++V){let K=V*w-C.top;for(let j=0;j<b;++j){let q=j*v-C.left;for(let J=0;J<g;++J){let Y=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<I;++Q){let et=K+Q*T;if(et>=0&&et<f)for(let nt=0;nt<k;++nt){let st=q+nt*E;if(st>=0&&st<m){let ct=In([B,et,st,J],u,pt(s.shape)),ft=In([Q,nt,J],d,pt(r.shape)),mt=c[ct]+h[ft];mt>Y&&(Y=mt)}}}let tt=In([B,V,j,J],M,pt(F));z[tt]=Y}}}return{dataId:l.write(Ns(z,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};let NP={kernelName:Cc,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:s,filter:r,dy:o}=n,{strides:a,pad:i,dilations:l}=e,c=t,u=sn(s.shape,c.data.get(s.dataId).values),h=sn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:k,dilationWidth:T,outShape:E}=qi(s.shape,r.shape,a,i,"NHWC",l);N(o.rank===E.length,()=>`Error in ${Cc}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);let F=sn(E,c.data.get(o.dataId).values),P=Cd(r.shape,r.dtype);for(let z=0;z<d;++z)for(let U=0;U<g;++U){let B=U*C-b.top;for(let V=0;V<y;++V){let K=V*w-b.left;for(let j=0;j<m;++j){let q=Number.MIN_SAFE_INTEGER,J=0,Y=0;for(let tt=0;tt<v;++tt){let Q=B+tt*k;if(Q>=0&&Q<p)for(let et=0;et<I;++et){let nt=K+et*T;if(nt>=0&&nt<f){let st=u[z][Q][nt][j]+h[tt][et][j];st>q&&(q=st,J=tt,Y=et)}}}P[J][Y][j]+=F[z][U][V][j]}}}return{dataId:c.write(Ns(P,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};let kP={kernelName:vc,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:s,filter:r,dy:o}=n,{strides:a,pad:i,dilations:l}=e,c=t,u=sn(s.shape,c.data.get(s.dataId).values),h=sn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:k,dilationWidth:T,outShape:E}=qi(s.shape,r.shape,a,i,"NHWC",l);N(o.rank===E.length,()=>`Error in ${vc}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);let F=sn(E,c.data.get(o.dataId).values),P=Cd(s.shape,s.dtype);for(let z=0;z<d;++z)for(let U=0;U<g;++U){let B=U*C-b.top;for(let V=0;V<y;++V){let K=V*w-b.left;for(let j=0;j<m;++j){let q=Number.MIN_SAFE_INTEGER,J=B<0?0:B,Y=K<0?0:K;for(let tt=0;tt<v;++tt){let Q=B+tt*k;if(Q>=0&&Q<p)for(let et=0;et<I;++et){let nt=K+et*T;if(nt>=0&&nt<f){let st=u[z][Q][nt][j]+h[tt][et][j];st>q&&(q=st,J=Q,Y=nt)}}}P[z][J][Y][j]+=F[z][U][V][j]}}}return{dataId:c.write(Ns(P,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function IP(n){let{inputs:t,backend:e}=n,{dy:s,y:r}=t;it([s,r],"eluGrad");let o=new Float32Array(H(r.shape)),a=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values;for(let l=0;l<a.length;++l){let c=a[l];c>=1?o[l]=i[l]:o[l]=i[l]*(c+1)}return e.makeTensorInfo(r.shape,"float32",o)}let SP={kernelName:Nc,backendName:"cpu",kernelFunc:IP};let TP=ie((n,t)=>n===t?1:0),V0=Ne(Ya,TP,null,"bool"),EP={kernelName:Ya,backendName:"cpu",kernelFunc:V0};let AP=Qp,DP=tf,RP=ef,FP=nf,_P=sf,OP=rf,LP=Ft(eo,n=>{let t=Math.sign(n),e=Math.abs(n),s=1/(1+AP*e);return t*(1-((((OP*s+_P)*s+FP)*s+RP)*s+DP)*s*Math.exp(-e*e))}),PP={kernelName:eo,backendName:"cpu",kernelFunc:LP};function qh(n){let{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:o}=s,a=r.shape.length,i=r.shape.slice(),l=o;return o<0&&(N(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Kt({inputs:{x:r},backend:e,attrs:{shape:i}})}let zP={kernelName:Ja,backendName:"cpu",kernelFunc:qh};let MP=ie((n,t)=>n/t),mg=Ne(Qr,MP),gg={kernelName:Qr,backendName:"cpu",kernelFunc:mg};function W0(n,t,e){let s=n.shape,r=s[0],o=s[1],a=e.data.get(n.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[r,o],u=H(c),h=ye("float32",u),d=ye("float32",u);for(let g=0;g<r;g++){let y=Fr({inputs:{x:i},backend:e,attrs:{begin:[g,0],size:[1,o]}}),b=Fr({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,o]}}),C=en({inputs:{real:y,imag:b},backend:e}),{real:w,imag:v}=BP(C,t,e),I=ps(w,v);for(let k=0;k<o;k++){let T=of(I,k);h[g*o+k]=T.real,d[g*o+k]=T.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(C)}let p=e.makeTensorInfo(c,"float32",h),f=e.makeTensorInfo(c,"float32",d),m=en({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),m}function BP(n,t,e){let s=H(n.shape),r=e.data.get(n.dataId),o=e.data.get(r.complexTensorInfos.real.dataId).values,a=e.data.get(r.complexTensorInfos.imag.dataId).values;if(VP(s)){let i=yg(o,a,s,t,e),l=[n.shape[0],n.shape[1]];if(t){let c=e.makeTensorInfo(l,"float32",i.real),u=e.makeTensorInfo(l,"float32",i.imag),h=e.makeTensorInfo([],"float32",ss(s,"float32")),d=Qn({inputs:{x:h},backend:e}),p=gg.kernelFunc({inputs:{a:c,b:h},backend:e}),f=gg.kernelFunc({inputs:{a:u,b:d},backend:e}),m=e.data.get(p.dataId).values,g=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return i}else{let i=ps(o,a),l=WP(i,s,t);return Ib(l)}}function VP(n){return(n&n-1)==0}function yg(n,t,e,s,r){if(e===1)return{real:n,imag:t};let o=ps(n,t),a=e/2,i=Sb(o),l=i.real,c=i.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),d=r.makeTensorInfo(u,"float32",c),p=en({inputs:{real:h,imag:d},backend:r}),f=Tb(o),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),C=r.makeTensorInfo(y,"float32",g),w=en({inputs:{real:b,imag:C},backend:r}),v=yg(l,c,a,s,r),I=v.real,k=v.imag,T=[I.length],E=r.makeTensorInfo(T,"float32",I),F=r.makeTensorInfo(T,"float32",k),P=en({inputs:{real:E,imag:F},backend:r}),M=yg(m,g,a,s,r),z=M.real,U=M.imag,B=[z.length],V=r.makeTensorInfo(B,"float32",z),K=r.makeTensorInfo(B,"float32",U),j=en({inputs:{real:V,imag:K},backend:r}),q=Ab(e,s),J=[q.real.length],Y=r.makeTensorInfo(J,"float32",q.real),tt=r.makeTensorInfo(J,"float32",q.imag),Q=en({inputs:{real:Y,imag:tt},backend:r}),et=ug({inputs:{a:Q,b:j},backend:r}),nt=jl({inputs:{a:P,b:et},backend:r}),st=dg({inputs:{a:P,b:et},backend:r}),ct=Rr({inputs:{input:nt},backend:r}),ft=Rr({inputs:{input:st},backend:r}),mt=wa({inputs:{input:nt},backend:r}),xt=wa({inputs:{input:st},backend:r}),kt=$a({inputs:[ct,ft],backend:r,attrs:{axis:0}}),_t=$a({inputs:[mt,xt],backend:r,attrs:{axis:0}}),te=r.data.get(kt.dataId).values,Wt=r.data.get(_t.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(tt),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(et),r.disposeIntermediateTensorInfo(nt),r.disposeIntermediateTensorInfo(st),r.disposeIntermediateTensorInfo(ct),r.disposeIntermediateTensorInfo(mt),r.disposeIntermediateTensorInfo(ft),r.disposeIntermediateTensorInfo(xt),r.disposeIntermediateTensorInfo(kt),r.disposeIntermediateTensorInfo(_t),{real:te,imag:Wt}}function WP(n,t,e){let s=new Float32Array(t*2);for(let r=0;r<t;r++){let o=0,a=0;for(let i=0;i<t;i++){let l=Db(r*i,t,e),c=of(n,i);o+=c.real*l.real-c.imag*l.imag,a+=c.real*l.imag+c.imag*l.real}e&&(o/=t,a/=t),Eb(s,o,a,r)}return s}function UP(n){let{inputs:t,backend:e}=n,{input:s}=t,r=H(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Kt({inputs:{x:s},backend:e,attrs:{shape:[a,o]}}),l=W0(i,!1,e),c=Kt({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),c}let GP={kernelName:kc,backendName:"cpu",kernelFunc:UP};function bg(n){let{backend:t,attrs:e}=n,{shape:s,value:r,dtype:o}=e,a=o||Mr(r),i=er(a,H(s));return jP(i,r,a),t.makeTensorInfo(s,a,i)}let HP={kernelName:Ic,backendName:"cpu",kernelFunc:bg};function jP(n,t,e){n.fill(t)}let qP={kernelName:Sc,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:s}=n,r=e,o=ye(s.dtype,H(s.shape)),[a,i,l,c]=s.shape,u=r.data.get(s.dataId).values;for(let d=0;d<a;d++){let p=d*l*i*c;for(let f=0;f<i;f++){let m=f*(l*c);for(let g=0;g<l;g++){let y=g*c;for(let b=0;b<c;b++){let w=[a,f,g,b][2],v=Math.round(l-w),I=p+m+y+b,k=u[I];if(v>=0&&v<l){let T=v*c,E=p+m+T+b;k=u[E]}o[I]=k}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};let KP=ie((n,t)=>Math.floor(n/t)),XP=Ne(oo,KP,null,"int32"),YP={kernelName:oo,backendName:"cpu",kernelFunc:XP};function JP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=M0({inputs:{x:r,filter:o},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){let g=m;m=jl({inputs:{a:m,b:a},backend:e}),e.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=pg(e,m,p,i,f),e.disposeIntermediateTensorInfo(g)}return m}let ZP={kernelName:Li,backendName:"cpu",kernelFunc:JP};function QP(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=B0({inputs:{x:r,filter:o},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){let g=m;m=jl({inputs:{a:m,b:a},backend:e}),e.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=pg(e,m,p,i,f),e.disposeIntermediateTensorInfo(g)}return m}let tz={kernelName:Pi,backendName:"cpu",kernelFunc:QP};function ez(n){let{inputs:t,backend:e}=n,{params:s,indices:r}=t,o=H(s.shape),a=r.shape,i=a[a.length-1],[l,c,u,h]=hu(s,r);if(c===0)return e.makeTensorInfo(l,s.dtype,[]);let d=vt([c,u],s.dtype),p=e.data.get(r.dataId).values,f=e.data.get(s.dataId).values;for(let m=0;m<c;m++){let g=[],y=0;for(let b=0;b<i;b++){let C=p[m*i+b];y+=C*h[b],g.push(C)}if(y<0||y>=o/u)throw new Error(`Invalid indices: ${g} does not index into ${s.shape}`);for(let b=0;b<u;b++)d.values[m*u+b]=f[y*u+b]}return e.makeTensorInfo(l,d.dtype,d.values)}let nz={kernelName:Tc,backendName:"cpu",kernelFunc:ez};function sz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,indices:o}=t,{axis:a,batchDims:i}=s;it([r,o],"gatherV2");let l=i;i==null&&(l=0);let c=H(o.shape),u=$t(a,r.shape)[0],h=lf(r,o,u,l),d=Kt({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),p=Kt({inputs:{x:o},backend:e,attrs:{shape:[h.batchSize,c/h.batchSize]}}),f=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],m=e.bufferSync(p),g=e.bufferSync(d),y=h0(g,m,f);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.makeTensorInfo(h.outputShape,y.dtype,y.values)}let rz={kernelName:Qa,backendName:"cpu",kernelFunc:sz};let oz=ie((n,t)=>n>=t?1:0),az=Ne(ao,oz,null,"bool"),iz={kernelName:ao,backendName:"cpu",kernelFunc:az};function lz(n){let{inputs:t,backend:e}=n,{input:s}=t,r=H(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Kt({inputs:{x:s},backend:e,attrs:{shape:[a,o]}}),l=W0(i,!0,e),c=Kt({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),c}let cz={kernelName:Ec,backendName:"cpu",kernelFunc:lz};let uz=Ft(lo,n=>Number.isFinite(n)?1:0,"bool"),hz={kernelName:lo,backendName:"cpu",kernelFunc:uz};let dz=Ft(co,n=>Math.abs(n)===Infinity?1:0,"bool"),pz={kernelName:co,backendName:"cpu",kernelFunc:dz};let fz=Ft(uo,n=>Number.isNaN(n)?1:0,"bool"),mz={kernelName:uo,backendName:"cpu",kernelFunc:fz};let gz=ie((n,t)=>n<=t?1:0),yz=Ne(si,gz,null,"bool"),bz={kernelName:si,backendName:"cpu",kernelFunc:yz};function xz(n){let{backend:t,attrs:e}=n,{start:s,stop:r,num:o}=e,a=f0(s,r,o);return t.makeTensorInfo([a.length],"float32",a)}let wz={kernelName:Dc,backendName:"cpu",kernelFunc:xz};let $z=Ft(po,n=>Math.log1p(n)),vz={kernelName:po,backendName:"cpu",kernelFunc:$z};let Cz=ie((n,t)=>n&&t),Nz=Ne(ri,Cz,null,"bool"),kz={kernelName:ri,backendName:"cpu",kernelFunc:Nz};let Iz=Ft(oi,n=>n?0:1,"bool"),Sz={kernelName:oi,backendName:"cpu",kernelFunc:Iz};let Tz=ie((n,t)=>n||t),Ez=Ne(ai,Tz,null,"bool"),Az={kernelName:ai,backendName:"cpu",kernelFunc:Ez};function Dz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=s;it(r,"LRN");let c=r.shape[3],u=c-1,h=e.data.get(r.dataId).values,d=H(r.shape),p=new Float32Array(d);function f(m){let g=m%c,y=m-g+Math.max(0,g-o),b=m-g+Math.min(g+o,u),C=0;for(;y<=b;y++){let w=h[y];C+=w*w}return C}for(let m=0;m<d;m++){let g=f(m),y=h[m]*Math.pow(a+i*g,-l);p[m]=y}return e.makeTensorInfo(r.shape,r.dtype,p)}let Rz={kernelName:ii,backendName:"cpu",kernelFunc:Dz};function Fz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:c,beta:u}=s;it(a,"LRNGrad");let h=H(a.shape),d=a.shape[3],p=e.data.get(a.dataId).values,f=e.data.get(r.dataId).values,m=e.data.get(o.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){let C=b%d,w=b-C+Math.max(0,C-i),v=b-C+Math.min(d,C+i+1),I=0;for(let k=w;k<v;k++)I+=Math.pow(f[k],2);I=c*I+l;for(let k=w;k<v;k++){let T=-2*c*u*f[k]*m[b]/I;b===k&&(T+=Math.pow(I,-u)),T*=p[b],g[k]+=T}}return e.makeTensorInfo(a.shape,r.dtype,g)}let _z={kernelName:Rc,backendName:"cpu",kernelFunc:Fz};function U0(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:o,keepDims:a}=s,i=e,l=r.shape,c=l.length,u=$t(o,l),h=u,d=se(h,c),p=i.data.get(r.dataId).values;if(d!=null){let w=new Array(c);for(let v=0;v<w.length;v++)w[v]=l[d[v]];p=hg(p,l,r.dtype,d,w),h=ae(h.length,c),l=w}it(r,"max"),Ee("max",h,c);let[f,m]=we(l,h),g=H(m),y=g0(p,g,f,r.dtype),b=i.write(y,f,r.dtype),C=f;return a&&(C=ne(f,u)),{dataId:b,shape:C,dtype:r.dtype}}let Oz={kernelName:li,backendName:"cpu",kernelFunc:U0};function Lz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t;it(r,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,c=1;N(Te(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let u=mn(r.shape,o,a,c,i,l),h;if(u.filterWidth===1&&u.filterHeight===1&&At(u.inShape,u.outShape))h=Qn({inputs:{x:r},backend:e});else{let d=e.data.get(r.dataId).values,p=pt(r.shape),f=fg(d,r.shape,r.dtype,p,u,"max");h=e.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}let Pz={kernelName:ci,backendName:"cpu",kernelFunc:Lz};function zz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=s;it(r,"maxPool3d");let u=as(r.shape,o,a,1,i,l,c),h=e.data.get(r.dataId).values,d=z0(h,r.shape,r.dtype,pt(r.shape),u,"max");return e.makeTensorInfo(d.shape,"float32",d.values)}let Mz={kernelName:ui,backendName:"cpu",kernelFunc:zz};function Bz(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:c}=s;it([r,o],"maxPool3DGrad");let u=as(o.shape,a,i,1,l,c),h=e.bufferSync(o),d=SL(h,u),p=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,C=u.effectiveFilterDepth,w=u.effectiveFilterHeight,v=u.effectiveFilterWidth,I=C-1-u.padInfo.front,k=v-1-u.padInfo.left,T=w-1-u.padInfo.top,E=vt(o.shape,"float32"),F=e.bufferSync(r);for(let P=0;P<u.batchSize;++P)for(let M=0;M<u.inChannels;++M)for(let z=0;z<u.inDepth;++z)for(let U=0;U<u.inHeight;++U)for(let B=0;B<u.inWidth;++B){let V=z-I,K=U-T,j=B-k,q=0;for(let J=0;J<C;J+=g){let Y=(V+J)/p;if(!(Y<0||Y>=u.outDepth||Math.floor(Y)!==Y))for(let tt=0;tt<w;tt+=y){let Q=(K+tt)/f;if(!(Q<0||Q>=u.outHeight||Math.floor(Q)!==Q))for(let et=0;et<v;et+=b){let nt=(j+et)/m;if(nt<0||nt>=u.outWidth||Math.floor(nt)!==nt)continue;let st=C*w*v-1-d.get(P,Y,Q,nt,M),ct=J*w*v+tt*v+et,ft=st===ct?1:0;if(ft===0)continue;q+=F.get(P,Y,Q,nt,M)*ft}}}E.set(q,P,z,U,B,M)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}let Vz={kernelName:_c,backendName:"cpu",kernelFunc:Bz};function Wz(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o,output:a}=t,i=o;it([o,a],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=mn(i.shape,l,c,1,u,h),p=e.data.get(i.dataId).values,f=vt(d.outShape,i.dtype,P0(p,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,C=d.effectiveFilterHeight,w=d.effectiveFilterWidth,v=w-1-d.padInfo.left,I=C-1-d.padInfo.top,k=vt(i.shape,"float32"),T=e.data.get(r.dataId).values,E=vt(r.shape,"float32",T);for(let F=0;F<d.batchSize;++F)for(let P=0;P<d.inChannels;++P)for(let M=0;M<d.inHeight;++M)for(let z=0;z<d.inWidth;++z){let U=M-I,B=z-v,V=0;for(let K=0;K<C;K+=y){let j=(U+K)/m;if(!(j<0||j>=d.outHeight||Math.floor(j)!==j))for(let q=0;q<w;q+=b){let J=(B+q)/g;if(J<0||J>=d.outWidth||Math.floor(J)!==J)continue;let Y=C*w-1-f.get(F,j,J,P),tt=K*w+q,Q=Y===tt?1:0;if(Q===0)continue;V+=E.get(F,j,J,P)*Q}}k.set(V,F,M,z,P)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}let Uz={kernelName:Fc,backendName:"cpu",kernelFunc:Wz};function Gz(n,t,e,s,r){let o=pt(t),a=fg(n,t,e,o,r,"max"),i=P0(n,t,e,r,!0,s);return[a.values,i.values]}let Hz={kernelName:Oc,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=t,l=e;it(s,"MaxPoolWithArgmax");let c=l.data.get(s.dataId).values,u=mn(s.shape,r,o,[1,1],a),[h,d]=Gz(c,s.shape,s.dtype,i,u),p=l.write(h,u.outShape,s.dtype),f=l.write(d,u.outShape,s.dtype);return[{dataId:p,shape:u.outShape,dtype:s.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function Kh(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;it(r,"sum");let i;r.dtype==="bool"?i=Hs({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):i=Qn({inputs:{x:r},backend:e});let l=i.shape.length,c=$t(o,i.shape),u=se(c,l),h=c,d=i;u!=null&&(d=vn({inputs:{x:i},backend:e,attrs:{perm:u}}),h=ae(h.length,l)),Ee("sum",h,d.shape.length);let[p,f]=we(d.shape,h),m=Ge(d.dtype,"int32"),g=jh(e,p,m),y=H(f),b=e.data.get(g.dataId).values,C=e.data.get(d.dataId).values;for(let w=0;w<b.length;++w){let v=w*y,I=0;for(let k=0;k<y;++k)I+=C[v+k];b[w]=I}if(a){let w=ne(g.shape,c),v=g;g=Kt({inputs:{x:g},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(v)}return e.disposeIntermediateTensorInfo(i),u!=null&&e.disposeIntermediateTensorInfo(d),g}let jz={kernelName:Si,backendName:"cpu",kernelFunc:Kh};function qz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s,i=$t(o,r.shape),c=we(r.shape,i)[1],u=H(c),h=[],d=e.makeTensorInfo([],"float32",new Float32Array([u]));h.push(d);let p=Hs({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});h.push(p);let f=mg({inputs:{a:p,b:d},backend:e});h.push(f);let m=Kh({inputs:{x:f},backend:e,attrs:{axis:o,keepDims:a}});return h.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}let Kz={kernelName:hi,backendName:"cpu",kernelFunc:qz};function Xz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;it(r,"min");let i=$t(o,r.shape),l=i,c=se(l,r.shape.length),u=r;c!=null&&(u=vn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=ae(l.length,r.shape.length)),Ee("min",l,u.shape.length);let[h,d]=we(u.shape,l),p=H(d),f=Ie(H(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,C=m[b];for(let w=0;w<p;++w){let v=m[b+w];v<C&&(C=v)}f[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let g=e.makeTensorInfo(h,u.dtype,f);if(a){let y=ne(h,i),b=Kt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}let Yz={kernelName:di,backendName:"cpu",kernelFunc:Xz};function Jz(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:o,mode:a}=s;it(r,"mirrorPad");let i=o.map((C,w)=>C[0]+r.shape[w]+C[1]),l=o.map(C=>C[0]),c=o.map((C,w)=>C[0]+r.shape[w]),u=a==="reflect"?0:1,h=e.data.get(r.dataId).values,d=r.shape.length,p=pt(r.shape),f=H(i),m=i.length,g=pt(i),y=ye(r.dtype,f);for(let C=0;C<f;C++){let w=Br(C,m,g);for(let I=0;I<m;I++)w[I]<l[I]?w[I]=l[I]*2-w[I]-u:w[I]>=c[I]&&(w[I]=(c[I]-1)*2-w[I]+u);w=w.map((I,k)=>I-l[k]);let v=In(w,d,p);y[C]=h[v]}return{dataId:e.write(y,i,r.dtype),shape:i,dtype:r.dtype}}let Zz={kernelName:pi,backendName:"cpu",kernelFunc:Jz};let Qz=ie((n,t)=>{let e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),t3=Ne(go,Qz),e3={kernelName:go,backendName:"cpu",kernelFunc:t3};function G0(n){let{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:o}=s,a=r.shape.length,i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let l=$t([i],r.shape),c=U0({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=ne(c.shape,l),h=Kt({inputs:{x:c},backend:e,attrs:{shape:u}}),d=dg({inputs:{a:r,b:h},backend:e}),p=l0({inputs:{x:d},backend:e}),f=Kh({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),m=Kt({inputs:{x:f},backend:e,attrs:{shape:u}}),g=mg({inputs:{a:p,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}let n3={kernelName:Ai,backendName:"cpu",kernelFunc:G0};function s3(n){let{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:o,seed:a,normalized:i}=s;it(r,"multinomial");let l=i?r:G0({inputs:{logits:r},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=e.data.get(l.dataId).values,d=[c,o],p=Ie(H(d),"int32");for(let f=0;f<c;++f){let m=f*u,g=new Float32Array(u-1);g[0]=h[m];for(let C=1;C<g.length;++C)g[C]=g[C-1]+h[m+C];let y=ta(a.toString()),b=f*o;for(let C=0;C<o;++C){let w=y();p[b+C]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[b+C]=v;break}}}return i||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(d,"int32",p)}let r3={kernelName:Lc,backendName:"cpu",kernelFunc:s3};let o3=Yu;function a3(n){let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s;it(r,"NonMaxSuppression");let c=e.data.get(r.dataId).values,u=e.data.get(o.dataId).values,{selectedIndices:h}=o3(c,u,a,i,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}let i3={kernelName:Pc,backendName:"cpu",kernelFunc:a3};let l3=Ju;function c3(n){let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=s;it(r,"NonMaxSuppressionPadded");let u=e.data.get(r.dataId).values,h=e.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=l3(u,h,a,i,l,c);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}let u3={kernelName:zc,backendName:"cpu",kernelFunc:c3};let h3=Zu;function d3(n){let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=s;it(r,"NonMaxSuppressionWithScore");let u=e.data.get(r.dataId).values,h=e.data.get(o.dataId).values,d=a,p=i,f=l,m=c,{selectedIndices:g,selectedScores:y}=h3(u,h,d,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}let p3={kernelName:Mc,backendName:"cpu",kernelFunc:d3};function f3(n){let{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{depth:o,onValue:a,offValue:i}=s;it(r,"oneHot");let l=H(r.shape),c=new Float32Array(l*o);c.fill(i);let u=e.data.get(r.dataId).values;for(let h=0;h<l;++h)u[h]>=0&&u[h]<o&&(c[h*o+u[h]]=a);return e.makeTensorInfo([...r.shape,o],"int32",c)}let m3={kernelName:yi,backendName:"cpu",kernelFunc:f3};function Xh(n){let{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){let r=Rr({inputs:{input:s},backend:e}),o=Xh({inputs:{x:r},backend:e}),a=wa({inputs:{input:s},backend:e}),i=Xh({inputs:{x:a},backend:e}),l=en({inputs:{real:o,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),l}else return bg({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}let g3={kernelName:_i,backendName:"cpu",kernelFunc:Xh};function H0(n){let{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){let r=Rr({inputs:{input:s},backend:e}),o=H0({inputs:{x:r},backend:e}),a=wa({inputs:{input:s},backend:e}),i=Xh({inputs:{x:a},backend:e}),l=en({inputs:{real:o,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),l}else return bg({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}let y3={kernelName:gi,backendName:"cpu",kernelFunc:H0};function j0(n){let{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return qh({inputs:{input:t[0]},backend:e,attrs:{dim:r}});let o=t[0].shape,a=t[0].dtype;t.forEach(u=>{ge(o,u.shape,"All tensors passed to stack must have matching shapes"),N(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(u=>{let h=qh({inputs:{input:u},backend:e,attrs:{dim:r}});return i.push(h),h}),c=$a({inputs:l,backend:e,attrs:{axis:r}});return i.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}let b3={kernelName:bi,backendName:"cpu",kernelFunc:j0};function x3(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:o,constantValue:a}=s;it(r,"pad");let i=o.map((b,C)=>b[0]+r.shape[C]+b[1]),l=o.map(b=>b[0]),c=e.data.get(r.dataId).values,u=H(r.shape),h=r.shape.length,d=pt(r.shape),p=H(i),f=i.length,m=pt(i),g=ye(r.dtype,p);a!==0&&g.fill(a);for(let b=0;b<u;b++){let w=Br(b,h,d).map((I,k)=>I+l[k]),v=In(w,f,m);g[v]=c[b]}return{dataId:e.write(g,i,r.dtype),shape:i,dtype:r.dtype}}let q0={kernelName:xi,backendName:"cpu",kernelFunc:x3};let w3=ie((n,t)=>Math.pow(n,t)),$3=Ne(bo,w3),v3={kernelName:bo,backendName:"cpu",kernelFunc:$3};function C3(n){let{backend:t,attrs:e}=n,{start:s,stop:r,dtype:o,step:a}=e,i=v0(s,r,a,o);return t.makeTensorInfo([i.length],o,i)}let N3={kernelName:Vc,backendName:"cpu",kernelFunc:C3};let k3=Ft(xo,n=>1/n),I3={kernelName:xo,backendName:"cpu",kernelFunc:k3};function S3(n){let{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:o,halfPixelCenters:a,size:i}=s;it(r,"resizeBilinear");let l=pt(r.shape),[c,u]=i,[h,d,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(H([h,c,u,f])),y=[o&&c>1?d-1:d,o&&u>1?p-1:p],b=[o&&c>1?c-1:c,o&&u>1?u-1:u],C=0,w=y[0]/b[0],v=y[1]/b[1];for(let I=0;I<h;I++)for(let k=0;k<c;k++){let T;a?T=w*(k+.5)-.5:T=w*k;let E=Math.max(0,Math.floor(T)),F=T-E,P=Math.min(d-1,Math.ceil(T)),M=I*l[0]+E*l[1],z=I*l[0]+P*l[1];for(let U=0;U<u;U++){let B;a?B=v*(U+.5)-.5:B=v*U;let V=Math.max(0,Math.floor(B)),K=B-V,j=Math.min(p-1,Math.ceil(B)),q=M+V*l[2],J=z+V*l[2],Y=M+j*l[2],tt=z+j*l[2];for(let Q=0;Q<f;Q++){let et=m[q+Q],nt=m[J+Q],st=m[Y+Q],ct=m[tt+Q],ft=et+(st-et)*K,mt=nt+(ct-nt)*K,xt=ft+(mt-ft)*F;g[C++]=xt}}}return e.makeTensorInfo([h,c,u,f],"float32",g)}let T3={kernelName:Ci,backendName:"cpu",kernelFunc:S3};function E3(n){let{inputs:t,backend:e,attrs:s}=n,{images:r,dy:o}=t,{alignCorners:a}=s;it([o,r],"resizeBilinearGrad");let i=pt(r.shape),[l,c,u,h]=r.shape,[,d,p]=o.shape,f=new Float32Array(l*c*u*h),m=[a&&d>1?c-1:c,a&&p>1?u-1:u],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],C=e.data.get(o.dataId).values,w=0;for(let v=0;v<l;v++){let I=v*i[0];for(let k=0;k<d;k++){let T=k*y,E=Math.floor(T),F=Math.min(Math.ceil(T),c-1),P=I+E*i[1],M=I+F*i[1],z=T-E,U=1-z;for(let B=0;B<p;B++){let V=B*b,K=Math.floor(V),j=Math.min(Math.ceil(V),u-1),q=V-K,J=1-q,Y=P+K*i[2],tt=P+j*i[2],Q=M+K*i[2],et=M+j*i[2],nt=U*J,st=U*q,ct=z*J,ft=z*q;for(let mt=0;mt<h;mt++){let xt=C[w++];f[Y+mt]+=xt*nt,f[tt+mt]+=xt*st,f[Q+mt]+=xt*ct,f[et+mt]+=xt*ft}}}}return e.makeTensorInfo([l,u,c,h],"float32",f)}let A3={kernelName:Gc,backendName:"cpu",kernelFunc:E3};function D3(n){let{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:o,halfPixelCenters:a,size:i}=s;it(r,"resizeNearestNeighbor");let l=pt(r.shape),[c,u]=i,[h,d,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(h*c*u*f),y=[o&&c>1?d-1:d,o&&u>1?p-1:p],b=[o&&c>1?c-1:c,o&&u>1?u-1:u],C=y[0]/b[0],w=y[1]/b[1],v=0;for(let I=0;I<h;I++){let k=I*l[0];for(let T=0;T<c;T++){let E=a?C*(T+.5):C*T,F=Math.min(d-1,o?Math.round(E):Math.floor(E));a&&(F=Math.max(0,F));let P=k+F*l[1];for(let M=0;M<u;M++){let z=a?w*(M+.5):w*M,U=Math.min(p-1,o?Math.round(z):Math.floor(z));a&&(U=Math.max(0,U));let B=P+U*l[2];for(let V=0;V<f;V++){let K=m[B+V];g[v++]=K}}}}return e.makeTensorInfo([h,c,u,f],r.dtype,g)}let R3={kernelName:vi,backendName:"cpu",kernelFunc:D3};function F3(n){let{inputs:t,backend:e,attrs:s}=n,{images:r,dy:o}=t,{alignCorners:a}=s;it([o,r],"resizeNearestNeighborGrad");let i=pt(r.shape),l=pt(o.shape),[c,u,h,d]=r.shape,[,p,f]=o.shape,m=new Float32Array(c*u*h*d),g=e.data.get(o.dataId).values,y=[a&&p>1?u-1:u,a&&f>1?h-1:h],b=[a&&p>1?p-1:p,a&&f>1?f-1:f],C=y[0]/b[0],w=y[1]/b[1],v=1/C,I=1/w,k=Math.ceil(v)*2+2,T=Math.ceil(I)*2+2;for(let E=0;E<c;E++){let F=E*i[0];for(let P=0;P<u;P++){let M=F+P*i[1],z=Math.floor(P*v),U=Math.floor(z-k/2);for(let B=0;B<h;B++){let V=M+B*i[2],K=Math.floor(B*I),j=Math.floor(K-T/2);for(let q=0;q<d;q++){let J=0;for(let Y=0;Y<k;Y++){let tt=Y+U;if(tt<0||tt>=p)continue;let Q=F+tt*l[1],et=tt*C,nt=Math.min(u-1,a?Math.round(et):Math.floor(et));if(P===nt)for(let st=0;st<T;st++){let ct=st+j;if(ct<0||ct>=f)continue;let ft=Q+ct*l[2],mt=ct*w,xt=Math.min(h-1,a?Math.round(mt):Math.floor(mt));B===xt&&(J+=g[ft+q])}}m[V+q]=J}}}}return e.makeTensorInfo(r.shape,r.dtype,m)}let _3={kernelName:Uc,backendName:"cpu",kernelFunc:F3};function O3(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:o}=s;it(r,"reverse");let a=r.shape.length,i=$t(o,r.shape);if(a===0)return Qn({inputs:{x:r},backend:e});let l=new ce(r.shape,r.dtype),c=e.bufferSync(r);for(let u=0;u<l.size;u++){let h=l.indexToLoc(u),d=h.slice();i.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}let L3={kernelName:Ni,backendName:"cpu",kernelFunc:O3};let P3={kernelName:Zc,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:s}=n,{radians:r,fillValue:o,center:a}=t,i=e,l=ye(s.dtype,H(s.shape)),[c,u,h,d]=s.shape,[p,f]=Yp(a,u,h),m=255,g=Math.sin(r),y=Math.cos(r),b=i.data.get(s.dataId).values;for(let w=0;w<c;w++){let v=w*h*u*d;for(let I=0;I<u;I++){let k=I*(h*d);for(let T=0;T<h;T++){let E=T*d;for(let F=0;F<d;F++){let P=[c,I,T,F],M=P[2],z=P[1],U=(M-p)*y-(z-f)*g,B=(M-p)*g+(z-f)*y;U=Math.round(U+p),B=Math.round(B+f);let V=o;if(typeof o!="number"&&(F===3?V=m:V=o[F]),U>=0&&U<h&&B>=0&&B<u){let j=B*(h*d),q=U*d,J=v+j+q+F;V=b[J]}let K=v+k+E+F;l[K]=V}}}}return{dataId:i.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};let z3=Ft(vo,n=>{let t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),M3={kernelName:vo,backendName:"cpu",kernelFunc:z3};function K0(n,t,e,s,r,o,a,i,l,c){let u=[s/r,r],h=n.values,d=t.values;if(s===0)return vt(e,t.dtype);let p=vt(u,t.dtype);p.values.fill(l);for(let f=0;f<o;f++){let m=[],g=0;for(let y=0;y<a;y++){let b=h[f*a+y];m.push(b),g+=b*i[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<r;y++)c?p.values[g*r+y]+=d[f*r+y]:p.values[g*r+y]=t.rank===0?d[0]:d[f*r+y]}return p}function B3(n){let{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:o}=t,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Uo(o,r,a),d=!0,p=e.bufferSync(r),f=e.bufferSync(o),m=K0(p,f,a,h,c,l,i,u,0,d);return e.makeTensorInfo(a,m.dtype,m.values)}let V3={kernelName:Hc,backendName:"cpu",kernelFunc:B3};function W3(n){let{inputs:t,backend:e}=n,{condition:s,t:r,e:o}=t;it([s,r,o],"select");let a=s.shape.length,i=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(o.dataId).values,u=Ge(r.dtype,o.dtype),h=Ie(H(r.shape),u),d=0,p=a===0||a>1||r.shape.length===1?1:H(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let m=0;m<p;m++)i[f]===1?h[d++]=l[f]:h[d++]=c[f];return e.makeTensorInfo(r.shape,u,h)}let U3={kernelName:ki,backendName:"cpu",kernelFunc:W3};let G3=eh,H3=nh,j3=Ft(No,n=>n>=0?H3*n:G3*(Math.exp(n)-1)),q3={kernelName:No,backendName:"cpu",kernelFunc:j3};let K3=Ft(To,n=>1/(1+Math.exp(-n))),X3={kernelName:To,backendName:"cpu",kernelFunc:K3};let Y3=Ft(So,n=>n<0?-1:n>0?1:0),J3={kernelName:So,backendName:"cpu",kernelFunc:Y3};let Z3=Ft(ko,n=>Math.sin(n)),Q3={kernelName:ko,backendName:"cpu",kernelFunc:Z3};let tM=Ft(Io,n=>Math.sinh(n)),eM={kernelName:Io,backendName:"cpu",kernelFunc:tM};let X0=Math.log(11920928955078125e-23)+2,nM=Ft(Eo,n=>{let t=n>-X0,e=n<X0,s=Math.exp(n),r;return e?r=s:t?r=n:r=Math.log(1+s),r}),sM={kernelName:Eo,backendName:"cpu",kernelFunc:nM};function rM(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:o,paddings:a}=s;it([r],"spaceToBatchND");let i=H(o),l=[[0,0]];l.push(...a);for(let I=1+o.length;I<r.shape.length;++I)l.push([0,0]);let c=q0.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),u=yl(c.shape,o,i,!1),h=bl(u.length,o.length,!1),d=xl(c.shape,o,i,!1),m=Kt({inputs:{x:c},backend:e,attrs:{shape:u}}),b=vn({inputs:{x:m},backend:e,attrs:{perm:h}}),v=Kt({inputs:{x:b},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),v}let oM={kernelName:Ti,backendName:"cpu",kernelFunc:rM};function aM(n){let{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=t,{outputShape:i}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=Uo(o,r,i),p=!1,f=e.bufferSync(r),m=e.bufferSync(o),g=e.data.get(a.dataId).values[0],y=K0(f,m,i,d,u,c,l,h,g,p);return e.makeTensorInfo(i,y.dtype,y.values)}let iM={kernelName:qc,backendName:"cpu",kernelFunc:aM};function lM(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:o,axis:a}=s,i=$t(a,r.shape)[0],l=af(r,o,i),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map(h=>{let d=[...u];d[i]=h;let p=Fr({inputs:{x:r},backend:e,attrs:{begin:c,size:d}});return c[i]+=h,p})}let cM={kernelName:Ei,backendName:"cpu",kernelFunc:lM};let uM=Ft(Ao,n=>Math.sqrt(n)),hM={kernelName:Ao,backendName:"cpu",kernelFunc:uM};let dM={kernelName:jc,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{let{x:e}=n,s=t;it(e,"square");let r=s.data.get(e.dataId).values,o=new Float32Array(r.length);for(let i=0;i<r.length;++i){let l=r[i];o[i]=l*l}return{dataId:s.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};let pM=Ft(Lo,(n,t)=>{let e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),fM={kernelName:Lo,backendName:"cpu",kernelFunc:pM};function mM(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s;it(r,"stridedSlice");let{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Qd(r.shape,o,a,i,l,c,u,h,d),C=Kt({inputs:{x:r},backend:e,attrs:{shape:y}}),w;if(p){let I=Fr({inputs:{x:C},backend:e,attrs:{begin:f,size:g}});w=Kt({inputs:{x:I},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(I)}else if(b.some(I=>I===0))w=e.makeTensorInfo(b,r.dtype,[]);else{let I=e.bufferSync(C),k=I0(b,I,m,f);w=e.makeTensorInfo(k.shape,k.dtype,k.values)}let v=Kt({inputs:{x:w},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(w),v}let gM={kernelName:Kc,backendName:"cpu",kernelFunc:mM};let yM=Ft(Fo,n=>Math.tan(n)),bM={kernelName:Fo,backendName:"cpu",kernelFunc:yM};let xM=Ft(_o,n=>Math.tanh(n)),wM={kernelName:_o,backendName:"cpu",kernelFunc:xM};function $M(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:o}=s;it(r,"tile");let a=T0(e.bufferSync(r),o);return e.makeTensorInfo(a.shape,a.dtype,a.values)}let vM={kernelName:Oo,backendName:"cpu",kernelFunc:$M};function CM(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:o,sorted:a}=s;it(r,"topk");let i=e.data.get(r.dataId).values,[l,c]=E0(i,r.shape,r.dtype,o,a);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}let NM={kernelName:Xc,backendName:"cpu",kernelFunc:CM};function kM(n){let{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:o}=t;it(o,"unique");let a=s.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:c}=A0(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([c.length],"int32",c)]}let IM={kernelName:Yc,backendName:"cpu",kernelFunc:kM};function SM(n){let{inputs:t,backend:e,attrs:s}=n,{value:r}=t,{axis:o}=s;o<0&&(o+=r.shape.length);let a=r.shape.length,i=r.shape[o],l=new Array(a-1),c=0;for(let p=0;p<a;p++)p!==o&&(l[c++]=r.shape[p]);let u=new Array(a).fill(0),h=r.shape.slice();h[o]=1;let d=new Array(i);for(let p=0;p<d.length;p++){u[o]=p;let f=Fr({inputs:{x:r},backend:e,attrs:{begin:u,size:h}});d[p]=Kt({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return d}let TM={kernelName:Ri,backendName:"cpu",kernelFunc:SM};function EM(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:o}=t,{numSegments:a}=s;it(r,"unsortedSegmentSum");let i=r.shape.length,l=o.shape.length,c=[],u=[],h=i-l,d=o;for(let f=0;f<h;++f){let m=qh({inputs:{input:d},backend:e,attrs:{dim:f+1}});d=m,u.push(m)}for(let f=0;f<a;++f){let m=ss(f,"int32"),g=e.makeTensorInfo([],"int32",m),y=V0({inputs:{a:g,b:d},backend:e}),b=Hs({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),C=ug({inputs:{a:b,b:r},backend:e}),w=Kh({inputs:{x:C},backend:e,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(b),u.push(C),u.push(w)}let p=j0({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}let AM={kernelName:Fi,backendName:"cpu",kernelFunc:EM};let DM=[eL,rO,sL,oL,uO,iL,cL,hL,pL,mL,yL,xL,$L,NL,IL,EL,DL,FL,OL,QO,PL,ML,VL,lO,dO,UL,oO,GL,jL,XL,JL,qL,eP,sP,QL,oP,iP,cP,hP,pP,mP,gP,bP,wP,vP,CP,kP,NP,gg,jO,SP,EP,PP,pO,zP,mO,GP,HP,qP,yO,YP,ZP,tz,nz,rz,xO,iz,aO,cz,HL,hz,pz,mz,qO,$O,bz,wz,CO,vz,kz,Sz,Az,Rz,_z,kO,Pz,Mz,Vz,Uz,Hz,Oz,Kz,Yz,SO,Zz,e3,r3,EO,DO,i3,u3,p3,FO,m3,y3,b3,q0,v3,XO,LO,N3,iO,I3,YO,JO,ZO,T3,A3,R3,_3,L3,P3,M3,zO,V3,U3,q3,X3,J3,Q3,eM,MO,n3,sM,oM,iM,cM,hM,dM,VO,fM,gM,UO,jz,bM,wM,vM,NM,_O,IM,TM,AM,g3];for(let n of DM)eu(n);let js={},xg={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function N5(n){delete js[n]}function RM(n,t){js[n]=t}function ts(n){if(!(n in js)){let e=_M(n);if(e!==null)js[n]=e;else return console.log("Could not get context for WebGL version",n),null}let t=js[n];return t.isContextLost()?(delete js[n],ts(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),js[n])}function FM(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function _M(n){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=FM(n);return t.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete js[n]},!1),n===1?t.getContext("webgl",xg)||t.getContext("experimental-webgl",xg):t.getContext("webgl2",xg)}var ql;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ql||(ql={}));var dn;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(dn||(dn={}));var De;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(De||(De={}));function Kl(n,t){return[t,n]}function OM(n,t){return n*t}function k5(n,t){return[t*4,n]}function Xl(n){let t=H(n),e=Math.ceil(t/4);return sc(e)}function I5(n,t){if(n%t!=0)throw new Error(`unpackedSize (${n}) must be a multiple of ${t}`);return n/t}function S5(n,t,e){let s=n.length*e/4;if(t.length<s)throw new Error(`matrix length (${t.length}) must be >= ${s}`);let r=0;for(let o=0;o<n.length;o+=4)for(let a=0;a<e;a++)t[r++]=n[o+a]}function va(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function LM(n,t){let[e,s]=va(n,t);return e*s*4}function wg(n,t){let e=n,s,r,o,a,i,l,c,u,h,d;return G().getNumber("WEBGL_VERSION")===2?(s=e.R32F,r=e.R16F,o=e.RGBA16F,a=e.RGBA32F,i=e.RED,c=4,u=1,h=e.HALF_FLOAT,d=e.FLOAT):(s=n.RGBA,r=n.RGBA,o=n.RGBA,a=e.RGBA,i=n.RGBA,c=4,u=4,h=t!=null?t.HALF_FLOAT_OES:null,d=n.FLOAT),l=n.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function lt(n,t){let e=t();return G().getBool("DEBUG")&&PM(n),e}function PM(n){let t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+VM(n,t))}let zM=596e-10,MM=65504;function BM(n){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||zM<Math.abs(n)&&Math.abs(n)<MM)}function VM(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Yh(n,t){return xs(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function WM(n,t){let e=xs(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(lt(n,()=>n.shaderSource(e,t)),lt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function UM(n,t){let e=xs(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(lt(n,()=>n.shaderSource(e,t)),lt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw HM(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}let GM=/ERROR: [0-9]+:([0-9]+):/g;function HM(n,t){let e=GM.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}let s=+e[1],r=n.split(`
`),o=r.length.toString().length+2,a=r.map((h,d)=>tr((d+1).toString(),o)+h),i=0;for(let h=0;h<a.length;h++)i=Math.max(a[h].length,i);let l=a.slice(0,s-1),c=a.slice(s-1,s),u=a.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${tr(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function jM(n){return xs(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function qM(n,t){if(lt(n,()=>n.linkProgram(t)),n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function $g(n,t){if(lt(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function KM(n,t){let e=xs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),lt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function XM(n,t){let e=xs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return lt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),lt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function T5(){return G().getNumber("WEBGL_VERSION")===2?1:4}function YM(n){return xs(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function JM(n,t){let e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){let s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){let s=`[${n}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function ZM(n){return xs(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Y0(n,t,e,s,r,o,a){let i=n.getAttribLocation(t,e);return i===-1?!1:(lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),lt(n,()=>n.vertexAttribPointer(i,r,n.FLOAT,!1,o,a)),lt(n,()=>n.enableVertexAttribArray(i)),!0)}function QM(n,t,e){Z0(n,e),lt(n,()=>n.activeTexture(n.TEXTURE0+e)),lt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function E5(n,t){Z0(n,t),lt(n,()=>n.activeTexture(n.TEXTURE0+t)),lt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function tB(n,t,e){return xs(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function eB(n,t,e){return n.getUniformLocation(t,e)}function nB(n,t,e,s){lt(n,()=>QM(n,t,s)),lt(n,()=>n.uniform1i(e,s))}function A5(n){lt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),lt(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),lt(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function vg(n,t,e){lt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),lt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function J0(n,t){lt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),lt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Jh(n){let t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+sB(n,t))}function sB(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function xs(n,t,e){let s=lt(n,()=>t());if(s==null)throw new Error(e);return s}function Z0(n,t){let e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){let r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Ca(n,t=2){return H(n.slice(0,n.length-t))}function Na(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Cg(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[Ca(n),...Na(n)]),t}function rB(n,t=!1){let e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,n=n.map((r,o)=>o>=n.length-2?bd(n[o]):n[o]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=vs(n).newShape);let s=H(n);if(n.length<=1&&s<=e)return[1,s];if(n.length===2&&n[0]<=e&&n[1]<=e)return n;if(n.length===3&&n[0]*n[1]<=e&&n[2]<=e)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=e&&n[1]*n[2]<=e)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e)return[n[0],n[1]*n[2]*n[3]];if(t){let r=Ca(n),o=2,a=2;return n.length&&([o,a]=Na(n)),s=r*(o/2)*(a/2),sc(s).map(i=>i*2)}return sc(s)}function Zh(n){return n%2==0}function Qh(n,t){if(n=n.slice(-2),t=t.slice(-2),At(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){let e=n.slice(-1)[0],s=t.slice(-1)[0];if(e===s||Zh(e)&&Zh(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&Zh(n[0])&&Zh(t[0])}let td,ed;function oB(n){if(td==null){let t=ts(n);td=t.getParameter(t.MAX_TEXTURE_SIZE)}return td}function D5(){td=null}function R5(){ed=null}function aB(n){if(ed==null){let t=ts(n);ed=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ed)}function iB(n){if(n===0)return 0;let t,e=ts(n);return Cn(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:Cn(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Cn(n,t){return n.getExtension(t)!=null}function Q0(n){try{if(ts(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function lB(n){if(n===0)return!1;let t=ts(n);if(n===1){if(!Cn(t,"OES_texture_float"))return!1}else if(!Cn(t,"EXT_color_buffer_float"))return!1;return Ng(t)}function cB(n){if(n===0)return!1;let t=ts(n);if(n===1){if(!Cn(t,"OES_texture_float")||!Cn(t,"WEBGL_color_buffer_float"))return!1}else{if(Cn(t,"EXT_color_buffer_float"))return Ng(t);let s="EXT_color_buffer_half_float";if(Cn(t,s)){let r=t.getExtension(s);return uB(t,r)}return!1}return Ng(t)}function Ng(n){let t=wg(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e);let s=1,r=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,s,r,0,t.textureFormatFloat,t.textureTypeFloat,null);let o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);let a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),a}function uB(n,t){let e=wg(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);let r=1,o=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,r,o,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);let i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),i}function hB(n){return n!==2?!1:ts(n).fenceSync!=null}function Yl(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&N(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}let yt=G();yt.registerFlag("HAS_WEBGL",()=>yt.getNumber("WEBGL_VERSION")>0),yt.registerFlag("WEBGL_VERSION",()=>Q0(2)?2:Q0(1)?1:0),yt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),yt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>yt.get("WEBGL_VERSION")===2),yt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),yt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),yt.registerFlag("WEBGL_PACK",()=>yt.getBool("HAS_WEBGL")),yt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_CLIP",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),yt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_PACK_REDUCE",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_LAZILY_UNPACK",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_CONV_IM2COL",()=>yt.getBool("WEBGL_PACK")),yt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>oB(yt.getNumber("WEBGL_VERSION"))),yt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>aB(yt.getNumber("WEBGL_VERSION"))),yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let n=yt.getNumber("WEBGL_VERSION");return n===0?0:iB(n)}),yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>yt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!sy()),yt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>lB(yt.getNumber("WEBGL_VERSION"))),yt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>yt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:yt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),yt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>cB(yt.getNumber("WEBGL_VERSION"))),yt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>hB(yt.getNumber("WEBGL_VERSION"))),yt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>yt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),yt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),yt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});function Pe(){let n,t,e,s,r,o,a,i,l,c;return G().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",r="texture",o="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",r="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}function _r(n,t,e="index"){let s=pt(t);return s.map((r,o)=>{let a=`int ${n[o]} = ${e} / ${r}`,i=o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${a}; ${i};`}).join("")}function nd(n){return n.length===1?`${n[0]}`:`vec${n.length}(${n.join(",")})`}function F5(n,t){if(n.length!==t.length)throw new Error(`Vectors to be dotted must be of the same length -got ${n.length} and ${t.length}`);let e=[],s=Math.floor(n.length/4),r=n.length%4;for(let o=0;o<s;o++){let a=n.slice(o*4,o*4+4),i=t.slice(o*4,o*4+4);e.push(`${nd(a)}, ${nd(i)}`)}if(r!==0){let o=n.slice(s*4),a=t.slice(s*4);o.length===1&&(o=o.map(i=>`float(${i})`),a=a.map(i=>`float(${i})`)),e.push(`${nd(o)}, ${nd(a)}`)}return e.map((o,a)=>`dot(${o})`).join("+")}function kg(n){let t=pt(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}let t1=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;class dB{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ql.DENSE;let e=Xl(t),s=Pe();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${_r(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${s.output} = result;
      }
    `}}class pB{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ql.DENSE;let e=Xl(t),s=Pe();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${_r(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${s.output} = result;
      }
    `}}class fB{constructor(t){this.variableNames=["A"],this.outTexUsage=dn.DOWNLOAD;let e=Pe();this.outputShape=t,this.userCode=`
      ${t1}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class mB{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=dn.DOWNLOAD;let e=Pe();this.outputShape=t,this.userCode=`
      ${t1}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}class gB{constructor(t,e,s=!1){this.variableNames=["A"];let r=Pe(),[o,a]=e;this.outputShape=t;let i="result";s&&(i="floor(result * 255. + 0.5)"),this.userCode=`
      ${kg(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${a};
        int c = imod(flatIndex, ${a});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class yB{constructor(t,e,s=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let r=Pe(),[o,a]=e;this.outputShape=t;let i="",l="result";s&&(l="floor(result * 255. + 0.5)");for(let c=0;c<=1;c++)for(let u=0;u<=1;u++){let h=c*2+u;i+=`
          localCoords = coords;
          if(localCoords[2] + ${u} < ${t[2]}) {
            localCoords[2] += ${u};
            if(localCoords[1] + ${c} < ${t[1]}) {
              localCoords[1] += ${c};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${a};
              c = imod(flatIndex, ${a});
              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);
              values = ${r.texture2D}(A, uv);

              if(offset == 0) {
                result[${h}] = values[0];
              } else if(offset == 1) {
                result[${h}] = values[1];
              } else if(offset == 2) {
                result[${h}] = values[2];
              } else {
                result[${h}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${kg(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${i}

        ${r.output} = ${l};
      }
    `}}function bB(n){let t=Pe(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return WM(n,e)}function xB(n){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return KM(n,t)}function wB(n){let t=new Uint16Array([0,1,2,2,1,3]);return XM(n,t)}function Jl(n,t,e,s,r,o){JM(t,e);let a=YM(n),i=n.TEXTURE_2D;return lt(n,()=>n.bindTexture(i,a)),lt(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),lt(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),lt(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),lt(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),lt(n,()=>n.texImage2D(i,0,s,t,e,0,r,o,null)),lt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),a}function e1(n){return n.internalFormatFloat}function $B(n,t,e,s){let[r,o]=Kl(t,e);return Jl(n,r,o,e1(s),s.textureFormatFloat,n.FLOAT)}function n1(n){return n.internalFormatHalfFloat}function vB(n,t,e,s){let[r,o]=Kl(t,e);return Jl(n,r,o,n1(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function s1(n){return n.downloadTextureFormat}function CB(n,t,e,s){let[r,o]=Kl(t,e);return Jl(n,r,o,s1(s),n.RGBA,n.UNSIGNED_BYTE)}function r1(n){return n.internalFormatPackedFloat}function NB(n,t,e,s){let[r,o]=va(t,e);return Jl(n,r,o,r1(s),n.RGBA,n.FLOAT)}function o1(n){return n.internalFormatPackedHalfFloat}function kB(n,t,e,s){let[r,o]=va(t,e);return Jl(n,r,o,o1(s),n.RGBA,s.textureTypeHalfFloat)}function IB(n,t,e){let s=0,r=3*4,o=3*4+2*4;return lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Y0(n,t,"clipSpacePos",e,3,o,s)&&Y0(n,t,"uv",e,2,o,r)}function SB(n,t,e,s,r,o){lt(n,()=>n.bindTexture(n.TEXTURE_2D,t));let a,i,l;r instanceof Uint8Array?(a=new Uint8Array(e*s*4),i=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(e*s*4),i=n.FLOAT,l=o.internalFormatPackedFloat),a.set(r),lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,s,0,n.RGBA,i,a)),lt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function TB(n,t,e){lt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),lt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function EB(n,t,e,s){let r=n.createBuffer();lt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));let i=4*4*t*e;return lt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),lt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),lt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function AB(n,t,e){let s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function DB(n,t,e,s){let[r,o]=Kl(t,e),a=4,i=new Uint8Array(OM(t*e,a));return lt(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function RB(n,t,e,s,r,o,a,i){let l=n,c=new Float32Array(LM(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function FB(n,t,e){let s=new Float32Array(t*e*4);return lt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class _B{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=G().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,RM(e,t)):this.gl=ts(e);let s="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(G().getNumber("WEBGL_VERSION")===1){let o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Yh(this.gl,o),Cn(this.gl,a))this.textureHalfFloatExtension=Yh(this.gl,a);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Cn(this.gl,r))this.colorBufferHalfFloatExtension=Yh(this.gl,r);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Cn(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Cn(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=xB(this.gl),this.indexBuffer=wB(this.gl),this.framebuffer=ZM(this.gl),this.textureConfig=wg(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;lt(t,()=>t.finish()),lt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),lt(t,()=>t.deleteFramebuffer(this.framebuffer)),lt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),lt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),lt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),$B(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),vB(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),CB(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),TB(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),SB(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),kB(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),NB(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(J0(this.gl,this.framebuffer),this.outputTexture=null),lt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>DB(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,o,a){return RB(this.gl,t,e,s,r,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return AB(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);let r=EB(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(G().getBool("WEBGL_FENCE_API_ENABLED")){let r=t,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{let a=r.clientWaitSync(o,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},e=o}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>FB(this.gl,e,s))}createProgram(t){this.throwIfDisposed();let e=this.gl,s=UM(e,t),r=bB(e),o=jM(e);return lt(e,()=>e.attachShader(o,r)),lt(e,()=>e.attachShader(o,s)),qM(e,o),this.debug&&$g(e,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=IB(e,this.program,this.vertexBuffer)),o}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&lt(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&$g(this.gl,this.program),lt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?tB(this.gl,t,e):eB(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),lt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),nB(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();let[r,o]=va(e,s);this.setOutputMatrixTextureDriver(t,r,o)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&$g(this.gl,this.program),Jh(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),lt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),lt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Yh(this.gl,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await xd(()=>this.disposed||this.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{let s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{let s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=OB(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&xd(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),vg(this.gl,t,this.framebuffer),this.debug&&Jh(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(vg(this.gl,this.outputTexture,this.framebuffer),this.debug&&Jh(this.gl)):J0(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();let r=this.gl;vg(r,t,this.framebuffer),this.debug&&Jh(r),this.outputTexture=t,lt(r,()=>r.viewport(0,0,e,s)),lt(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),lt(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function OB(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}let{getBroadcastDims:a1}=Ob;function LB(n,t,e,s){let r=[];n.forEach(f=>{let m=H(f.shapeInfo.logicalShape);f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`))});let o=r.join(`
`),a=n.map(f=>PB(f,t,s)).join(`
`),i=t.texShape,l=Pe(),c=BB(l),u,h,d=UB(l);return t.isPacked?(u=zB(t.logicalShape,i),h=WB(l)):(u=MB(t.logicalShape,i),h=VB(l)),s&&(d+=qB),[d,c,h,o,u,a,e].join(`
`)}function ka(n){let t=n.shapeInfo.logicalShape;switch(t.length){case 0:return oV(n);case 1:return iV(n);case 2:return cV(n);case 3:return hV(n);case 4:return pV(n);case 5:return fV(n);case 6:return mV(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function i1(n){switch(n.shapeInfo.logicalShape.length){case 0:return rV(n);case 1:return aV(n);case 2:return lV(n);case 3:return uV(n);default:return dV(n)}}function PB(n,t,e=!1){let s="";e?s+=i1(n):s+=ka(n);let r=n.shapeInfo.logicalShape,o=t.logicalShape;return r.length<=o.length&&(e?s+=gV(n,t):s+=yV(n,t)),s}function zB(n,t){switch(n.length){case 0:return l1();case 1:return KB(n,t);case 2:return nV(n,t);case 3:return YB(n,t);default:return ZB(n,t)}}function MB(n,t){switch(n.length){case 0:return l1();case 1:return XB(n,t);case 2:return sV(n,t);case 3:return JB(n,t);case 4:return QB(n,t);case 5:return tV(n,t);case 6:return eV(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function BB(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function VB(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function WB(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function UB(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${GB}
    ${HB}
    ${jB}
  `}let GB=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,HB=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jB=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qB=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function l1(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function KB(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return e[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${e[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);
    }
  `}function XB(n,t){return t[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function YB(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),r=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function JB(n,t){let e=_r(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec3(r, c, d);
    }
  `}function ZB(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),r=s*Math.ceil(n[n.length-2]/2),o=r,a="",i="b, r, c";for(let l=2;l<n.length-1;l++)o*=n[n.length-l-1],a=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+a,i=`b${l}, `+i;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${i});
    }
  `}function QB(n,t){let e=_r(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec4(r, c, d, d2);
    }
  `}function tV(n,t){let e=_r(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function eV(n,t){let e=_r(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function nV(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(At(n,t))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `;let s=Math.ceil(n[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function sV(n,t){return At(n,t)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Or(n){return`offset${n}`}function rV(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Pe();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function oV(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${e}() {return ${t};}`;let[s,r]=n.shapeInfo.texShape;if(s===1&&r===1)return`
      float ${e}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let[o,a]=n.shapeInfo.texShape,i=Or(t);return`
    float ${e}() {
      vec2 uv = uvFromFlat(${o}, ${a}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function aV(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],o=Pe();return`
    vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
        ${r[0]}, ${r[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function iV(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${e}(int index) {
        ${Ia(n)}
      }
    `;let s=n.shapeInfo.texShape,r=s[0],o=s[1];if(o===1&&r===1)return`
      float ${e}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Or(t);return o===1?`
      float ${e}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?`
      float ${e}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
    float ${e}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function lV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,o=r[0],a=r[1],i=Pe();if(r!=null&&At(t,r))return`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${i.texture2D}(${e}, uv);
      }
    `;let l=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${i.texture2D}(${e}, uv);
    }
  `}function cV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape;if(r!=null&&At(t,r)){let h=r[0],d=r[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${e}, uv);
    }
  `}let{newShape:o,keptDims:a}=vs(t),i=o;if(i.length<t.length){let h=Sa(n,i),d=["row","col"];return`
      ${ka(h)}
      float ${s}(int row, int col) {
        return ${s}(${Ta(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Ia(n)}
      }
    `;let l=r[0],c=r[1],u=Or(e);return c===1?`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${u}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${e}, uv);
    }
  `:l===1?`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${u}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${e}, uv);
    }
  `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${u};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${e}, uv);
  }
`}function uV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){let h=t.slice(1),d=[1,2],p=Sa(n,h),f=["b","row","col"];return`
        ${i1(p)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Ta(f,d)});
        }
      `}let a=o[0],i=o[1],l=Math.ceil(t[2]/2),c=l*Math.ceil(t[1]/2),u=Pe();return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${a}, ${i}, ${c}, ${l}, b, row, col);
      return ${u.texture2D}(${e}, uv);
    }
  `}function hV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[1]*t[2],o=t[2],{newShape:a,keptDims:i}=vs(t),l=a;if(l.length<t.length){let f=Sa(n,l),m=["row","col","depth"];return`
        ${ka(f)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Ta(m,i)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${Ia(n)}
      }
    `;let c=n.shapeInfo.texShape,u=c[0],h=c[1],d=n.shapeInfo.flatOffset;if(h===r&&d==null)return`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${u}.0);
          return sampleTexture(${e}, uv);
        }
      `;if(h===o&&d==null)return`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${u}.0);
      return sampleTexture(${e}, uv);
    }
  `;let p=Or(e);return`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${u}, ${h}, index);
        return sampleTexture(${e}, uv);
      }
  `}function dV(n){let t=n.shapeInfo.logicalShape,e=t.length,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],i=a[0],l=a[1],c=Math.ceil(t[e-1]/2),u=c*Math.ceil(t[e-2]/2),h="int b, int row, int col",d=`b * ${u} + (row / 2) * ${c} + (col / 2)`;for(let f=2;f<e-1;f++)h=`int b${f}, `+h,u*=t[e-f-1],d=`b${f} * ${u} + `+d;let p=Pe();return`
    vec4 ${r}(${h}) {
      int index = ${d};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${i});
      return ${p.texture2D}(${s}, uv);
    }
  `}function pV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[3],o=t[2]*r,a=t[1]*o,{newShape:i,keptDims:l}=vs(t);if(i.length<t.length){let f=Sa(n,i),m=["row","col","depth","depth2"];return`
      ${ka(f)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Ta(m,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${r}, 1)));
        ${Ia(n)}
      }
    `;let c=n.shapeInfo.flatOffset,u=n.shapeInfo.texShape,h=u[0],d=u[1];if(d===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${h}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${h}.0);
        return sampleTexture(${e}, uv);
      }
    `;let p=Or(e);return`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${h}, ${d}, index + ${p});
      return sampleTexture(${e}, uv);
    }
  `}function fV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],o=t[3]*r,a=t[2]*o,i=t[1]*a,{newShape:l,keptDims:c}=vs(t);if(l.length<t.length){let m=Sa(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${ka(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Ta(g,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${r})) +
          depth3;
        ${Ia(n)}
      }
    `;let u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(p===r&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let f=Or(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${e}, uv);
    }
  `}function mV(n){let t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:o}=vs(t);if(r.length<t.length){let g=Sa(n,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${ka(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Ta(y,o)});
      }
    `}let a=t[5],i=t[4]*a,l=t[3]*i,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Ia(n)}
      }
    `;let h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===a&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;let m=Or(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Ia(n){let t=n.name,e=H(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function gV(n,t){let e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,a=t.logicalShape.length,i=a1(n.shapeInfo.logicalShape,t.logicalShape),l=zt(a),c=a-o,u,h=["x","y","z","w","u","v"];o===0?u="":a<2&&i.length>=1?u="coords = 0;":u=i.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let d="";a<2&&o>0?d="coords":d=n.shapeInfo.logicalShape.map((b,C)=>`coords.${h[C+c]}`).join(", ");let p="return outputValue;",m=H(n.shapeInfo.logicalShape)===1,y=H(t.logicalShape)===1;if(o===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)a===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(i.length){let b=o-2,C=o-1;i.indexOf(b)>-1&&i.indexOf(C)>-1?p="return vec4(outputValue.x);":i.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(C)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function yV(n,t){let e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",o=t.texShape,a=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&i===l&&n.shapeInfo.flatOffset==null&&At(a,o))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let c=zt(l),u=a1(n.shapeInfo.logicalShape,t.logicalShape),h=l-i,d,p=["x","y","z","w","u","v"];i===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function zt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Sa(n,t){let e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Ta(n,t){return t.map(e=>n[e]).join(", ")}function bV(n,t,e,s){let r=t.userCode,o=e.map((p,f)=>{let m={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(m.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[f],shapeInfo:m}}),a=o.map(p=>p.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=LB(o,i,r,t.packedInputs),c=n.createProgram(l),u=null,h=n.getUniformLocation(c,"NAN",!1);G().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(c,"INFINITY",!1));let d={};for(let p=0;p<t.variableNames.length;p++){let f=t.variableNames[p],m=!1;d[f]=n.getUniformLocation(c,f,m),d[`offset${f}`]=n.getUniformLocation(c,`offset${f}`,m)}return{program:t,source:l,webGLProgram:c,uniformLocations:d,inShapeInfos:a,outShapeInfo:i,infLoc:u,nanLoc:h}}function c1(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{let r=e.logicalShape,o=t[s],a=o.shape;if(!At(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&o.isUniform)return;let i=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!At(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function xV(n,t,e,s,r){c1(t.inShapeInfos,e),c1([t.outShapeInfo],[s]);let o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o,a[0],a[1]):n.setOutputMatrixTexture(o,a[0],a[1]),n.setProgram(t.webGLProgram),G().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,Infinity),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((i,l)=>{let c=t.program.variableNames[l],u=t.uniformLocations[c],h=t.uniformLocations[`offset${c}`];if(u!=null){if(i.isUniform){if(H(i.shape)<2)n.gl.uniform1f(u,i.uniformValues[0]);else{let d=i.uniformValues;d instanceof Float32Array||(d=new Float32Array(d)),n.gl.uniform1fv(u,d)}return}i.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,i.texData.slice.flatOffset),n.setInputMatrixTexture(i.texData.texture,u,l)}}),r!=null&&r(n,t.webGLProgram),n.executeProgram()}function wV(n,t,e){let s="";t.concat(e).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0,l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${i}`});let r=n.userCode,o=n.constructor.name;return o+="_"+s+"_"+r,o}let{addImpl:$V,bincountImpl:u1,bincountReduceImpl:vV,ceilImpl:CV,concatImpl:NV,expImpl:kV,expm1Impl:IV,floorImpl:SV,gatherV2Impl:TV,greaterImpl:EV,lessImpl:AV,linSpaceImpl:DV,logImpl:RV,maxImpl:FV,maximumImpl:_V,minimumImpl:OV,multiplyImpl:LV,negImpl:PV,prodImpl:zV,rangeImpl:MV,rsqrtImpl:BV,simpleAbsImpl:h1,sliceImpl:VV,stridedSliceImpl:WV,subImpl:UV,tileImpl:GV,topKImpl:HV,transposeImpl:Ig,uniqueImpl:jV}=GO;function d1(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function ze(n,t){return t===1?[n]:d1(n,t)}function qV(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class KV{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;let e=t.length;if(e===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let s=ze("rc",e),r=zt(e),o=YV(e,t,s),a=JV(e,t[t.length-1],t[t.length-2],s),i=ZV(t,s);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}}function XV(n,t){let e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<n;a++)o=`${t[t.length-1-a]},`+o;e.push(o)}return e}function YV(n,t,e){if(n===1)return`rc > ${t[0]}`;let s="";for(let r=n-2;r<n;r++)s+=`${e[r]} >= ${t[r]}`,r<n-1&&(s+="||");return s}function JV(n,t,e,s){if(n===1)return"";let r=s.slice(-2);return`
    int r = ${r[0]};
    int c = ${r[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${t};
    bool rEdge = rp1 >= ${e};
  `}function ZV(n,t){let e=n.length,s=XV(e,t);return e===1?`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${s[0]}),
          cEdge ? 0. : getA(${s[1]}),
          rEdge ? 0. : getA(${s[2]}),
          rEdge || cEdge ? 0. : getA(${s[3]})`}class p1{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${QV(e)}
      ${kg(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${t[1]};
        int cols = ${t[2]};

        ${s}

        setOutput(result);
      }
    `}}function QV(n){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${_r(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class tW{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,s){let r=m1(e,s),o=g1(t,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);let a=f1(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let i;return r===De.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===De.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===De.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===De.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===De.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(t,e,s,r){if(this.freeTextures==null)return;let o=m1(s,r),a=g1(e,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);let i=f1(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=G().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=i):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let c=this.usedTextures[a],u=c.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function eW(n,t){let e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function f1(n,t,e,s,r){let o=nW(t,s),a;if(r){let[l,c]=va(n[0],n[1]);a=l*c}else{let[l,c]=Kl(n[0],n[1]);a=l*c}let i=eW(e,o);return a*i}function nW(n,t){switch(n){case De.PACKED_2X2_FLOAT32:return r1(t);case De.PACKED_2X2_FLOAT16:return o1(t);case De.UNPACKED_FLOAT32:return e1(t);case De.UNPACKED_FLOAT16:return n1(t);case De.PACKED_4X1_UNSIGNED_BYTE:return s1(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function sW(n){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?De.PACKED_2X2_FLOAT32:De.UNPACKED_FLOAT32:n?De.PACKED_2X2_FLOAT16:De.UNPACKED_FLOAT16}function m1(n,t){if(n===dn.UPLOAD)return De.PACKED_2X2_FLOAT32;if(n===dn.RENDER||n==null)return sW(t);if(n===dn.DOWNLOAD||n===dn.PIXELS)return De.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function g1(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class qs{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}let Nn="if (isnan(x)) return x;",rW="return x;",y1="return abs(x);";function _5(n=0){return Nn+`
    return x > 0.0 ? 1.0 : float(${n});
  `}let oW="return (x >= 0.0) ? x : (exp(x) - 1.0);",aW=Nn+`
  return (x < 0.0) ? 0.0 : x;
`,iW=Nn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,sd="return x;";let lW="return x;",cW=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,uW=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hW=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;class Ea{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class dW{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;let e=t.length,s=ze("rc",e),r=zt(e),o=qV(e,s),a=s.slice(-2),i=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}let pW=Uu,fW=1e-7,mW=1e-4,rd={};function gW(n){return n in rd||(rd[n]={}),rd[n]}let yW=128,bW=600;function xW(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*bW/1024/1024}class od extends zr{constructor(t){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(t==null){let e=ts(G().getNumber("WEBGL_VERSION"));this.binaryCache=gW(G().getNumber("WEBGL_VERSION")),this.gpgpu=new _B(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;this.textureManager=new tW(this.gpgpu),this.numMBBeforeWarning=xW(),this.texData=new fn(this,os())}nextDataId(){return od.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,s){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:s,values:t,usage:dn.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,s,r,o){if(G().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:e,usage:dn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:o,slice:a,shape:i,isPacked:l}=e;if(a!=null){let d;l?d=new Ea(i,sd):d=new qs(i,sd);let p=this.runWebGLProgram(d,[{dataId:t,shape:i,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;let c=this.activeTimers!=null,u;c&&(u=Se());let h;if(r==="complex64"){let d=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);h=ps(d,p)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=Se()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let e=this.texData.get(t),{values:s,shape:r,slice:o,dtype:a,complexTensorInfos:i,isPacked:l}=e;if(o!=null){let f;l?f=new Ea(r,sd):f=new qs(r,sd);let m=this.runWebGLProgram(f,[{dataId:t,shape:r,dtype:a}],a),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(t);if(!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&G().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(a!=="complex64"&&G().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);let f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture,...Xl(r))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(a==="complex64"){let f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=f[0],g=f[1];h=ps(m,g)}else if(c==null)h=this.getValuesFromTexture(t);else{let f=H(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}u!=null&&this.disposeIntermediateTensorInfo(u);let d=this.convertAndCacheOnCPU(t,h),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&os().removeDataId(t,this),this.pendingDeletes--),d}bufferSync(t){let e=this.readSync(t.dataId),s=e;if(t.dtype==="string")try{s=e.map(r=>or(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(t.shape,t.dtype,s)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let s=t[e];if(!BM(s))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:s,isPacked:r}=this.texData.get(t),o=H(e);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...Xl(e)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),f}let a=G().getBool("WEBGL_PACK")&&r===!0,i=a?Cg(e):e,l=a?new mB(i):new fB(i),c=this.runWebGLProgram(l,[{shape:i,dtype:s,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){let e=this.activeTimers,s=[],r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();let o=ns(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=ns(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(o);i.kernelMs=Pg(l),i.getExtraProfileInfo=()=>l.map((c,u)=>({name:a[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Se(),endMs:null}}endTimer(t){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Se(),t)}async getQueryTime(t){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:s,texShape:r,usage:o,isPacked:a,slice:i}=this.texData.get(t),l=i&&i.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(e,r,o,a)));let u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return G().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=os().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=yW){let s=this.getCPUBackend();return!G().getBool("IS_TEST")&&!this.warnedAboutCPUBackend&&s==null&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),s!=null&&t.every(r=>this.texData.get(r.dataId).texture==null&&H(r.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){oa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return pW(t.shape,e)}packedUnaryOp(t,e,s){let r=new Ea(t.shape,e),o=this.compileAndRun(r,[t],s);return os().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=h1(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,y1,t.dtype);let e=new qs(t.shape,y1),s=this.compileAndRun(e,[t]);return os().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&Mn(s[0])){let o=s.map(a=>rr(a));r=this.write(o,t,e)}else r=this.write(s,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,s){let{dataId:r}=this.makeTensorInfo(t,e,s);return os().makeTensorFromDataId(r,t,e,this)}unpackTensor(t){let e=new dW(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new KV(t.shape),s=!0;return this.runWebGLProgram(e,[t],t.dtype,null,s)}packedReshape(t,e){let s=[Ca(t.shape),...Na(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},o=[Ca(e),...Na(e)],a=new p1(o,s),i=!0,l=this.runWebGLProgram(a,[r],t.dtype,null,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t){let e=this.texData.get(t),{isPacked:s,shape:r,dtype:o}=e,a=Cg(r),i;s?i=new pB(a):i=new dB(a);let l=!0,c=this.runWebGLProgram(i,[{shape:a,dtype:o,dataId:t}],o,null,l);return{dtype:o,shape:r,dataId:c.dataId}}runWebGLProgram(t,e,s,r,o=!1){let a=this.makeTensorInfo(t.outputShape,s),i=this.texData.get(a.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===ql.DENSE){let g=Xl(t.outputShape);i.texShape=g.map(y=>y*2)}if(t.outTexUsage!=null&&(i.usage=t.outTexUsage),H(a.shape)===0)return i.values=ye(a.dtype,0),a;let l=[],c=e.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!t.packedInputs&&H(g.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}else if(!!y.isPacked!=!!t.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!Qh(y.shape,g.shape)){let b=g,C=g.shape;g.shape=y.shape,g=this.packedReshape(g,C),l.push(g),y=this.texData.get(g.dataId),b.shape=C}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(a.dataId);let u={shape:a.shape,texData:i,isUniform:!1},h=wV(t,c,u),d=this.getAndSaveBinary(h,()=>bV(this.gpgpu,t,c,u)),p=this.activeTimers!=null,f;p&&(f=this.startTimer()),xV(this.gpgpu,d,c,u,r),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));let m=G().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let g=Se();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&o===!1){let g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(t,e,s,r,o=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,r,o)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=O(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=G().getBool("DEBUG");G().set("DEBUG",!1);let e=this.abs(ut(1e-8)).dataSync()[0];if(G().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?fW:mW}uploadToGPU(t){let e=this.texData.get(t),{shape:s,dtype:r,values:o,texture:a,usage:i,isPacked:l}=e;if(a!=null)return;let c=this.activeTimers!=null,u;c&&(u=Se());let h=e.texShape;if(h==null&&(h=rB(s,l),e.texShape=h),o!=null){let d=Cg(s),p,f=h[1],m=h[0],g=o instanceof Uint8Array;l?([f,m]=va(h[0],h[1]),p=new yB(d,[m,f],g)):p=new gB(d,[m,f],g);let y=this.makeTensorInfo([m,f],r);g?this.texData.get(y.dataId).usage=dn.PIXELS:this.texData.get(y.dataId).usage=dn.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,m,o);let b=!0,C=this.runWebGLProgram(p,[y],r,null,b),w=this.texData.get(C.dataId);e.texture=w.texture,e.texShape=w.texShape,e.isPacked=w.isPacked,e.usage=w.usage,this.disposeIntermediateTensorInfo(y),this.texData.delete(C.dataId),e.values=null,c&&(this.uploadWaitMs+=Se()-u)}else{let d=this.acquireTexture(h,i,r,l);e.texture=d}}convertAndCacheOnCPU(t,e){let s=this.texData.get(t),{dtype:r}=s;return this.releaseGPUData(t),e!=null&&(s.values=wW(e,r)),s.values}acquireTexture(t,e,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*rc(e)}}od.nextDataId=0;function wW(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}let $W="3.2.0";function vW(){G().set("WEBGL_FORCE_F16_TEXTURES",!0)}Od()&&sp("webgl",()=>new od,2);let O5={forceHalfFloat:vW};let b1=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,L5="return (a - b) * (a - b);";class Aa{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Nt(e,s),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}let ad=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`,P5=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,z5=`
  return vec4(notEqual(a, b));
`;class Zl{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Nt(e,s);let o=this.outputShape.length,a="";if(r)if(o===0||H(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${zt(o)} coords = getOutputCoords();
        `,o===1)a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=ze("coords",o);a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function nn(n){let{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}let CW={kernelName:io,backendName:"webgl",kernelFunc:nn};function Ks(n){let{inputs:t,backend:e}=n,{real:s,imag:r}=t,o=e.makeTensorInfo(s.shape,"complex64"),a=e.texData.get(o.dataId),i=nn({inputs:{x:s},backend:e}),l=nn({inputs:{x:r},backend:e});return a.complexTensorInfos={real:i,imag:l},o}let NW={kernelName:dc,backendName:"webgl",kernelFunc:Ks};let x1="return (a < 0.) ? b * a : a;",w1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kW(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:o}=s,a=e.makeTensorInfo([],"float32",ss(o,"float32")),i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zl(w1,r.shape,a.shape):new Aa(x1,r.shape,a.shape),l=e.runWebGLProgram(i,[r,a],r.dtype);return e.disposeIntermediateTensorInfo(a),l}let IW={kernelName:ei,backendName:"webgl",kernelFunc:kW};let $1="return (a < 0.) ? b * a : a;",v1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function SW(n){let{inputs:t,backend:e}=n,{x:s,alpha:r}=t,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zl(v1,s.shape,r.shape):new Aa($1,s.shape,r.shape);return e.runWebGLProgram(o,[s,r],s.dtype)}let TW={kernelName:wi,backendName:"webgl",kernelFunc:SW};let C1="if (isnan(x)) return x;",EW=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,AW=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Et({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:o})=>{let{x:a}=r,i=o,l=s||a.dtype;if(i.shouldExecuteOnCPU([a])&&e!=null){let h=i.texData.get(a.dataId),d=e(h.values,l);return i.makeTensorInfo(a.shape,l,d)}let c=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return c?u=new Ea(a.shape,t):u=new qs(a.shape,n),i.runWebGLProgram(u,[a],l)}}function Re({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:a,backend:i})=>{let{a:l,b:c}=a,u=i;if(s&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(C=>{let[w,v]=C,I={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:v.dataId,dtype:v.dtype,shape:c.shape},T=new Aa(n,l.shape,c.shape);return u.runWebGLProgram(T,[I,k],Ge(w.dtype,v.dtype))}),b=Ks({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}let h=o||Ge(l.dtype,c.dtype);if(u.shouldExecuteOnCPU([l,c])&&r!=null){let f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=r(l.shape,c.shape,f.values,m.values,h),b=u.makeTensorInfo(y,h),C=u.texData.get(b.dataId);return C.values=g,b}let d=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return d?p=new Zl(t,l.shape,c.shape,e):p=new Aa(n,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function id(n,t=!1){if(n==="linear")return t?lW:rW;if(n==="relu")return t?uW:aW;if(n==="elu")return t?cW:oW;if(n==="relu6")return t?hW:iW;if(n==="prelu")return t?v1:$1;if(n==="leakyrelu")return t?w1:x1;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class N1{constructor(t,e,s,r=!1,o=!1,a=!1,i=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let u=r?t[1]:t[2],h=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";i&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let C="rc.x",w="rc.x";t[0]<e[0]?C=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(w=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}

      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${h}; i++) {
          int batchA = ${C};
          int batchB = ${w};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}let k1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class I1{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Nt(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}let S1="return a * b;";function T1(n){let{inputs:t,backend:e}=n,{a:s,b:r}=t,o=Ge(s.dtype,r.dtype);if(s.dtype==="complex64"){let i=e.texData.get(s.dataId),l=e.texData.get(r.dataId),c=new I1(k1.REAL,s.shape,r.shape),u=new I1(k1.IMAG,s.shape,r.shape),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=e.runWebGLProgram(c,h,"float32"),p=e.runWebGLProgram(u,h,"float32"),f=Ks({inputs:{real:d,imag:p},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([s,r])){let i=e.texData.get(s.dataId),l=e.texData.get(r.dataId),[c,u]=LV(s.shape,r.shape,i.values,l.values,o),h=e.makeTensorInfo(u,o),d=e.texData.get(h.dataId);return d.values=c,h}let a;return G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Zl(S1,s.shape,r.shape):a=new Aa(S1,s.shape,r.shape),e.runWebGLProgram(a,[s,r],o)}let DW={kernelName:yo,backendName:"webgl",kernelFunc:T1};function RW(n,t,e){let s=[Ca(n.shape),...Na(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[Ca(t),...Na(t)],a=new p1(o,s),i=!0,l=e.runWebGLProgram(a,[r],n.dtype,null,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function ot(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:o}=s,a=e,i=H(r.shape),l=wd(o,i),c=H(l);N(i===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let u=a.texData.get(r.dataId);return u.isPacked&&!Qh(r.shape,l)&&!(u.texture!==null&&Qh(u.shape,l))?RW(r,l,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}let FW={kernelName:$i,backendName:"webgl",kernelFunc:ot};class E1{constructor(t,e){this.variableNames=["x"];let{windowSize:s,batchSize:r,inSize:o,outSize:a}=t;this.outputShape=[r,a];let i=Math.floor(s/4)*4,l=s%4,c="sumValue += dot(values, ones);";if(e!=null){let h=1/e;c=`sumValue += dot(values * ${le(h)?h.toPrecision(2):h}, ones);`}let u="";o%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}class _W{constructor(t,e){this.variableNames=["x"];let{windowSize:s,batchSize:r,inSize:o,outSize:a}=t;this.outputShape=[r,a];let i="0.0",l="";e==="prod"?i="1.0":e==="min"?(i="1.0 / 1e-20",l="min"):e==="max"&&(i="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?c="sumValue":e==="prod"?c="prodValue":e==="all"?c="allValue":e==="any"&&(c="anyValue");let u=Math.floor(s/4)*4,h=s%4,d=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
      }
    `,p="vec4";e==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):e==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}function OW(n){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:n[1],s=th(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function Lr(n,t,e,s){let r=OW(n.shape),o=n;for(let a=0;a<r.length;a++){let{inSize:i,windowSize:l,outSize:c}=r[a],u,h;e==="mean"?u=a===0?new E1({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:c},i):new E1({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:c}):u=new _W({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:c},e),h=o,o=s.runWebGLProgram(u,[o],t),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return o}class LW{constructor(t,e){this.variableNames=["A"];let s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[e[a]];this.outputShape=s,this.rank=s.length;let r=zt(this.rank),o=PW(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function PW(n){let t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}class zW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let s=new Array(t.length);for(let u=0;u<s.length;u++)s[u]=t[e[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=zt(this.rank),o=d1("rc",this.rank),a=new Array(this.rank);for(let u=0;u<e.length;u++)a[e[u]]=o[u];let i=`vec2(${a.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}function ld(n,t,e){let s=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zW(n.shape,t):new LW(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function MW(n,t,e,s){let r=t,o=n.shape.length,a=$t(r,n.shape),i=a,l=se(i,o),c=l!=null,u=n;c&&(u=ld(n,l,s),i=ae(i.length,o)),Ee("sum",i,o);let[h,d]=we(u.shape,i),p=h;e&&(p=ne(h,a));let f=H(d),g=H(n.shape)/f,y=ot({inputs:{x:u},attrs:{shape:[g,f]},backend:s}),b=su(n.dtype),C=Lr(y,b,"sum",s),w=ot({inputs:{x:C},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(C),c&&s.disposeIntermediateTensorInfo(u),w}function Sg(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s;return MW(r,o,a,e)}let BW={kernelName:Si,backendName:"webgl",kernelFunc:Sg};function Ue(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:o}=s,a=e,i=r.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=r.shape[o[u]];let c;if(a.shouldExecuteOnCPU([r])){let h=a.texData.get(r.dataId).values,d=Ig(h,r.shape,r.dtype,o,l);c=a.makeTensorInfo(l,r.dtype);let p=a.texData.get(c.dataId);p.values=d}else c=ld(r,o,a);return c}let VW={kernelName:Di,backendName:"webgl",kernelFunc:Ue};let A1=1e3;function cd({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){let c=n.shape.length,u=t.shape.length,h=e?n.shape[c-2]:n.shape[c-1],d=s?t.shape[u-1]:t.shape[u-2],p=e?n.shape[c-1]:n.shape[c-2],f=s?t.shape[u-2]:t.shape[u-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),y=H(m),b=H(g),C=y===b||y===1||b===1;N(c>=2&&u>=2&&C,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);let v=(y>b?n.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);N(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);let I=e?[y,h,p]:[y,p,h],k=s?[b,f,d]:[b,d,f],T=ot({inputs:{x:n},backend:r,attrs:{shape:I}}),E=ot({inputs:{x:t},backend:r,attrs:{shape:k}}),F=[T,E],P=Math.max(y,b),M=e?T.shape[1]:T.shape[2],z=o!=null,U=a!=null,B=l==="leakyrelu",V=l!=null?id(l,!0):null,K=z||U||B||V!=null,j;if((p===1||f===1)&&M>A1&&K===!1){let J=T,Y=E;e&&(J=Ue({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),F.push(J)),s&&(Y=Ue({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),F.push(Y));let tt=f!==1,Q=f===1,et=J;tt&&(et=ot({inputs:{x:J},backend:r,attrs:{shape:[P,M,1]}}),F.push(et));let nt=f===1?2:1,st=Y;Q&&(st=ot({inputs:{x:Y},backend:r,attrs:{shape:[P,1,M]}}),F.push(st));let ct=T1({inputs:{a:et,b:st},backend:r});j=Sg({inputs:{x:ct},backend:r,attrs:{axis:nt,keepDims:!0}}),F.push(ct)}else{let J=Ge(n.dtype,t.dtype),Y=new N1(I,k,[P,p,f],e,s,z,V,U,B),tt=[T,E];if(o!=null&&tt.push(o),U&&tt.push(a),B){let Q=r.makeTensorInfo([],"float32",ss(i,"float32"));tt.push(Q),F.push(Q)}j=r.runWebGLProgram(Y,tt,J)}let q=ot({inputs:{x:j},backend:r,attrs:{shape:v}});F.push(j);for(let J of F)r.disposeIntermediateTensorInfo(J);return q}function WW(n){let{inputs:t,backend:e,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return cd({a:r,b:o,transposeA:l,transposeB:c,backend:e,bias:a,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}let UW={kernelName:Oi,backendName:"webgl",kernelFunc:WW};let D1="return abs(x);";function GW(n){let{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){let o=e.texData.get(s.dataId),a=h1(o.values);return e.makeTensorInfo(s.shape,s.dtype,a)}let r;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ea(s.shape,D1):r=new qs(s.shape,D1),e.runWebGLProgram(r,[s],s.dtype)}let HW={kernelName:_a,backendName:"webgl",kernelFunc:GW};let jW=Nn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,qW=Et({opSnippet:jW}),KW={kernelName:Vr,backendName:"webgl",kernelFunc:qW};let XW=Nn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,YW=Et({opSnippet:XW}),JW={kernelName:Wr,backendName:"webgl",kernelFunc:YW};let R1="return a + b;",ZW=Re({opSnippet:R1,packedOpSnippet:R1,supportsComplex:!0,cpuKernelImpl:$V}),QW={kernelName:sr,backendName:"webgl",kernelFunc:ZW};class t4{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,a)=>`T${a}`);let s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});let r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class e4{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,a)=>`T${a}`);let s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});let r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function ud(n){let{inputs:t,backend:e}=n,s=t;if(s.length===1)return nn({inputs:{x:s[0]},backend:e});if(s.length>G().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(s.length/2),c=ud({inputs:s.slice(0,l),backend:e}),u=ud({inputs:s.slice(l),backend:e});return ud({inputs:[c,u],backend:e})}let r=s.map(l=>l.dtype).reduce((l,c)=>Ge(l,c)),o=s.map(l=>l.shape),i=G().getBool("WEBGL_PACK")?new e4(s[0].shape,o):new t4(s[0].shape,o);return e.runWebGLProgram(i,s,r)}let n4={kernelName:Oa,backendName:"webgl",kernelFunc:ud};function s4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s,i=r.shape.length,l=$t(o,r.shape),c=l,u=se(c,i),h=r;u!=null&&(h=Ue({inputs:{x:r},backend:e,attrs:{perm:u}}),c=ae(c.length,i)),Ee("all",c,i);let[d,p]=we(h.shape,c),f=H(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Lr(m,m.dtype,"all",e),y;if(a){let b=ne(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}let r4={kernelName:ic,backendName:"webgl",kernelFunc:s4};function o4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s,i=r.shape.length,l=$t(o,r.shape),c=l,u=se(c,i),h=r;u!=null&&(h=Ue({inputs:{x:r},backend:e,attrs:{perm:u}}),c=ae(c.length,i)),Ee("any",c,i);let[d,p]=we(h.shape,c),f=H(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Lr(m,m.dtype,"any",e),y;if(a){let b=ne(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}let a4={kernelName:lc,backendName:"webgl",kernelFunc:o4};class i4{constructor(t,e,s){this.variableNames=["A"];let{windowSize:r,batchSize:o,outSize:a}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];let i=e==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class l4{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,N(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);let o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,l=i.length,c=zt(l),u=ze("coords",l),h,d;if(a===1){d=l+1;let T=zt(d);h=`
        ${T} sourceLocR = ${T}(${u.join()}, 0);
        ++${u[l-1]};
        ${T} sourceLocG = ${T}(${u.join()}, 0);
        ++${u[l-2]};
        ${T} sourceLocA = ${T}(${u.join()}, 0);
        --${u[l-1]};
        ${T} sourceLocB = ${T}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;let p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(T=>"int "+T),g=ze("sourceLocR",d-1).concat("inIdx.r"),y=ze("sourceLocG",d-1).concat("inIdx.g"),b=ze("sourceLocB",d-1).concat("inIdx.b"),C=ze("sourceLocA",d-1).concat("inIdx.a"),w=s==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${C.join()})));`,I=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${i[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function F1(n,t,e,s=null){let r=t.shape[0],o=t.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);let a=th(o),i={windowSize:a,inSize:o,batchSize:r,outSize:Math.ceil(o/a)},l=new i4(i,e,s==null),c=[t];s!=null&&c.push(s);let u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;let h=F1(n,t,e,u);return n.disposeIntermediateTensorInfo(u),h}function _1(n,t,e,s=null){let r=s!=null?s.shape:t.shape,o=r[r.length-1],a=th(o),i=new l4(r,a,e,s==null),l=s==null?[t]:[t,s],c=n.runWebGLProgram(i,l,"int32");if(c.shape.length===t.shape.length){let u=_1(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function O1(n,t,e,s){let r=[e];if(Ee("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let o=[],[a,i]=we(t.shape,r),l=H(i),c=ot({inputs:{x:t},backend:n,attrs:{shape:[-1,l]}});o.push(c);let u=F1(n,c,s);o.push(u);let h=ot({inputs:{x:u},backend:n,attrs:{shape:a}});return o.forEach(d=>n.disposeIntermediateTensorInfo(d)),h}return _1(n,t,s)}function c4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o}=s,a=$t(o,r.shape),i=se(a,r.shape.length),l=r,c=[];i!=null&&(l=Ue({inputs:{x:r},backend:e,attrs:{perm:i}}),c.push(l),a=ae(a.length,l.shape.length)),Ee("argMax",[a[0]],l.shape.length);let u=O1(e,l,a[0],"max");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),u}let u4={kernelName:La,backendName:"webgl",kernelFunc:c4};function h4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o}=s,a=$t(o,r.shape),i=se(a,r.shape.length),l=r,c=[];i!=null&&(l=Ue({inputs:{x:r},backend:e,attrs:{perm:i}}),c.push(l),a=ae(a.length,l.shape.length)),Ee("argMin",[a[0]],l.shape.length);let u=O1(e,l,a[0],"min");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),u}let d4={kernelName:Pa,backendName:"webgl",kernelFunc:h4};let p4=Nn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,f4=Et({opSnippet:p4}),m4={kernelName:Ur,backendName:"webgl",kernelFunc:f4};let g4=Nn+"return log(x + sqrt(x * x + 1.0));",y4=Et({opSnippet:g4}),b4={kernelName:Gr,backendName:"webgl",kernelFunc:y4};let x4=Nn+`
  return atan(x);
`,w4=Et({opSnippet:x4}),$4={kernelName:Hr,backendName:"webgl",kernelFunc:w4};let v4=EW+`
  return atan(a, b);
`,C4=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+AW+`
  return result;
`,N4=Re({opSnippet:v4,packedOpSnippet:C4}),k4={kernelName:qr,backendName:"webgl",kernelFunc:N4};let I4=Nn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,S4=Et({opSnippet:I4}),T4={kernelName:jr,backendName:"webgl",kernelFunc:S4};class Ql{constructor(t,e,s,r=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;let m=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(m||(b="-1.0 / 1e-20"),s){let T=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / count");let v=Math.floor(a/4)*4,I=a%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${v};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${w});
      }
    `}}class Tg{constructor(t,e,s,r=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let C=e==="avg",w="0.0";if(C||(w="-1.0 / 1e-20"),s){let F=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${F} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",I=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(I="avgValue / count");let k=Math.floor(a/4)*4,T=a%4,E=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${k};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${E}
            }
          }
          setOutput(${I});
        }
      }
    `}}function E4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Yl(r,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,c=1;N(Te(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let u=mn(r.shape,o,a,c,i,l);if(u.filterWidth===1&&u.filterHeight===1&&At(u.inShape,u.outShape))return nn({inputs:{x:r},backend:e});let h=new Ql(u,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}let A4={kernelName:za,backendName:"webgl",kernelFunc:E4};function D4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],h=as(r.shape,o,a,u,i,l,c),d=new Tg(h,"avg",!1);return e.runWebGLProgram(d,[r],"float32")}let R4={kernelName:Ma,backendName:"webgl",kernelFunc:D4};class F4{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=l-1-t.padInfo.top,h=c-1-t.padInfo.left,d=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class _4{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,h=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=h-1-t.padInfo.front,m=d-1-t.padInfo.top,g=p-1-t.padInfo.left,y=1/(e*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function O4(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,a=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=as(a.shape,i,l,h,c,u),p=new _4(d);return e.runWebGLProgram(p,[r],a.dtype)}let L4={kernelName:uc,backendName:"webgl",kernelFunc:O4};function P4(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,a=o;Yl([r,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:c}=s,u=mn(a.shape,i,l,1,c),h=new F4(u);return e.runWebGLProgram(h,[r],a.dtype)}let z4={kernelName:cc,backendName:"webgl",kernelFunc:P4};function M4(n){let{inputs:t,backend:e,attrs:s}=n,{a:r,b:o}=t,{transposeA:a,transposeB:i}=s;return cd({a:r,b:o,transposeA:a,transposeB:i,backend:e})}let B4={kernelName:Ba,backendName:"webgl",kernelFunc:M4};class V4{constructor(t,e,s,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Nt(t,e),Nt(t,s);let i="0.0";r!=null&&(Nt(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";o!=null&&(Nt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class W4{constructor(t,e,s,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Nt(t,e),Nt(t,s);let i="vec4(0.0)";r!=null&&(Nt(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(Nt(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}let U4={kernelName:Za,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:s,mean:r,variance:o,offset:a,scale:i}=n;N(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);let c=[s,r,o],u=null;a!=null&&(u=a.shape,c.push(a));let h=null;i!=null&&(h=i.shape,c.push(i));let d=G().getBool("WEBGL_PACK_NORMALIZATION")?new W4(s.shape,r.shape,o.shape,u,h,l):new V4(s.shape,r.shape,o.shape,u,h,l);return t.runWebGLProgram(d,c,c[0].dtype)}};class G4{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=zt(this.rank),s=`uniform int start[${this.rank}];`,r=H4(this.rank),o,a=t.map((i,l)=>`sourceLoc.${Eg[l]} = start[${l}] + coords.${Eg[l]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      ${s}
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,s)=>{this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(s,"start"),this.startLoc==null)||e.gl.uniform1iv(this.startLoc,t)}}}let Eg=["x","y","z","w","u","v"];function H4(n){if(n===1)return"sourceLoc";if(n<=6)return Eg.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class j4{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;let e=zt(this.rank),s=ze("coords",this.rank),r=ze("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((u,h)=>`start[${h}]`).join()});`:t.map((u,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,s)=>{this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(s,"start"),this.startLoc==null)||e.gl.uniform1iv(this.startLoc,t)}}}function q4(n,t,e,s){let r=s.texData.get(n.dataId),o=s.makeTensorInfo(e,n.dtype),a=s.texData.get(o.dataId);Object.assign(a,r),a.refCount=1,a.shape=e,a.dtype=n.dtype;let i=Zd(t,pt(n.shape));r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||n.dataId};let l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),o}function tc(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:o,size:a}=s,[i,l]=pu(r,o,a);if(Yd(r,i,l),H(l)===0)return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){let h=e.texData.get(r.dataId),d=VV(h.values,i,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,d)}let{isPacked:c}=e.texData.get(r.dataId),u=Jd(r.shape,i,l);if(c||!u){let h=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j4(l):new G4(l),d=h.getCustomSetupFunc(i);return e.runWebGLProgram(h,[r],r.dtype,d)}return e.uploadToGPU(r.dataId),q4(r,i,l,e)}let K4={kernelName:Ii,backendName:"webgl",kernelFunc:tc};let X4={kernelName:Va,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:o,crops:a}=s;N(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((b,C)=>b*C),l=yl(r.shape,o,i),c=bl(l.length,o.length),u=xl(r.shape,o,i),h=Jp(a,o.length),d=Zp(u,a,o.length),p=[],f=ot({inputs:{x:r},backend:e,attrs:{shape:l}}),m=Ue({inputs:{x:f},backend:e,attrs:{perm:c}}),g=ot({inputs:{x:m},backend:e,attrs:{shape:u}}),y=tc({inputs:{x:g},backend:e,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}};function Y4(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,weights:o}=t,{size:a}=s,i=e.readSync(r.dataId),l=e.readSync(o.dataId),c=u1(i,l,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,c)}let J4={kernelName:hc,backendName:"webgl",kernelFunc:Y4};let L1=Re({opSnippet:"return float(a != b);",dtype:"bool"}),Z4={kernelName:mi,backendName:"webgl",kernelFunc:L1};function ec(n){let{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return nn({inputs:{x:r.complexTensorInfos.real},backend:e})}let Q4={kernelName:Wc,backendName:"webgl",kernelFunc:ec};let tU="return float(int(x));";function eU(n,t){let e=new qs(n.shape,tU),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function Ag(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return nn({inputs:{x:r},backend:e});let a=re(r.shape),i=Ag({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=Ks({inputs:{real:i,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(i),l}if(r.dtype==="complex64"){let a=ec({inputs:{input:r},backend:e}),i=Ag({inputs:{x:a},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(a),i}if(!$d(r.dtype,o)){let a=nn({inputs:{x:r},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return eU(r,e);if(o==="bool"){let a=e.makeTensorInfo([],"bool",ye("bool",1)),l=L1({inputs:{a:r,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}let nU={kernelName:Kr,backendName:"webgl",kernelFunc:Ag};let P1="return ceil(x);",sU=Et({opSnippet:P1,packedOpSnippet:P1,cpuKernelImpl:CV}),rU={kernelName:Xr,backendName:"webgl",kernelFunc:sU};class oU{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(t,e){return(s,r)=>{this.minLoc==null&&(this.minLoc=s.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=s.getUniformLocationNoThrow(r,"maxVal")),s.gl.uniform1f(this.minLoc,t),s.gl.uniform1f(this.maxLoc,e)}}}class aU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(t,e){return(s,r)=>{this.minLoc==null&&(this.minLoc=s.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=s.getUniformLocationNoThrow(r,"maxVal")),s.gl.uniform1f(this.minLoc,t),s.gl.uniform1f(this.maxLoc,e)}}}function iU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:o,clipValueMax:a}=s,i;G().getBool("WEBGL_PACK_CLIP")?i=new aU(r.shape):i=new oU(r.shape);let l=i.getCustomSetupFunc(o,a);return e.runWebGLProgram(i,[r],r.dtype,l)}let lU={kernelName:Yr,backendName:"webgl",kernelFunc:iU};class cU{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function z1(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function uU(n){let{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),o=new cU(s.shape),a=[z1(s,r.complexTensorInfos.real),z1(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(o,a,a[0].dtype)}let hU={kernelName:Wa,backendName:"webgl",kernelFunc:uU};class dU{constructor(t){this.outputShape=[],this.outputShape=ds(t,1),this.variableNames=t.map((a,i)=>`T${i}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];let s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){let i=e[a-1];s.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let r=e.length,o=e[e.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class pU{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ds(t,e);let s=this.outputShape,r=s.length,o=zt(r),a=ze("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((m,g)=>`T${g}`);let l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];let c=i[e],u=i.slice(-2),h=i.join(),d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){let g=l[m-1];d+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${hd(i,c,g)}),
            vec2(${hd(u,c,g)}));
        }`}let p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${hd(i,c,f)}),
          vec2(${hd(u,c,f)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function hd(n,t,e){let s=n.indexOf(t);return n.map((o,a)=>a===s?`${o} - ${e}`:o).join()}function dd(n){let{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return nn({inputs:{x:r.complexTensorInfos.imag},backend:e})}let fU={kernelName:Ac,backendName:"webgl",kernelFunc:dd};function Da(n,t,e){let s=n[0].dtype;if(s==="complex64"){let c=n.map(f=>ec({inputs:{input:f},backend:e})),u=n.map(f=>dd({inputs:{input:f},backend:e})),h=Da(c,t,e),d=Da(u,t,e),p=Ks({inputs:{real:h,imag:d},backend:e});return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),u.forEach(f=>e.disposeIntermediateTensorInfo(f)),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),p}if(s==="string"){let{tensors2D:c,outShape:u}=M1(n,t,e),h=c.map(g=>({vals:e.readSync(g.dataId),shape:g.shape})),d=c[0].shape[0]===1,p=NV(h,u,s,d),f=ds(n.map(g=>g.shape),t),m=e.makeTensorInfo(f,s,p);return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}if(n.length>G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(n.length/2),u=Da(n.slice(0,c),t,e),h=Da(n.slice(c),t,e),d=Da([u,h],t,e);return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),d}if(G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){let c=new pU(n.map(u=>u.shape),t);return e.runWebGLProgram(c,n,s)}let{tensors2D:r,outShape:o}=M1(n,t,e),a=new dU(r.map(c=>c.shape)),i=e.runWebGLProgram(a,r,s);r.forEach(c=>e.disposeIntermediateTensorInfo(c));let l=ot({inputs:{x:i},attrs:{shape:o},backend:e});return e.disposeIntermediateTensorInfo(i),l}function M1(n,t,e){let s=ds(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>ot({inputs:{x:o},attrs:{shape:[-1,H(o.shape.slice(t))]},backend:e})),outShape:s}}function B1(n){let{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,o=$t(r,t[0].shape)[0],a=ds(t.map(c=>c.shape),o);if(H(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(c=>H(c.shape)>0);if(i.length===1)return nn({inputs:{x:i[0]},backend:e});let l=i.map(c=>c.shape);return Kp(l,o),Da(i,o,e)}let mU={kernelName:Ua,backendName:"webgl",kernelFunc:B1};class V1{constructor(t,e=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let a=t.padInfo.top,i=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,C=g?3:1,w="",v="";s&&(r?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:w=`
          float activation(float x) {
            ${s}
          }
        `,v="result = activation(result);");let I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${v}
        setOutput(result);
      }
    `}}class gU{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterDepth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${e}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yU{constructor(t,e,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let{filterWidth:r,inChannels:o,strideWidth:a,strideHeight:i,padInfo:l,outWidth:c,dilationWidth:u,dilationHeight:h,dataFormat:d}=s,{left:p,top:f}=l,m=o*r,g=Pe(),y=d==="channelsLast",b=y?0:1,C=y?1:2,w="";for(let v=0;v<=1;v++)for(let I=0;I<=1;I++)w+=`
          blockIndex = rc.y + ${I};
          pos = rc.x + ${v};

          if(blockIndex < ${t[1]} && pos < ${t[0]}) {
            offsetY = int(blockIndex / (${c})) * ${i} - ${f};
            d0 = offsetY + ${h} * (pos / ${m});

            if(d0 < ${e[b]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${c}.) * ${a}. - ${p}.);
              d1 = offsetX + ${u} * (int(mod(float(pos), ${m}.) / ${o}.));

              if(d1 < ${e[C]} && d1 >= 0) {

                ch = int(mod(float(pos), ${o}.));

                if (${y}) {
                  innerDims = vec2(d1, ch);
                  result[${v*2+I}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${v*2+I}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${w}

        ${g.output} = result;
      }
    `}}function W1({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let l=n.shape,c=s.texData.get(n.dataId),u=e.inChannels,h=l[0]*l[1]*l[2],d=e.outChannels,p=e.dataFormat==="channelsLast",f=!1,m=!1,g,y=[],b=(h===1||d===1)&&u>A1,C=l[2]%2!=0&&!!c.isPacked;if(b||!G().getBool("WEBGL_LAZILY_UNPACK")||!G().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!C){let w=p?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],v=ot({inputs:{x:n},backend:s,attrs:{shape:[1,w,e.inChannels]}}),I=ot({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),k=cd({a:v,b:I,transposeA:f,transposeB:m,backend:s,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a});g=ot({inputs:{x:k},backend:s,attrs:{shape:e.outShape}}),y.push(v),y.push(I),y.push(k)}else{let w=p?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),v={dataId:n.dataId,shape:[1,w,e.inChannels],dtype:n.dtype},I=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,N(Qh(c.shape,v.shape),()=>`packed reshape ${c.shape} to ${v.shape} isn't free`);let k=ot({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(k);let T=cd({a:v,b:k,backend:s,transposeA:f,transposeB:m,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),E=s.texData.get(T.dataId);N(E.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=I,E.shape=e.outShape,g=nn({inputs:{x:T},backend:s}),g.shape=e.outShape,y.push(T)}for(let w of y)s.disposeIntermediateTensorInfo(w);return g}function U1({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=e,f=p==="channelsLast",m=l*c*u,g=d*h,y=[m,g],b=!0,C=!1,w=[],v=ot({inputs:{x:n},backend:s,attrs:{shape:n.shape.slice(1)}}),I=ot({inputs:{x:t},backend:s,attrs:{shape:[1,m,H(t.shape)/m]}});w.push(v),w.push(I);let k=new yU(y,v.shape,e),T=s.runWebGLProgram(k,[v],"float32"),E=ot({inputs:{x:T},backend:s,attrs:{shape:[1,y[0],y[1]]}});w.push(T),w.push(E);let F=r!=null,P=o!=null,M=i==="leakyrelu",z=i?id(i,!0):null,U=new N1(E.shape,I.shape,[1,g,e.outChannels],b,C,F,z,P,M),B=[E,I];if(r&&B.push(r),P&&B.push(o),M){let q=s.makeTensorInfo([],"float32",ss(a,"float32"));B.push(q),w.push(q)}let V=s.runWebGLProgram(U,B,"float32"),K=f?[1,d,h,e.outChannels]:[1,e.outChannels,d,h],j=ot({inputs:{x:V},backend:s,attrs:{shape:K}});w.push(V);for(let q of w)s.disposeIntermediateTensorInfo(q);return j}function bU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=is(l),d=xe(r.shape,o.shape,a,c,i,u,!1,h),p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=W1({x:r,filter:o,convInfo:d,backend:e});else if(G().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)p=U1({x:r,filter:o,convInfo:d,backend:e});else{let m=new V1(d);p=e.runWebGLProgram(m,[r,o],"float32")}let f=ot({inputs:{x:p},backend:e,attrs:{shape:d.outShape}});return e.disposeIntermediateTensorInfo(p),f}let xU={kernelName:Ga,backendName:"webgl",kernelFunc:bU};class wU{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $U{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dataFormat==="channelsLast",i=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=a?1:2,u=a?2:3,h=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vU{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${o};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CU{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=e-1-t.padInfo.front,c=s-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function NU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=is(l),d=xe(r.shape,u,a,1,i,c,!1,h),p=new wU(d);return e.runWebGLProgram(p,[r,o],"float32")}let kU={kernelName:pc,backendName:"webgl",kernelFunc:NU};function IU(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=is(c),d=xe(a,o.shape,i,1,l,u,!1,h),p=new $U(d);return e.runWebGLProgram(p,[r,o],"float32")}let SU={kernelName:Ha,backendName:"webgl",kernelFunc:IU};function TU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dilations:l}=s,c=Es(r.shape,o.shape,a,l,i),u=new gU(c);return e.runWebGLProgram(u,[r,o],"float32")}let EU={kernelName:ja,backendName:"webgl",kernelFunc:TU};function AU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,pad:i,filterShape:l}=s,c=Es(r.shape,l,a,1,i),u=new vU(c);return e.runWebGLProgram(u,[r,o],"float32")}let DU={kernelName:fc,backendName:"webgl",kernelFunc:AU};function RU(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{pad:a,strides:i,inputShape:l}=s,c=Es(l,o.shape,i,1,a),u=new CU(c);return e.runWebGLProgram(u,[r,o],"float32")}let FU={kernelName:mc,backendName:"webgl",kernelFunc:RU};let _U=C1+`
  return cos(x);
`,OU=Et({opSnippet:_U}),LU={kernelName:Jr,backendName:"webgl",kernelFunc:OU};let PU=Et({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),zU={kernelName:Zr,backendName:"webgl",kernelFunc:PU};class MU{constructor(t,e,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,l,c]=t,[u]=e,[h,d]=s;this.outputShape=[u,h,d,c];let p=r==="bilinear"?1:0,[f,m]=[`${i-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(i-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[C,w,v]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}let BU={kernelName:gc,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:c}=s,u=new MU(r.shape,o.shape,i,l,c);return e.runWebGLProgram(u,[r,o,a],"float32")}};class G1{constructor(t,e,s){this.variableNames=["x"],this.outputShape=t;let r=t.length,o=e?"0.0":`getX(${H1(r,"coords")})`,a=t[t.length-1],i="",l="";e?(i=s?`end != ${a-1}`:"end != 0",l=s?"end + 1":"end - 1"):(i=s?`end + pow2 < ${a}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${zt(r)} coords = getOutputCoords();
        int end = ${j1(r,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${l};
          ${j1(r,"coords")} = idx;
          val += getX(${H1(r,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(t){return(e,s)=>{this.index==null&&(this.index=e.getUniformLocation(s,"index")),e.gl.uniform1f(this.index,t)}}}function H1(n,t){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function j1(n,t){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function VU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,exclusive:a,reverse:i}=s,l=r.shape.length,c=se([o],l),u=r;c!=null&&(u=Ue({inputs:{x:r},backend:e,attrs:{perm:c}}));let h=ae(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${o}`);let d=u.shape[h],p=nn({inputs:{x:u},backend:e});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){let m=new G1(u.shape,!1,i),g=m.getCustomSetupFunc(f),y=p;p=e.runWebGLProgram(m,[p],p.dtype,g),e.disposeIntermediateTensorInfo(y)}if(a){let f=new G1(u.shape,a,i),m=p;p=e.runWebGLProgram(f,[p],p.dtype),e.disposeIntermediateTensorInfo(m)}if(c!=null){let f=Yo(c),m=Ue({inputs:{x:p},backend:e,attrs:{perm:f}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),m}return p}let WU={kernelName:qa,backendName:"webgl",kernelFunc:VU};function UU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,weights:o}=t,{size:a,binaryOutput:i}=s;if(r.shape.length===1){let l=e.readSync(r.dataId),c=e.readSync(o.dataId),u=u1(l,c,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,u)}else if(r.shape.length===2){let l=e.bufferSync(r),c=e.bufferSync(o),u=vV(l,c,a,i);return e.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}let GU={kernelName:yc,backendName:"webgl",kernelFunc:UU};class HU{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function jU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:o,dataFormat:a}=s;N(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],u=a==="NHWC"?r.shape[3]:r.shape[1],h=l*o,d=c*o,p=u/(o*o),f=a==="NHWC"?[i,h,d,p]:[i,p,h,d],m=new HU(f,o,a);return e.runWebGLProgram(m,[r],r.dtype)}let qU={kernelName:bc,backendName:"webgl",kernelFunc:jU};class q1{constructor(t,e=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let a=t.inHeight,i=t.inWidth,l=t.padInfo.top,c=t.padInfo.left,u=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=t.outChannels/t.inChannels,y="",b="";s&&(r?y=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?y=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:y=`
          float activation(float x) {
            ${s}
          }
        `,b="result = activation(result);");let C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      const ivec2 strides = ivec2(${u}, ${h});
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${g};
        int q = d2 - d1 * ${g};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${a}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${i}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${C}
        ${b}
        setOutput(result);
      }
    `}}class K1{constructor(t,e=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;let a=t.inHeight,i=t.inWidth,l=t.padInfo.top,c=t.padInfo.left,u=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=m,y="int xR; int xC; int xCOffset;";for(let v=0;v<f;v++)for(let I=0;I<m;I++)y+=`
          vec4 xTexelR${v}C${I*2} = vec4(0.);
          vec4 wR${v}C${I} = vec4(0.);
          vec4 xR${v}C${I} = vec4(0.);`;for(let v=0;v<f;v++)for(let I=0;I<g;I++){let k=I*2;if(y+=`
          xR = xRCorner + ${v*d};
          xC = xCCorner + ${k*p};
        `,h===1){if(k<m&&(c%2==1?y+=`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${i}) {
                  xTexelR${v}C${k} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${i}) {
                    xTexelR${v}C${k}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${v}C${k} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${i}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${i}) {
                    previous.zw = vec2(0.);
                  }

                  xR${v}C${k} = vec4(previous.zw, xTexelR${v}C${k}.xy);
                } else {
                  xR${v}C${k} = vec4(0, 0, xTexelR${v}C${k}.xy);
                }
              `:y+=`
                if(xR >= 0 && xR < ${a} && xC >= 0 && xC < ${i}) {
                  xTexelR${v}C${k} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${v}C${k} = vec4(0.);
                }

                xR${v}C${k} = xTexelR${v}C${k};
              `,k+1<m)){let T=c%2==0?bd(p):p;p%2==0&&c%2==1||p%2!=0&&c%2!=1?(y+=`
                  xCOffset = xC + ${c%2} + ${T};

                  if(xR >= 0 && xR < ${a} &&
                    xCOffset >= 0 && xCOffset < ${i}) {
                    xTexelR${v}C${k+2} = getX(batch, xR, xCOffset, d1);
                  }
                `,p>1&&(y+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${a} &&
                      xCOffset >= 0 && xCOffset < ${i}) {
                      xTexelR${v}C${k} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${v}C${k} = vec4(0.);
                    }
                  `),y+=`
                  xR${v}C${k+1} = vec4(
                    xTexelR${v}C${k}.zw, xTexelR${v}C${k+2}.xy);
                `):y+=`
                  xCOffset = xC + ${T};

                  if(xR >= 0 && xR < ${a} &&
                    xCOffset >= 0 && xCOffset < ${i}) {
                    xTexelR${v}C${k+2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${v}C${k+1} = xTexelR${v}C${k+2};
                `}}else k<m&&(y+=`
              if(xR >= 0 && xR < ${a}) {
            `,c%2==1?(y+=`
                xCOffset = xC + 1 - ${h};
                if(xCOffset >= 0 && xCOffset < ${i}) {
                  xTexelR${v}C${k} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${v}C${k} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${i}) {
                  xTexelR${v}C${k+2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${v}C${k+2} = vec4(0.);
                }

                xR${v}C${k} = vec4(
                  xTexelR${v}C${k}.zw, xTexelR${v}C${k+2}.zw);
              `,k+1<m&&(y+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${h};
                  if(xCOffset >= 0 && xCOffset < ${i}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${v}C${k+1} = vec4(xTexelR${v}C${k+2}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < ${i}) {
                  xTexelR${v}C${k} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${v}C${k} = vec4(0.);
                }

                xCOffset = xC + ${h};
                if(xCOffset >= 0 && xCOffset < ${i}) {
                  xTexelR${v}C${k+2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${v}C${k+2} = vec4(0.);
                }

                xR${v}C${k} = vec4(
                  xTexelR${v}C${k}.xy, xTexelR${v}C${k+2}.xy);
              `,k+1<m&&(y+=`
                  xR${v}C${k+1} = vec4(
                    xTexelR${v}C${k}.zw, xTexelR${v}C${k+2}.zw);
                `)),y+="}");k<m&&(y+=`
            vec4 wTexelR${v}C${k} = getW(${v}, ${k}, d1, q);
            wR${v}C${k} = vec4(wTexelR${v}C${k}.xz, wTexelR${v}C${k}.xz);
          `,k+1<m&&(y+=`
              vec4 wTexelR${v}C${k+1} = getW(${v}, ${k+1}, d1, q);
              wR${v}C${k+1} =
                vec4(wTexelR${v}C${k+1}.xz, wTexelR${v}C${k+1}.xz);`))}for(let v=0;v<f;v++)for(let I=0;I<m;I++)y+=`dotProd += xR${v}C${I} * wR${v}C${I};`;let b="",C="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,C="result = activation(result);");let w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      const ivec2 strides = ivec2(${u}, ${h});
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${y}

        vec4 result = dotProd;
        ${w}
        ${C}
        setOutput(result);
      }
    `}}function KU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:c}=s,u=l;u==null&&(u=[1,1]),N(Te(a,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let h=xe(r.shape,o.shape,a,u,i,c,!0),d;return G().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?d=new K1(h):d=new q1(h),e.runWebGLProgram(d,[r,o],"float32")}let XU={kernelName:Ka,backendName:"webgl",kernelFunc:KU};class YU{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class JU{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=s-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function ZU(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=s,h=xe(r.shape,u,a,i,l,c,!0),d=new YU(h);return e.runWebGLProgram(d,[r,o],"float32")}let QU={kernelName:xc,backendName:"webgl",kernelFunc:ZU};function tG(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=s,h=xe(u,o.shape,a,i,l,c,!0),d=new JU(h);return e.runWebGLProgram(d,[r,o],"float32")}let eG={kernelName:wc,backendName:"webgl",kernelFunc:tG};class nG{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function sG(n){let{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],o=H(s.shape),a=ot({inputs:{x:s},backend:e,attrs:{shape:[o]}}),i=new nG(o),l=e.runWebGLProgram(i,[a],a.dtype),c=ot({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}let rG={kernelName:$c,backendName:"webgl",kernelFunc:sG};class oG{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:s,padInfo:r,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function aG(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o}=t,{strides:a,pad:i,dilations:l}=s,c=qi(r.shape,o.shape,a,i,"NHWC",l),u,h=new oG(c);u=e.runWebGLProgram(h,[r,o],"float32");let d=ot({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),d}let iG={kernelName:Xa,backendName:"webgl",kernelFunc:aG};let lG=Et({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),cG={kernelName:to,backendName:"webgl",kernelFunc:lG};let uG="return (b >= 1.0) ? a : a * (b + 1.0);",hG=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,dG={kernelName:Nc,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e}=n,{dy:s,y:r}=t,o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zl(hG,s.shape,r.shape):new Aa(uG,s.shape,r.shape);return e.runWebGLProgram(o,[s,r],s.dtype)}};let pG=Re({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool"}),fG={kernelName:Ya,backendName:"webgl",kernelFunc:pG};let mG=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Qp};
  float a1 = ${tf};
  float a2 = ${ef};
  float a3 = ${nf};
  float a4 = ${sf};
  float a5 = ${rf};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,gG=Et({opSnippet:mG}),yG={kernelName:eo,backendName:"webgl",kernelFunc:gG};let X1="return exp(x);",Y1=Et({opSnippet:X1,packedOpSnippet:X1,cpuKernelImpl:kV}),bG={kernelName:no,backendName:"webgl",kernelFunc:Y1};function Dg(n){let{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:o}=t,a=o.shape.length,i=o.shape.slice(),l=r;return r<0&&(N(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),i.splice(l,0,1),ot({inputs:{x:o},backend:s,attrs:{shape:i}})}let xG={kernelName:Ja,backendName:"webgl",kernelFunc:Dg};let J1="return exp(x) - 1.0;",wG=Et({opSnippet:J1,packedOpSnippet:J1,cpuKernelImpl:IV}),$G={kernelName:so,backendName:"webgl",kernelFunc:wG};class Z1{constructor(t,e,s){this.variableNames=["real","imag"];let r=e[1];this.outputShape=e;let o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0",i;if(t==="real")i="return real * expR - imag * expI;";else if(t==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function Q1(n,t,e){let s=e.texData.get(n.dataId),r=H(n.shape),o=n.shape[n.shape.length-1],a=r/o,i=ot({inputs:{x:n},backend:e,attrs:{shape:[a,o]}}),l=i.shape,c=new Z1("real",l,t),u=new Z1("imag",l,t),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=e.runWebGLProgram(c,h,"float32"),p=e.runWebGLProgram(u,h,"float32"),f=Ks({inputs:{real:d,imag:p},backend:e});e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p);let m=ot({inputs:{x:f},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(f),m}function vG(n){let{inputs:t,backend:e}=n,{input:s}=t;return Q1(s,!1,e)}let CG={kernelName:kc,backendName:"webgl",kernelFunc:vG};class NG{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(t){return(e,s)=>{this.valueLoc==null&&(this.valueLoc=e.getUniformLocationNoThrow(s,"value")),e.gl.uniform1f(this.valueLoc,t)}}}function Rg(n){let{backend:t,attrs:e}=n,{shape:s,value:r}=e,{dtype:o}=e;if(o=o||Mr(r),o==="string"){let a=er(o,H(s));return a.fill(r),t.makeTensorInfo(s,o,a)}else{let a=new NG(s,r),i=a.getCustomSetupFunc(r);return t.runWebGLProgram(a,[],o,i)}}let kG={kernelName:Ic,backendName:"webgl",kernelFunc:Rg};class IG{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let SG={kernelName:Sc,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{let{image:e}=n,s=t,r=new IG(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}};let t$="return floor(x);",TG=Et({opSnippet:t$,packedOpSnippet:t$,cpuKernelImpl:SV}),EG={kernelName:ro,backendName:"webgl",kernelFunc:TG};let AG=Re({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),DG={kernelName:oo,backendName:"webgl",kernelFunc:AG};class RG{constructor(t){this.variableNames=["A"];let e=Pe(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class FG{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=Pe(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}let _G={kernelName:Jc,backendName:"webgl",kernelFunc:OG},Ra;function OG(n){let{inputs:t,backend:e,attrs:s}=n,{pixels:r}=t,{numChannels:o}=s,a=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,l=typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap,[c,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[u,c],d=[u,c,o];(i||a||l)&&(Ra==null&&(Ra=document.createElement("canvas").getContext("2d")),Ra.canvas.width=c,Ra.canvas.height=u,Ra.drawImage(r,0,0,c,u),r=Ra.canvas);let p=e.makeTensorInfo(h,"int32");e.texData.get(p.dataId).usage=dn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(p.dataId),r);let f=G().getBool("WEBGL_PACK")?new FG(d):new RG(d),m=e.runWebGLProgram(f,[p],"int32");return e.disposeData(p.dataId),m}function LG(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=is(u),g=xe(r.shape,o.shape,l,h,c,d,!1,m),y,b=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=W1({x:r,filter:o,convInfo:g,backend:e,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else if(G().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)y=U1({x:r,filter:o,convInfo:g,backend:e,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{let w=a!=null,v=i!=null,I=p==="leakyrelu",k=p?id(p,!1):null,T=new V1(g,w,k,v,I),E=[r,o];if(a&&E.push(a),i&&E.push(i),I){let F=e.makeTensorInfo([],"float32",ss(f,"float32"));E.push(F),b.push(F)}y=e.runWebGLProgram(T,E,"float32")}let C=ot({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(w=>e.disposeIntermediateTensorInfo(w)),C}let PG={kernelName:Li,backendName:"webgl",kernelFunc:LG};function zG(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[],m=u;m==null&&(m=[1,1]),N(Te(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=xe(r.shape,o.shape,l,m,c,h,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=d?id(d,y):null,C=[r,o],w=a!=null,v=i!=null,I=d==="leakyrelu";if(w&&C.push(a),v&&C.push(i),I){let E=e.makeTensorInfo([],"float32",ss(p,"float32"));C.push(E),f.push(E)}let k;y?k=new K1(g,w,b,v,I):k=new q1(g,w,b,v,I);let T=e.runWebGLProgram(k,C,"float32");return f.forEach(E=>e.disposeIntermediateTensorInfo(E)),T}let MG={kernelName:Pi,backendName:"webgl",kernelFunc:zG};class BG{constructor(t,e,s){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=s;let r=zt(e.length),o=zt(s.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}function VG(n){let{inputs:t,backend:e}=n,{params:s,indices:r}=t,o=r.shape,a=o[o.length-1],[i,l,c,u]=hu(s,r),h=ot({inputs:{x:r},backend:e,attrs:{shape:[l,a]}}),d=ot({inputs:{x:s},backend:e,attrs:{shape:[H(s.shape)/c,c]}}),p=new BG(a,u,[l,c]),f=e.runWebGLProgram(p,[d,h],d.dtype),m=ot({inputs:{x:f},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),m}let WG={kernelName:Tc,backendName:"webgl",kernelFunc:VG};class UG{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let s=zt(this.rank),r=GG(t,2);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function GG(n,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("int(getIndices(resRC.x, resRC.z))"):s.push(`${e[r]}`);return s.join()}function HG(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,indices:o}=t,{axis:a,batchDims:i}=s,l=$t(a,r.shape)[0],c=lf(r,o,l,i),u=H(o.shape),h=[],d=ot({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=ot({inputs:{x:o},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);let f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let b=e.bufferSync(p),C=e.bufferSync(d),w=TV(C,b,f);return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.makeTensorInfo(c.outputShape,w.dtype,w.values)}let m=new UG(d.shape,f),g=e.runWebGLProgram(m,[d,p],d.dtype);h.push(g);let y=ot({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return h.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}let jG={kernelName:Qa,backendName:"webgl",kernelFunc:HG};let qG=Re({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:EV,dtype:"bool"}),KG={kernelName:ti,backendName:"webgl",kernelFunc:qG};let XG=Re({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool"}),YG={kernelName:ao,backendName:"webgl",kernelFunc:XG};function JG(n){let{inputs:t,backend:e}=n,{input:s}=t;return Q1(s,!0,e)}let ZG={kernelName:Ec,backendName:"webgl",kernelFunc:JG};let QG=Et({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),tH={kernelName:lo,backendName:"webgl",kernelFunc:QG};let eH=Et({opSnippet:"return float(isinf(x));",dtype:"bool"}),nH={kernelName:co,backendName:"webgl",kernelFunc:eH};let sH=Et({opSnippet:"return float(isnan(x));",dtype:"bool"}),rH={kernelName:uo,backendName:"webgl",kernelFunc:sH};let oH=Re({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:AV,dtype:"bool"}),aH={kernelName:ni,backendName:"webgl",kernelFunc:oH};let iH=Re({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,dtype:"bool"}),lH={kernelName:si,backendName:"webgl",kernelFunc:iH};function cH(n){let{backend:t,attrs:e}=n,{start:s,stop:r,num:o}=e,a=DV(s,r,o);return t.makeTensorInfo([a.length],"float32",a)}let uH={kernelName:Dc,backendName:"webgl",kernelFunc:cH};let hH=Et({opSnippet:`if (x < 0.0) return NAN;
  return log(x);`,packedOpSnippet:`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,cpuKernelImpl:RV}),dH={kernelName:ho,backendName:"webgl",kernelFunc:hH};let pH=Et({opSnippet:"return log(1.0 + x);"}),fH={kernelName:po,backendName:"webgl",kernelFunc:pH};let mH=Re({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),gH={kernelName:ri,backendName:"webgl",kernelFunc:mH};let yH=Et({opSnippet:"return float(!(x >= 1.0));"}),bH={kernelName:oi,backendName:"webgl",kernelFunc:yH};let xH=Re({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),wH={kernelName:ai,backendName:"webgl",kernelFunc:xH};class $H{constructor(t,e,s,r,o){this.variableNames=["x"],this.outputShape=[];let a=e,i=t[3]-1;this.outputShape=t;let l,c=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class vH{constructor(t,e,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=e,i=t[3]-1;this.outputShape=t;let l,c=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}let CH={kernelName:ii,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=s,c=G().getBool("WEBGL_PACK_NORMALIZATION")?new vH(r.shape,o,a,i,l):new $H(r.shape,o,a,i,l);return e.runWebGLProgram(c,[r],r.dtype)}};class NH{constructor(t,e,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}let kH={kernelName:Rc,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{x:r,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:c,beta:u}=s,h=new NH(r.shape,i,l,c,u);return e.runWebGLProgram(h,[r,o,a],r.dtype)}};function IH(n,t,e,s){let r=H(t),a=H(n.shape)/r,i=ot({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Lr(i,n.dtype,"max",s),c=ot({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),c}function e$(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:o,keepDims:a}=s,i=r.shape.length,l=$t(o,r.shape),c=l,u=se(c,i),h=u!=null,d=e.shouldExecuteOnCPU([r]),p=r;if(h){if(d){let C=e.texData.get(p.dataId).values,w=new Array(i);for(let k=0;k<w.length;k++)w[k]=r.shape[u[k]];let v=Ig(C,r.shape,r.dtype,u,w);p=e.makeTensorInfo(w,r.dtype);let I=e.texData.get(p.dataId);I.values=v}else p=ld(r,u,e);c=ae(c.length,i)}Ee("max",c,i);let[f,m]=we(p.shape,c),g=f;a&&(g=ne(f,l));let y;if(d){let C=e.texData.get(p.dataId).values,w=FV(C,H(m),g,r.dtype);y=e.makeTensorInfo(g,r.dtype);let v=e.texData.get(y.dataId);v.values=w}else y=IH(p,m,g,e);return h&&e.disposeIntermediateTensorInfo(p),y}let SH={kernelName:li,backendName:"webgl",kernelFunc:e$};let TH=b1+`
  return max(a, b);
`,EH=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+ad+`
  return result;
`,AH=Re({opSnippet:TH,packedOpSnippet:EH,cpuKernelImpl:_V}),DH={kernelName:fo,backendName:"webgl",kernelFunc:AH};function RH(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Yl(r,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,c=1;N(Te(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let u=mn(r.shape,o,a,c,i,l);if(u.filterWidth===1&&u.filterHeight===1&&At(u.inShape,u.outShape))return nn({inputs:{x:r},backend:e});let h=new Ql(u,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}let FH={kernelName:ci,backendName:"webgl",kernelFunc:RH};function _H(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=as(r.shape,o,a,u,i,c,l),d=new Tg(h,"max",!1);return e.runWebGLProgram(d,[r],r.dtype)}let OH={kernelName:ui,backendName:"webgl",kernelFunc:_H};class LH{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,l=a-1-t.padInfo.left,c=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class PH{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth,h=l-1-t.padInfo.front,d=c-1-t.padInfo.top,p=u-1-t.padInfo.left,f=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function zH(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o}=t,a=o,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=as(a.shape,i,l,h,c,u),p=new Tg(d,"max",!0),f=e.runWebGLProgram(p,[a],a.dtype),m=new PH(d),g=e.runWebGLProgram(m,[r,f],a.dtype);return e.disposeIntermediateTensorInfo(f),g}let MH={kernelName:_c,backendName:"webgl",kernelFunc:zH};function BH(n){let{inputs:t,backend:e,attrs:s}=n,{dy:r,input:o,output:a}=t,i=o;Yl([o,a],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=mn(i.shape,l,c,1,u,h),p=!0,f=new Ql(d,"max",p),m=e.runWebGLProgram(f,[i],i.dtype),g=new LH(d),y=e.runWebGLProgram(g,[r,m],i.dtype);return e.disposeIntermediateTensorInfo(m),y}let VH={kernelName:Fc,backendName:"webgl",kernelFunc:BH};function WH(n,t,e,s){let r=new Ql(e,"max",!1),o=s.runWebGLProgram(r,[n],"float32");r=new Ql(e,"max",!0,!0,t);let a=s.runWebGLProgram(r,[n],"float32");return[o,a]}let UH={kernelName:Oc,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=t,l=e;N(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let c=[1,1];N(Te(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let u=mn(s.shape,r,o,c,a),[h,d]=WH(s,i,u,l);return[h,d]}};function GH(n,t,e,s){let r=H(t),a=H(n.shape)/r,i=ot({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Lr(i,"float32","mean",s),c=ot({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),c}let HH={kernelName:hi,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:s}=n,{keepDims:r,axis:o}=t,a=e,i=s.shape.length,l=$t(o,s.shape),c=l,u=se(c,i),h=u!=null,d=a.shouldExecuteOnCPU([s]),p=[],f=s;if(h){if(d){let w=a.texData.get(f.dataId).values,v=new Array(i);for(let T=0;T<v.length;T++)v[T]=s.shape[u[T]];let I=Ig(w,s.shape,s.dtype,u,v);f=a.makeTensorInfo(v,s.dtype);let k=a.texData.get(f.dataId);k.values=I}else f=ld(s,u,a);p.push(f),c=ae(c.length,i)}Ee("sum",c,i);let[m,g]=we(f.shape,c),y=m;r&&(y=ne(m,l));let b=GH(f,g,y,a);for(let C of p)a.disposeIntermediateTensorInfo(C);return b}};function jH(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s,i=r.shape.length,l=$t(o,r.shape),c=l,u=se(c,i),h=r;u!=null&&(h=Ue({inputs:{x:r},backend:e,attrs:{perm:u}}),c=ae(c.length,r.shape.length)),Ee("min",c,i);let[d,p]=we(h.shape,c),f=H(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Lr(m,m.dtype,"min",e),y;if(a){let b=ne(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}let qH={kernelName:di,backendName:"webgl",kernelFunc:jH};let KH=b1+`
  return min(a, b);
`,XH=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+ad+`
  return result;
`,YH=Re({opSnippet:KH,packedOpSnippet:XH,cpuKernelImpl:OV}),JH={kernelName:mo,backendName:"webgl",kernelFunc:YH};class ZH{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((u,h)=>u[0]+t[h]+u[1]);let r=t.length,o=zt(r),a=e.map(u=>u[0]).join(","),i=e.map((u,h)=>u[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class QH{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,m)=>f[0]+t[m]+f[1]);let r=t.length,o=zt(r),a=e.map(f=>f[0]).join(","),i=e.map((f,m)=>f[0]+t[m]).join(","),l=ze("rc",r),c=ze("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1,p="";if(r===1){let f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{let f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[r-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}let tj={kernelName:pi,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:s}=n,{paddings:r,mode:o}=e,a=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QH(s.shape,r,o):new ZH(s.shape,r,o);return t.runWebGLProgram(a,[s],s.dtype)}};let ej=`if (b == 0.0) return NAN;
  return mod(a, b);`,nj=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+ad+`
  return result;
`,sj=Re({opSnippet:ej,packedOpSnippet:nj}),rj={kernelName:go,backendName:"webgl",kernelFunc:sj};class oj{constructor(t,e,s){this.variableNames=["probs"],this.outputShape=[t,s],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}getCustomSetupFunc(t){return(e,s)=>{this.seedLoc==null&&(this.seedLoc=e.getUniformLocation(s,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}let n$=Re({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),aj={kernelName:Qr,backendName:"webgl",kernelFunc:n$};let s$="return a - b;",r$=Re({opSnippet:s$,packedOpSnippet:s$,supportsComplex:!0,cpuKernelImpl:UV}),ij={kernelName:Ro,backendName:"webgl",kernelFunc:r$};function o$(n){let{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:o}=s,a=$t([o],r.shape),i=e$({inputs:{x:r},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),l=ne(i.shape,a),c=ot({inputs:{x:i},backend:e,attrs:{shape:l}}),u=r$({inputs:{a:r,b:c},backend:e}),h=Y1({inputs:{x:u},backend:e}),d=Sg({inputs:{x:h},backend:e,attrs:{axis:a,keepDims:!1}}),p=ot({inputs:{x:d},backend:e,attrs:{shape:l}}),f=n$({inputs:{a:h,b:p},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),f}let lj={kernelName:Ai,backendName:"webgl",kernelFunc:o$};function cj(n){let{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:o,seed:a,normalized:i}=s,l=i?r:o$({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new oj(c,u,o),d=h.getCustomSetupFunc(a),p=e.runWebGLProgram(h,[l],"int32",d);return i||e.disposeIntermediateTensorInfo(l),p}let uj={kernelName:Lc,backendName:"webgl",kernelFunc:cj};let a$="return -x;";function hj(n){let{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){let o=e.texData.get(s.dataId),[a,i]=PV(o.values,s.shape,s.dtype);return e.makeTensorInfo(i,s.dtype,a)}let r;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ea(s.shape,a$):r=new qs(s.shape,a$),e.runWebGLProgram(r,[s],s.dtype)}let dj={kernelName:fi,backendName:"webgl",kernelFunc:hj};let pj=Yu;function fj(n){oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s,c=e.readSync(r.dataId),u=e.readSync(o.dataId),{selectedIndices:h}=pj(c,u,a,i,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}let mj={kernelName:Pc,backendName:"webgl",kernelFunc:fj};let gj=Ju;function yj(n){oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=s,u=e.readSync(r.dataId),h=e.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=gj(u,h,a,i,l,c);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}let bj={kernelName:zc,backendName:"webgl",kernelFunc:yj};let xj=Zu;function wj(n){oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=s,u=e.readSync(r.dataId),h=e.readSync(o.dataId),d=a,p=i,f=l,m=c,{selectedIndices:g,selectedScores:y}=xj(u,h,d,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}let $j={kernelName:Mc,backendName:"webgl",kernelFunc:wj};class vj{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}let Cj={kernelName:yi,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{depth:o,onValue:a,offValue:i}=s,l=H(r.shape),c=new vj(l,o,a,i),u=ot({inputs:{x:r},backend:e,attrs:{shape:[l]}}),h=e.runWebGLProgram(c,[u],r.dtype);e.disposeIntermediateTensorInfo(u);let d=[...r.shape,o],p=ot({inputs:{x:h},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(h),p}};function pd(n){let{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){let r=ec({inputs:{input:s},backend:e}),o=pd({inputs:{x:r},backend:e}),a=dd({inputs:{input:s},backend:e}),i=pd({inputs:{x:a},backend:e}),l=Ks({inputs:{real:o,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),l}else return Rg({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}let Nj={kernelName:_i,backendName:"webgl",kernelFunc:pd};function i$(n){let{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){let r=ec({inputs:{input:s},backend:e}),o=i$({inputs:{x:r},backend:e}),a=dd({inputs:{input:s},backend:e}),i=pd({inputs:{x:a},backend:e}),l=Ks({inputs:{real:o,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),l}else return Rg({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}let kj={kernelName:gi,backendName:"webgl",kernelFunc:i$};function Ij(n){let{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return Dg({inputs:{input:t[0]},backend:e,attrs:{dim:r}});let o=t[0].shape,a=t[0].dtype;t.forEach(u=>{ge(o,u.shape,"All tensors passed to stack must have matching shapes"),N(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(u=>{let h=Dg({inputs:{input:u},backend:e,attrs:{dim:r}});return i.push(h),h}),c=B1({inputs:l,backend:e,attrs:{axis:r}});return i.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}let Sj={kernelName:bi,backendName:"webgl",kernelFunc:Ij};class Tj{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);let r=t.length,o=zt(r),a=e.map(c=>c[0]).join(","),i=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${s}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${s}));
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class Ej{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);let r=t.length,o=zt(r),a=e.map(m=>m[0]).join(","),i=e.map((m,g)=>m[0]+t[g]).join(","),l=ze("rc",r),c=ze("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${u}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(${s});
        } else {
          ${o} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}let l$=n=>{let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:o,constantValue:a}=s,i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ej(r.shape,o,a):new Tj(r.shape,o,a);return e.runWebGLProgram(i,[r],r.dtype)},Aj={kernelName:xi,backendName:"webgl",kernelFunc:l$};let Dj=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Rj=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+ad+`
  return result;
`,Fj=Re({opSnippet:Dj,packedOpSnippet:Rj}),_j={kernelName:bo,backendName:"webgl",kernelFunc:Fj};function Oj(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:o,keepDims:a}=s,i=r.shape.length,l=[],c=$t(o,r.shape),u=c,h=se(u,i),d=r;h!=null&&(d=Ue({inputs:{x:r},backend:e,attrs:{perm:h}}),u=ae(u.length,i),l.push(d)),Ee("prod",u,i);let p;if(e.shouldExecuteOnCPU([d])){let f=e.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=zV(d.shape,d.dtype,f,u);p=e.makeTensorInfo(g,y,m)}else{let[f,m]=we(d.shape,u),g=H(m),y=ot({inputs:{x:d},backend:e,attrs:{shape:[-1,g]}}),b=su(r.dtype),C=Lr(y,b,"prod",e);p=ot({inputs:{x:C},backend:e,attrs:{shape:f}}),l.push(y),l.push(C)}if(a){l.push(p);let f=ne(p.shape,c);p=ot({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}let Lj={kernelName:Bc,backendName:"webgl",kernelFunc:Oj};let c$=n=>{let{backend:t,attrs:e}=n,{start:s,stop:r,step:o,dtype:a}=e,i=MV(s,r,o,a);return t.makeTensorInfo([i.length],a,i)},Pj={kernelName:Vc,backendName:"webgl",kernelFunc:c$};let zj=Et({opSnippet:"return 1.0 / x;"}),Mj={kernelName:xo,backendName:"webgl",kernelFunc:zj};let Bj=Nn+`
  return (x < 0.0) ? 0.0 : x;
`,Vj=Et({opSnippet:Bj,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Wj={kernelName:wo,backendName:"webgl",kernelFunc:Vj};let Uj=Nn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Gj=Et({opSnippet:Uj,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Hj={kernelName:$o,backendName:"webgl",kernelFunc:Gj};class jj{constructor(t,e,s,r,o){this.variableNames=["A"],this.outputShape=[];let[a,i,l,c]=t;this.outputShape=[a,e,s,c];let u=[r&&e>1?i-1:i,r&&s>1?l-1:l],h=[r&&e>1?e-1:e,r&&s>1?s-1:s],d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class qj{constructor(t,e,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,l,c]=t;this.outputShape=[a,e,s,c];let u=[r&&e>1?i-1:i,r&&s>1?l-1:l],h=[r&&e>1?e-1:e,r&&s>1?s-1:s],d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Kj(n){let{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,c]=i,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qj(r.shape,l,c,o,a):new jj(r.shape,l,c,o,a);return e.runWebGLProgram(u,[r],"float32")}let Xj={kernelName:Ci,backendName:"webgl",kernelFunc:Kj};class Yj{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,r,o]=e,[,a,i]=t,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],c=[s&&a>1?a-1:a,s&&i>1?i-1:i],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function Jj(n){let{inputs:t,backend:e,attrs:s}=n,{images:r,dy:o}=t,{alignCorners:a}=s,i=new Yj(o.shape,r.shape,a);return e.runWebGLProgram(i,[o],o.dtype)}let Zj={kernelName:Gc,backendName:"webgl",kernelFunc:Jj};class Qj{constructor(t,e,s,r,o){this.variableNames=["A"],this.outputShape=[];let[a,i,l,c]=t;this.outputShape=[a,e,s,c];let u=[r&&e>1?i-1:i,r&&s>1?l-1:l],h=[r&&e>1?e-1:e,r&&s>1?s-1:s],d=r?"0.5":"0.0",p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}function tq(n){let{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,c]=i,u=new Qj(r.shape,l,c,o,a);return e.runWebGLProgram(u,[r],r.dtype)}let eq={kernelName:vi,backendName:"webgl",kernelFunc:tq};class nq{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,r,o]=e,[,a,i]=t,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],c=[s&&a>1?a-1:a,s&&i>1?i-1:i],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function sq(n){let{inputs:t,backend:e,attrs:s}=n,{images:r,dy:o}=t,{alignCorners:a}=s,i=new nq(o.shape,r.shape,a);return e.runWebGLProgram(i,[o],o.dtype)}let rq={kernelName:Uc,backendName:"webgl",kernelFunc:sq};class oq{constructor(t,e){this.variableNames=["x"];let s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let r=i=>e.indexOf(i)!==-1&&t[i]!==1?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`,o=t.map((i,l)=>r(l)).join(","),a=zt(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}class aq{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;let r=ze("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=zt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${o}){
            result.g = ${c(r.slice())};
          }
          if(${a}) {
            result.b = ${u(r.slice())};
            if(${o}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function u(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){let m=t.map((b,C)=>p(C,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return e.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}}}function iq(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:o}=s,a=r.shape.length,i=$t(o,r.shape);if(a===0)return nn({inputs:{x:r},backend:e});let l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aq(r.shape,i):new oq(r.shape,i);return e.runWebGLProgram(l,[r],r.dtype)}let lq={kernelName:Ni,backendName:"webgl",kernelFunc:iq};class cq{constructor(t,e,s,r){this.variableNames=["Image"],this.outputShape=[];let o=t[1],a=t[2],i=Math.sin(e).toFixed(3),l=Math.cos(e).toFixed(3);this.outputShape=t;let[c,u]=Yp(r,o,a),h=c.toFixed(3),d=u.toFixed(3),p="";typeof s=="number"?p=`float outputValue = ${s.toFixed(2)};`:p=`
        vec3 fill = vec3(${s.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${h}) * ${l} - (float(y) - ${d}) * ${i};
          float coordYFloat = (float(x) - ${h}) * ${i} + (float(y) - ${d}) * ${l};
          int coordX = int(round(coordXFloat + ${h}));
          int coordY = int(round(coordYFloat + ${d}));
          ${p}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${o}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let uq={kernelName:Zc,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:s}=n,{radians:r,fillValue:o,center:a}=t,i=e,l=new cq(s.shape,r,o,a);return i.runWebGLProgram(l,[s],s.dtype)}};let hq=Et({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),dq={kernelName:vo,backendName:"webgl",kernelFunc:hq};let pq=Et({opSnippet:"return inversesqrt(x);",cpuKernelImpl:BV}),fq={kernelName:Co,backendName:"webgl",kernelFunc:pq};class u${constructor(t,e,s,r,o,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=zt(o.length),c=zt(a.length),u="";s===1?u="i":s===2&&(u="i, j");let h=`getIndices(${u})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,f=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}function mq(n){let{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:o}=t,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Uo(o,r,a),d=[h/c,c];if(h===0)return e.makeTensorInfo(a,r.dtype);let p=ot({inputs:{x:r},backend:e,attrs:{shape:[l,i]}}),f=ot({inputs:{x:o},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new u$(l,i,p.shape.length,f.shape.length,u,d),y=e.runWebGLProgram(g,[f,p,m],f.dtype),b=ot({inputs:{x:y},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}let gq={kernelName:Hc,backendName:"webgl",kernelFunc:mq};class yq{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${i[u]}`),u<t&&l.push(`${i[u]}`);r=l.join(),o=c.join()}let a=zt(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}function bq(n){let{inputs:t,backend:e}=n,{condition:s,t:r,e:o}=t,a=new yq(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(a,[s,r,o],Ge(r.dtype,o.dtype))}let xq={kernelName:ki,backendName:"webgl",kernelFunc:bq};let wq=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${eh};
  float scale = ${nh};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,$q=Et({opSnippet:wq}),vq={kernelName:No,backendName:"webgl",kernelFunc:$q};let Cq=Et({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Nq={kernelName:To,backendName:"webgl",kernelFunc:Cq};let kq=Et({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),Iq={kernelName:So,backendName:"webgl",kernelFunc:kq};let Sq=C1+`
  return sin(x);
`,Tq=Et({opSnippet:Sq}),Eq={kernelName:ko,backendName:"webgl",kernelFunc:Tq};let Aq=Et({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),Dq={kernelName:Io,backendName:"webgl",kernelFunc:Aq};let Rq=Et({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),Fq={kernelName:Eo,backendName:"webgl",kernelFunc:Rq};let _q={kernelName:Ti,backendName:"webgl",kernelFunc:n=>{let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:o,paddings:a}=s;N(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...a);for(let y=1+o.length;y<r.shape.length;++y)l.push([0,0]);let c=[],u=l$({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),h=yl(u.shape,o,i,!1),d=bl(h.length,o.length,!1),p=xl(u.shape,o,i,!1),f=ot({inputs:{x:u},backend:e,attrs:{shape:h}}),m=Ue({inputs:{x:f},backend:e,attrs:{perm:d}}),g=ot({inputs:{x:m},backend:e,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}};function Oq(n){let{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=t,{outputShape:i}=s,{sliceRank:l,numUpdates:c,strides:u,outputSize:h}=Uo(o,r,i),d=!1,p=new u$(c,l,r.shape.length,o.shape.length,u,[h,1],d),f=e.runWebGLProgram(p,[o,r,a],o.dtype),m=ot({inputs:{x:f},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),m}let Lq={kernelName:qc,backendName:"webgl",kernelFunc:Oq};function Pq(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:o,axis:a}=s,i=$t(a,r.shape)[0],l=af(r,o,i),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map(d=>{let p=[...h];p[i]=d;let f=tc({inputs:{x:r},backend:e,attrs:{begin:u,size:p}});return u[i]+=d,f})}let zq={kernelName:Ei,backendName:"webgl",kernelFunc:Pq};let Mq=Et({opSnippet:"return sqrt(x);"}),Bq={kernelName:Ao,backendName:"webgl",kernelFunc:Mq};let Vq=Et({opSnippet:"return x * x;"}),Wq={kernelName:jc,backendName:"webgl",kernelFunc:Vq};let h$="return (a - b) * (a - b);",Uq=Re({opSnippet:h$,packedOpSnippet:h$}),Gq={kernelName:Do,backendName:"webgl",kernelFunc:Uq};function Hq({inputs:n,attrs:t,backend:e}){let{x:s}=n,r=Nn+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,o=new qs(s.shape,r);return e.runWebGLProgram(o,[s],s.dtype)}let jq={kernelName:Lo,backendName:"webgl",kernelFunc:Hq};class qq{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;let r=s.length,o=zt(s.length),a=zt(s.length),i="";if(r===1)i="coords * strides + begin";else{let l=0;i=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${t});
      ${o} strides = ${o}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}function Kq(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Qd(r.shape,o,a,i,l,c,u,h,d),C=ot({inputs:{x:r},backend:e,attrs:{shape:y}}),w;if(p){let I=tc({inputs:{x:C},backend:e,attrs:{begin:f,size:g}});w=ot({inputs:{x:I},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(I)}else if(b.some(I=>I===0))w=e.makeTensorInfo(b,r.dtype,[]);else if(e.shouldExecuteOnCPU([C])){let T=e.texData.get(C.dataId).values,E=vt(C.shape,C.dtype,T),F=WV(b,E,m,f);w=e.makeTensorInfo(b,C.dtype,F.values)}else{let k=new qq(f,m,b);w=e.runWebGLProgram(k,[C],C.dtype)}let v=ot({inputs:{x:w},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(w),v}let Xq={kernelName:Kc,backendName:"webgl",kernelFunc:Kq};let Yq=Et({opSnippet:"return tan(x);"}),Jq={kernelName:Fo,backendName:"webgl",kernelFunc:Yq};let Zq=Et({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),Qq={kernelName:_o,backendName:"webgl",kernelFunc:Zq};class tK{constructor(t,e){this.variableNames=["A"];let s=new Array(t.length);for(let a=0;a<s.length;a++)s[a]=t[a]*e[a];this.outputShape=s,this.rank=s.length;let r=zt(this.rank),o=eK(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function eK(n){let t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}function d$(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:o}=s;if(r.dtype==="string"){let c=e.readSync(r.dataId).map(d=>or(d)),u=vt(r.shape,r.dtype,c),h=GV(u,o);return e.makeTensorInfo(h.shape,h.dtype,h.values)}let a=new tK(r.shape,o);return e.runWebGLProgram(a,[r],r.dtype)}let nK={kernelName:Oo,backendName:"webgl",kernelFunc:d$};function sK(n){let{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:o,sorted:a}=s,i=e.readSync(r.dataId),[l,c]=HV(i,r.shape,r.dtype,o,a);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}let rK={kernelName:Xc,backendName:"webgl",kernelFunc:sK};function oK(n){let{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:o}=t;Yl(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=s.readSync(o.dataId),{outputValues:i,outputShape:l,indices:c}=jV(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([c.length],"int32",c)]}let aK={kernelName:Yc,backendName:"webgl",kernelFunc:oK};function iK(n){let{inputs:t,backend:e,attrs:s}=n,{value:r}=t,{axis:o}=s;o<0&&(o+=r.shape.length);let a=r,i=a.shape.length,l=r.shape[o],c=new Array(i-1),u=0;for(let m=0;m<i;m++)m!==o&&(c[u++]=a.shape[m]);let h=[],d=new Array(i).fill(0),p=a.shape.slice();p[o]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[o]=m;let g=tc({inputs:{x:a},backend:e,attrs:{begin:d,size:p}}),y=ot({inputs:{x:g},backend:e,attrs:{shape:c}});f[m]=y,h.push(g)}return h.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}let lK={kernelName:Ri,backendName:"webgl",kernelFunc:iK};class cK{constructor(t,e){this.variableNames=["x","segmentIds"];let s=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/s);this.outputShape=[r,i];let l="0.0",c="sumValue",u=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `,p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}function uK(n){let{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:o}=t,{numSegments:a}=s,i=r.shape.length,l=[],c=0,u=se([c],i),h=r;u!=null&&(h=Ue({inputs:{x:r},backend:e,attrs:{perm:u}}),l.push(h),c=ae(1,i)[0]);let d=Fb(h.shape,c,a),p=H([h.shape[c]]),f=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,p]}});l.push(f);let m=su(r.dtype),g=(w,v,I,k,T)=>{let E=w.shape[0],F=w.shape[1],P=Rb(F,T),M={windowSize:P,inSize:F,batchSize:E,numSegments:T},z=new cK(M,v),U=e.compileAndRun(z,[w,I],k);if(l.push(U),U.shape[1]===T)return U;let B=c$({backend:e,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),V=d$({inputs:{x:B},backend:e,attrs:{reps:[F/P]}});return l.push(B),l.push(V),g(U,v,V,k,T)},y=g(f,"unsortedSegmentSum",o,m,a),b=ot({inputs:{x:y},backend:e,attrs:{shape:d}}),C=b;if(u!=null){l.push(b);let w=Yo(u);C=Ue({inputs:{x:C},backend:e,attrs:{perm:w}})}return l.forEach(w=>e.disposeIntermediateTensorInfo(w)),C}let hK={kernelName:Fi,backendName:"webgl",kernelFunc:uK};let dK=[CH,kH,UW,HW,KW,JW,QW,n4,r4,a4,u4,d4,m4,b4,k4,$4,T4,R4,A4,L4,z4,B4,U4,X4,J4,nU,rU,lU,hU,NW,mU,kU,SU,xU,DU,FU,EU,LU,zU,BU,WU,GU,qU,QU,eG,XU,rG,iG,cG,dG,fG,yG,bG,xG,$G,CG,kG,SG,EG,DG,_G,PG,MG,WG,jG,KG,YG,CW,ZG,fU,tH,nH,rH,IW,aH,lH,uH,fH,dH,gH,bH,wH,SH,OH,FH,MH,VH,UH,DH,HH,qH,JH,tj,rj,uj,DW,dj,mj,bj,$j,Z4,Cj,kj,Sj,Aj,_j,TW,Lj,Pj,Q4,aj,Mj,Hj,Wj,FW,Xj,Zj,eq,rq,lq,uq,dq,fq,gq,xq,vq,Nq,Iq,Eq,Dq,K4,lj,Fq,_q,Lq,zq,Bq,Wq,Gq,jq,Xq,ij,BW,Jq,Qq,nK,rK,VW,aK,lK,hK,Nj];for(let n of dK)eu(n);let pK="3.2.0";let fK={"tfjs-core":Py,"tfjs-backend-cpu":HO,"tfjs-backend-webgl":$W,"tfjs-data":e0,"tfjs-layers":Th,"tfjs-converter":Ow,tfjs:pK};x.Abs=_a,x.Acos=Vr,x.Acosh=Wr,x.AdadeltaOptimizer=hl,x.AdagradOptimizer=dl,x.AdamOptimizer=pl,x.AdamaxOptimizer=fl,x.Add=sr,x.AddN=Oa,x.All=ic,x.Any=lc,x.ArgMax=La,x.ArgMin=Pa,x.Asin=Ur,x.Asinh=Gr,x.Atan=Hr,x.Atan2=qr,x.Atanh=jr,x.AvgPool=za,x.AvgPool3D=Ma,x.AvgPool3DGrad=uc,x.AvgPoolGrad=cc,x.BatchMatMul=Ba,x.BatchToSpaceND=Va,x.Bincount=hc,x.BroadcastTo=jg,x.Callback=xw,x.CallbackList=px,x.Cast=Kr,x.Ceil=Xr,x.ClipByValue=Yr,x.Complex=dc,x.ComplexAbs=Wa,x.Concat=Ua,x.Conv2D=Ga,x.Conv2DBackpropFilter=pc,x.Conv2DBackpropInput=Ha,x.Conv3D=ja,x.Conv3DBackpropFilterV2=fc,x.Conv3DBackpropInputV2=mc,x.Cos=Jr,x.Cosh=Zr,x.CropAndResize=gc,x.Cumsum=qa,x.CustomCallback=mx,x.DataStorage=fn,x.DenseBincount=yc,x.DepthToSpace=bc,x.DepthwiseConv2dNative=Ka,x.DepthwiseConv2dNativeBackpropFilter=xc,x.DepthwiseConv2dNativeBackpropInput=wc,x.Diag=$c,x.Dilation2D=Xa,x.Dilation2DBackpropFilter=Cc,x.Dilation2DBackpropInput=vc,x.EarlyStopping=$w,x.Elu=to,x.EluGrad=Nc,x.Environment=Gg,x.Equal=Ya,x.Erf=eo,x.Exp=no,x.ExpandDims=Ja,x.Expm1=so,x.FFT=kc,x.Fill=Ic,x.FlipLeftRight=Sc,x.Floor=ro,x.FloorDiv=oo,x.FromPixels=Jc,x.FusedBatchNorm=Za,x.FusedConv2D=Li,x.FusedDepthwiseConv2D=Pi,x.GatherNd=Tc,x.GatherV2=Qa,x.GraphModel=_w,x.Greater=ti,x.GreaterEqual=ao,x.History=fx,x.IFFT=Ec,x.Identity=io,x.Imag=Ac,x.InputSpec=ve,x.IsFinite=lo,x.IsInf=co,x.IsNan=uo,x.KernelBackend=zr,x.LRN=ii,x.LRNGrad=Rc,x.LayerVariable=Dn,x.LayersModel=gs,x.LeakyRelu=ei,x.Less=ni,x.LessEqual=si,x.LinSpace=Dc,x.Log=ho,x.Log1p=po,x.LogSoftmax=qg,x.LogicalAnd=ri,x.LogicalNot=oi,x.LogicalOr=ai,x.Max=li,x.MaxPool=ci,x.MaxPool3D=ui,x.MaxPool3DGrad=_c,x.MaxPoolGrad=Fc,x.MaxPoolWithArgmax=Oc,x.Maximum=fo,x.Mean=hi,x.Min=di,x.Minimum=mo,x.MirrorPad=pi,x.Mod=go,x.MomentumOptimizer=ml,x.Multinomial=Lc,x.Multiply=yo,x.Neg=fi,x.NonMaxSuppressionV3=Pc,x.NonMaxSuppressionV4=zc,x.NonMaxSuppressionV5=Mc,x.NotEqual=mi,x.OP_SCOPE_SUFFIX=ay,x.OneHot=yi,x.OnesLike=gi,x.Optimizer=hs,x.Pack=bi,x.PadV2=xi,x.Pool=E$,x.Pow=bo,x.Prelu=wi,x.Prod=Bc,x.RMSPropOptimizer=gl,x.RNN=Ln,x.Range=Vc,x.Real=Wc,x.RealDiv=Qr,x.Reciprocal=xo,x.Relu=wo,x.Relu6=$o,x.Reshape=$i,x.ResizeBilinear=Ci,x.ResizeBilinearGrad=Gc,x.ResizeNearestNeighbor=vi,x.ResizeNearestNeighborGrad=Uc,x.Reverse=Ni,x.RotateWithOffset=Zc,x.Round=vo,x.Rsqrt=Co,x.SGDOptimizer=ra,x.ScatterNd=Hc,x.Select=ki,x.Selu=No,x.Sequential=Ar,x.Sigmoid=To,x.Sign=So,x.Sin=ko,x.Sinh=Io,x.Slice=Ii,x.Softmax=Ai,x.Softplus=Eo,x.SpaceToBatchND=Ti,x.SparseToDense=qc,x.SplitV=Ei,x.Sqrt=Ao,x.Square=jc,x.SquaredDifference=Do,x.Step=Lo,x.StridedSlice=Kc,x.Sub=Ro,x.Sum=Si,x.SymbolicTensor=Rn,x.Tan=Fo,x.Tanh=_o,x.Tensor=Dt,x.TensorBuffer=ce,x.Tile=Oo,x.TopK=Xc,x.Transpose=Di,x.Unique=Yc,x.Unpack=Ri,x.UnsortedSegmentSum=Fi,x.Variable=Wi,x.ZerosLike=_i,x._FusedMatMul=Oi,x.abs=ue,x.acos=rp,x.acosh=op,x.add=Z,x.addN=Vy,x.all=yu,x.any=Hi,x.argMax=ji,x.argMin=ap,x.asin=ip,x.asinh=lp,x.atan=cp,x.atan2=up,x.atanh=hp,x.avgPool=Ki,x.avgPool3d=fp,x.backend=By,x.backend_util=Ob,x.basicLSTMCell=qC,x.batchNorm=fr,x.batchNorm2d=Wy,x.batchNorm3d=Uy,x.batchNorm4d=Gy,x.batchToSpaceND=Xi,x.bincount=Hy,x.booleanMaskAsync=oS,x.broadcastTo=Yi,x.browser=Xv,x.buffer=vt,x.callbacks=xF,x.cast=rt,x.ceil=mp,x.clipByValue=Me,x.clone=Ts,x.complex=ks,x.concat=ee,x.concat1d=jy,x.concat2d=qy,x.concat3d=Ky,x.concat4d=Xy,x.constraints=W2,x.conv1d=xu,x.conv2d=ls,x.conv2dTranspose=wu,x.conv3d=yp,x.conv3dTranspose=mN,x.copyRegisteredKernels=R$,x.cos=Ji,x.cosh=$u,x.cosineWindow=Gp,x.cumsum=vu,x.customGrad=Hn,x.data=nO,x.denseBincount=Jy,x.deprecationWarn=zy,x.depthToSpace=bp,x.depthwiseConv2d=jo,x.deregisterOp=$F,x.device_util=J$,x.diag=CN,x.dilation2d=xp,x.disableDeprecationWarnings=lC,x.dispose=bt,x.disposeVariables=cC,x.div=dt,x.divNoNan=wp,x.dot=Zy,x.dropout=fb,x.elu=qo,x.enableDebugMode=iC,x.enableProdMode=aC,x.enclosingPowerOfTwo=mb,x.engine=os,x.env=G,x.equal=cs,x.erf=$p,x.exp=on,x.expandDims=je,x.expm1=vp,x.eye=Cu,x.fft=ll,x.fill=Qi,x.findBackend=mC,x.findBackendFactory=gC,x.floor=Ko,x.floorDiv=gu,x.fused=CS,x.gather=mr,x.gatherND=pb,x.gather_util=Yv,x.getBackend=pC,x.getGradient=Sd,x.getKernel=Qc,x.getKernelsForBackend=tu,x.grad=JN,x.grads=ZN,x.greater=an,x.greaterEqual=Rs,x.ifft=ea,x.imag=Nu,x.image=_s,x.inTopKAsync=gS,x.initializers=IA,x.input=Mx,x.io=Bv,x.irfft=Bu,x.isFinite=Qy,x.isInf=tb,x.isNaN=eb,x.keep=be,x.kernel_impls=FT,x.layers=YR,x.leakyRelu=tl,x.less=ku,x.lessEqual=gr,x.linalg=kb,x.linspace=nb,x.loadGraphModel=w_,x.loadLayersModel=TD,x.localResponseNormalization=Cp,x.log=qe,x.log1p=Iu,x.logSigmoid=sb,x.logSoftmax=Tu,x.logSumExp=Ip,x.logicalAnd=gn,x.logicalNot=el,x.logicalOr=Eu,x.logicalXor=ob,x.losses=ET,x.matMul=It,x.math=jv,x.max=ln,x.maxPool=nl,x.maxPool3d=Sp,x.maxPoolWithArgmax=ab,x.maximum=jn,x.mean=Zt,x.memory=mu,x.metrics=dF,x.min=Jo,x.minimum=Zo,x.mirrorPad=Tp,x.mod=Ep,x.model=ID,x.models=pF,x.moments=Au,x.movingAverage=lS,x.mul=_,x.multiRNNCell=kk,x.multinomial=ib,x.neg=Jt,x.nextFrame=Qu,x.norm=Gu,x.notEqual=yr,x.oneHot=hr,x.ones=Tn,x.onesLike=Le,x.op=D,x.outerProduct=Ak,x.pad=qn,x.pad1d=Fk,x.pad2d=Ok,x.pad3d=Pk,x.pad4d=Mk,x.pool=lb,x.pow=Kn,x.prelu=rl,x.print=my,x.prod=Du,x.profile=uC,x.rand=Kk,x.randomGamma=lI,x.randomNormal=Rp,x.randomUniform=wr,x.range=Ru,x.ready=dC,x.real=ol,x.reciprocal=Fp,x.registerBackend=sp,x.registerCallbackConstructor=ED,x.registerGradient=Kg,x.registerKernel=eu,x.registerOp=wF,x.regularizers=yF,x.relu=Xn,x.relu6=Fu,x.removeBackend=fC,x.reshape=L,x.reverse=Ke,x.reverse1d=yI,x.reverse2d=xI,x.reverse3d=$I,x.reverse4d=CI,x.rfft=cl,x.round=_p,x.rsqrt=_u,x.scalar=ut,x.scatterND=db,x.scatter_util=Jv,x.selu=Ou,x.separableConv2d=Op,x.sequential=SD,x.serialization=Zv,x.setBackend=My,x.setPlatform=yC,x.setdiff1dAsync=cb,x.sigmoid=Gn,x.sign=Lp,x.signal=TT,x.sin=Lu,x.sinh=Pu,x.slice=St,x.slice1d=zu,x.slice2d=Pp,x.slice3d=Mu,x.slice4d=al,x.slice_util=_y,x.softmax=il,x.softplus=Xo,x.spaceToBatchND=sl,x.sparseToDense=Up,x.spectral=ST,x.split=Xe,x.sqrt=Ae,x.square=Ot,x.squaredDifference=Vu,x.squeeze=Fs,x.stack=Ye,x.step=na,x.stridedSlice=zp,x.sub=at,x.sum=ht,x.sumOutType=su,x.tan=Mp,x.tanh=Ho,x.tensor=Sn,x.tensor1d=Je,x.tensor2d=$r,x.tensor3d=vy,x.tensor4d=XI,x.tensor5d=YI,x.tensor6d=JI,x.tensor_util=q$,x.test_util=oC,x.tidy=O,x.tile=Ds,x.time=hC,x.topk=Bp,x.train=Cr,x.transpose=Rt,x.truncatedNormal=ul,x.unique=Wu,x.unregisterGradient=D$,x.unregisterKernel=A$,x.unsortedSegmentSum=Vp,x.unstack=yn,x.upcastType=Ge,x.util=_$,x.valueAndGrad=QN,x.valueAndGrads=tk,x.variable=ub,x.variableGrads=Np,x.version=fK,x.version_converter=Ow,x.version_core=Py,x.version_layers=Th,x.where=Oe,x.whereAsync=Wp,x.zeros=re,x.zerosLike=Ct,Object.defineProperty(x,"__esModule",{value:!0})})});var _e=kK(g$()),gd;async function kn(x){let Gt=document.getElementById("log")||document.createElement("div");Gt.innerHTML+=x+"<br>"}async function y$(x){let Gt=_e.browser.fromPixels(x);kn(`Image loaded: "${x.id}" ${Gt.shape[1]} x ${Gt.shape[0]}`);let Zs=_e.expandDims(Gt,0);Gt.dispose();let fn=_e.cast(Zs,"float32");Zs.dispose();let zr=["filtered_detections/map/TensorArrayStack/TensorArrayGatherV3:0","filtered_detections/map/TensorArrayStack_1/TensorArrayGatherV3:0"];try{let me=await gd.executeAsync(fn,zr);kn("OK"),me&&(kn(`Result[0] shape: ${me[0].shape}`),kn(`Result[1] shape: ${me[1].shape}`))}catch(me){console.error(me),kn("Error"),kn(`<pre>${me.stack}</pre>`)}fn.dispose()}async function IK(){_e.setBackend("webgl"),kn(`Init TFJS: ${_e.version["tfjs-core"]} Backend: ${_e.getBackend()}`),await _e.ready(),kn("Loading model..."),gd=await _e.loadGraphModel("./model/model.json"),kn(`Model loaded: ${gd.modelUrl}`),kn(`Engine state: ${_e.engine().state.numBytes} bytes`),kn(""),await y$(document.getElementById("imgok")),kn(""),await y$(document.getElementById("imgerr")),gd.dispose()}window.onload=IK;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=index.js.map
